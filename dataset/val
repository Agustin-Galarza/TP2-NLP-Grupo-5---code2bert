protected static long getCPtr(SWIGTYPE_p_btAlignedObjectArrayT_int_t obj) {return (obj == null) ? 0 : obj.swigCPtr;}public void set(final RayCastInput rci) {p1.set(rci.p1);p2.set(rci.p2);maxFraction = rci.maxFraction;}public static ByteOrder nativeOrder() {return NATIVE_ORDER;}
public String toString() {return name;}protected PooledEffect newObject() {return new PooledEffect(effect);}
public PooledEffect obtain() {PooledEffect effect = super.obtain();effect.reset();return effect;}
public void reset() {super.reset();}
public void free() {ParticleEffectPool.this.free(this);}public void addMesh(ModelMesh mesh) {for (ModelMesh other : meshes) {if (other.id.equals(mesh.id)) {throw new GdxRuntimeException("Mesh with id '" + other.id + "' already in model");}}meshes.add(mesh);}public void log() {if (TimeUtils.nanoTime() - startTime > 1000000000) /* 1,000,000,000ns == one second */{Gdx.app.log("FPSLogger", "fps: " + Gdx.graphics.getFramesPerSecond());startTime = TimeUtils.nanoTime();}}public void spawnAux(Vector3 vector, float percent) {vector.x = spawnWidth + (spawnWidthDiff * spawnWidthValue.getScale(percent));vector.y = spawnHeight + (spawnHeightDiff * spawnHeightValue.getScale(percent));vector.z = spawnDepth + (spawnDepthDiff * spawnDepthValue.getScale(percent));}
public SpawnShapeValue copy() {return new PointSpawnShapeValue(this);}public AudioDevice newAudioDevice(int samplingRate, boolean isMono) {// TODO Auto-generated method stubreturn null;}
public AudioRecorder newAudioRecorder(int samplingRate, boolean isMono) {// TODO Auto-generated method stubreturn null;}
public Sound newSound(FileHandle fileHandle) {return new IOSSound(fileHandle);}
public Music newMusic(FileHandle fileHandle) {String path = fileHandle.file().getPath().replace('\\', '/');OALAudioTrack track = OALAudioTrack.create();if (track != null) {if (track.preloadFile(path)) {return new IOSMusic(track);}}throw new GdxRuntimeException("Error opening music file at " + path);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btAxisSweep3_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btAxisSweep3 obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btAxisSweep3(swigCPtr);}swigCPtr = 0;}super.delete();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.ClosestNotMeRayResultCallback_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(ClosestNotMeRayResultCallback obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_ClosestNotMeRayResultCallback(swigCPtr);}swigCPtr = 0;}super.delete();}protected static long getCPtr(SWIGTYPE_p_p_btCollisionObject obj) {return (obj == null) ? 0 : obj.swigCPtr;}public float getX() {return x;}
public void setX(float x) {this.x = x;}
public float getY() {return y;}
public void setY(float y) {this.y = y;}
public float getOriginX() {return originX;}
public void setOriginX(float x) {this.originX = x;}
public float getOriginY() {return originY;}
public void setOriginY(float y) {this.originY = y;}
public float getScaleX() {return scaleX;}
public void setScaleX(float x) {this.scaleX = x;}
public float getScaleY() {return scaleY;}
public void setScaleY(float y) {this.scaleY = y;}
public float getRotation() {return rotation;}
public void setRotation(float rotation) {this.rotation = rotation;}
public TextureRegion getTextureRegion() {return textureRegion;}
public void setTextureRegion(TextureRegion region) {textureRegion = region;}public void draw(Batch batch, float x, float y, float width, float height) {patch.draw(batch, x, y, width, height);}
public void setPatch(NinePatch patch) {this.patch = patch;setMinWidth(patch.getTotalWidth());setMinHeight(patch.getTotalHeight());setTopHeight(patch.getPadTop());setRightWidth(patch.getPadRight());setBottomHeight(patch.getPadBottom());setLeftWidth(patch.getPadLeft());}
public NinePatch getPatch() {return patch;}
public NinePatchDrawable tint(Color tint) {NinePatchDrawable drawable = new NinePatchDrawable(this);drawable.setPatch(new NinePatch(drawable.getPatch(), tint));return drawable;}public void update() {update(true);}
public void update(boolean updateFrustum) {float aspect = viewportWidth / viewportHeight;projection.setToProjection(Math.abs(near), Math.abs(far), fieldOfView, aspect);view.setToLookAt(position, tmp.set(position).add(direction), up);combined.set(projection);Matrix4.mul(combined.val, view.val);if (updateFrustum) {invProjectionView.set(combined);Matrix4.inv(invProjectionView.val);frustum.update(invProjectionView);}}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btTriangleShapeEx_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btTriangleShapeEx obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btTriangleShapeEx(swigCPtr);}swigCPtr = 0;}super.delete();}
public void applyTransform(Matrix4 t) {CollisionJNI.btTriangleShapeEx_applyTransform(swigCPtr, this, t);}
public void buildTriPlane(btVector4 plane) {CollisionJNI.btTriangleShapeEx_buildTriPlane(swigCPtr, this, btVector4.getCPtr(plane), plane);}
public boolean overlap_test_conservative(btTriangleShapeEx other) {return CollisionJNI.btTriangleShapeEx_overlap_test_conservative(swigCPtr, this, btTriangleShapeEx.getCPtr(other), other);}public void onAttachedToWindow() {super.onAttachedToWindow();Log.i("Andrew", "hi");AndroidApplicationConfiguration cfg = new AndroidApplicationConfiguration();setInteractive(false);ApplicationListener app = new MeshShaderTest();initialize(app, cfg);}public GridPoint2 set(GridPoint2 point) {this.x = point.x;this.y = point.y;return this;}
public GridPoint2 set(int x, int y) {this.x = x;this.y = y;return this;}
public boolean equals(Object o) {if (this == o)return true;if (o == null || o.getClass() != this.getClass())return false;GridPoint2 g = (GridPoint2) o;return this.x == g.x && this.y == g.y;}
public int hashCode() {final int prime = 53;int result = 1;result = prime * result + this.x;result = prime * result + this.y;return result;}
public String toString() {return "(" + x + ", " + y + ")";}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btCollisionShapeData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btCollisionShapeData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setName(String value) {CollisionJNI.btCollisionShapeData_name_set(swigCPtr, this, value);}
public String getName() {return CollisionJNI.btCollisionShapeData_name_get(swigCPtr, this);}
public void setShapeType(int value) {CollisionJNI.btCollisionShapeData_shapeType_set(swigCPtr, this, value);}
public int getShapeType() {return CollisionJNI.btCollisionShapeData_shapeType_get(swigCPtr, this);}
public void setPadding(String value) {CollisionJNI.btCollisionShapeData_padding_set(swigCPtr, this, value);}
public String getPadding() {return CollisionJNI.btCollisionShapeData_padding_get(swigCPtr, this);}public void draw(Batch batch, float x, float y, float width, float height) {}
public float getLeftWidth() {return leftWidth;}
public void setLeftWidth(float leftWidth) {this.leftWidth = leftWidth;}
public float getRightWidth() {return rightWidth;}
public void setRightWidth(float rightWidth) {this.rightWidth = rightWidth;}
public float getTopHeight() {return topHeight;}
public void setTopHeight(float topHeight) {this.topHeight = topHeight;}
public float getBottomHeight() {return bottomHeight;}
public void setBottomHeight(float bottomHeight) {this.bottomHeight = bottomHeight;}
public float getMinWidth() {return minWidth;}
public void setMinWidth(float minWidth) {this.minWidth = minWidth;}
public float getMinHeight() {return minHeight;}
public void setMinHeight(float minHeight) {this.minHeight = minHeight;}
public String getName() {return name;}
public void setName(String name) {this.name = name;}
public String toString() {if (name == null)return ClassReflection.getSimpleName(getClass());return name;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(DynamicsJNI.btSimpleDynamicsWorld_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btSimpleDynamicsWorld obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btSimpleDynamicsWorld(swigCPtr);}swigCPtr = 0;}super.delete();}
public int stepSimulation(float timeStep, int maxSubSteps, float fixedTimeStep) {return DynamicsJNI.btSimpleDynamicsWorld_stepSimulation__SWIG_0(swigCPtr, this, timeStep, maxSubSteps, fixedTimeStep);}
public int stepSimulation(float timeStep, int maxSubSteps) {return DynamicsJNI.btSimpleDynamicsWorld_stepSimulation__SWIG_1(swigCPtr, this, timeStep, maxSubSteps);}
public int stepSimulation(float timeStep) {return DynamicsJNI.btSimpleDynamicsWorld_stepSimulation__SWIG_2(swigCPtr, this, timeStep);}
public void addRigidBody(btRigidBody body) {DynamicsJNI.btSimpleDynamicsWorld_addRigidBody__SWIG_0(swigCPtr, this, btRigidBody.getCPtr(body), body);}
public void addRigidBody(btRigidBody body, short group, short mask) {DynamicsJNI.btSimpleDynamicsWorld_addRigidBody__SWIG_1(swigCPtr, this, btRigidBody.getCPtr(body), body, group, mask);}public static final boolean is(final long mask) {return (mask & Mask) != 0;}
public static final ColorAttribute createAmbient(final Color color) {return new ColorAttribute(Ambient, color);}
public static final ColorAttribute createAmbient(float r, float g, float b, float a) {return new ColorAttribute(Ambient, r, g, b, a);}
public static final ColorAttribute createDiffuse(final Color color) {return new ColorAttribute(Diffuse, color);}
public static final ColorAttribute createDiffuse(float r, float g, float b, float a) {return new ColorAttribute(Diffuse, r, g, b, a);}
public static final ColorAttribute createSpecular(final Color color) {return new ColorAttribute(Specular, color);}
public static final ColorAttribute createSpecular(float r, float g, float b, float a) {return new ColorAttribute(Specular, r, g, b, a);}
public static final ColorAttribute createReflection(final Color color) {return new ColorAttribute(Reflection, color);}
public static final ColorAttribute createReflection(float r, float g, float b, float a) {return new ColorAttribute(Reflection, r, g, b, a);}
public Attribute copy() {return new ColorAttribute(this);}
public int hashCode() {int result = super.hashCode();result = 953 * result + color.toIntBits();return result;}
public int compareTo(Attribute o) {if (type != o.type)return (int) (type - o.type);return ((ColorAttribute) o).color.toIntBits() - color.toIntBits();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btSphereTriangleCollisionAlgorithm_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btSphereTriangleCollisionAlgorithm obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btSphereTriangleCollisionAlgorithm(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btSphereTriangleCollisionAlgorithm_CreateFunc_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(CreateFunc obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btSphereTriangleCollisionAlgorithm_CreateFunc(swigCPtr);}swigCPtr = 0;}super.delete();}protected void createWorld(World world) {{BodyDef bd = new BodyDef();Body ground = world.createBody(bd);EdgeShape shape = new EdgeShape();shape.set(new Vector2(-40, 0), new Vector2(40, 0));ground.createFixture(shape, 0);shape.dispose();}{CircleShape shape = new CircleShape();shape.setRadius(1.0f);for (int i = 0; i < e_count; i++) {BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.position.set(0, 4.0f + 3.0f * i);Body body = world.createBody(bd);body.createFixture(shape, 1.0f);}shape.dispose();}}public void create() {texture = new Texture(Gdx.files.internal("data/badlogicsmall.jpg"));Sprite sprite = new Sprite(texture);sprite.setSize(tileSize, tileSize);cache = new SpriteCache(1000, false);for (int y = 0; y < tileMapHeight; y++) {cache.beginCache();for (int x = 0; x < tileMapWidth; x++) {sprite.setPosition(x * tileSize, y * tileSize);cache.add(sprite);}cache.endCache();sprite.rotate90(true);}}
public void render() {Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);cache.begin();for (int y = 1; y < tileMapHeight - 1; y++) cache.draw(y, 1, tileMapWidth - 2);cache.end();}
public void dispose() {cache.dispose();texture.dispose();}public MeasuredDimension calcMeasures(int widthMeasureSpec, int heightMeasureSpec) {return new MeasuredDimension(width, height);}protected Vector3 newObject() {return new Vector3();}
protected Quaternion newObject() {return new Quaternion();}
protected Matrix3 newObject() {return new Matrix3();}
protected Matrix4 newObject() {return new Matrix4();}
public static void setGDeactivationTime(float value) {DynamicsJNI.gDeactivationTime_set(value);}
public static float getGDeactivationTime() {return DynamicsJNI.gDeactivationTime_get();}
public static void setGDisableDeactivation(boolean value) {DynamicsJNI.gDisableDeactivation_set(value);}
public static boolean getGDisableDeactivation() {return DynamicsJNI.gDisableDeactivation_get();}
public static float btAdjustAngleToLimits(float angleInRadians, float angleLowerLimitInRadians, float angleUpperLimitInRadians) {return DynamicsJNI.btAdjustAngleToLimits(angleInRadians, angleLowerLimitInRadians, angleUpperLimitInRadians);}
public static void InternalTickCallback_CB(btDynamicsWorld world, float timeStep) {DynamicsJNI.InternalTickCallback_CB(btDynamicsWorld.getCPtr(world), world, timeStep);}
public static float resolveSingleCollision(btRigidBody body1, btCollisionObject colObj2, Vector3 contactPositionWorld, Vector3 contactNormalOnB, btContactSolverInfo solverInfo, float distance) {return DynamicsJNI.resolveSingleCollision(btRigidBody.getCPtr(body1), body1, btCollisionObject.getCPtr(colObj2), colObj2, contactPositionWorld, contactNormalOnB, btContactSolverInfo.getCPtr(solverInfo), solverInfo, distance);}
public static void resolveSingleBilateral(btRigidBody body1, Vector3 pos1, btRigidBody body2, Vector3 pos2, float distance, Vector3 normal, SWIGTYPE_p_float impulse, float timeStep) {DynamicsJNI.resolveSingleBilateral(btRigidBody.getCPtr(body1), body1, pos1, btRigidBody.getCPtr(body2), body2, pos2, distance, normal, SWIGTYPE_p_float.getCPtr(impulse), timeStep);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(BT_BOX_BOX_TRANSFORM_CACHE obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_BT_BOX_BOX_TRANSFORM_CACHE(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setT1to0(btVector3 value) {CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_T1to0_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getT1to0() {long cPtr = CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_T1to0_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setR1to0(Matrix3 value) {CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_R1to0_set(swigCPtr, this, value);}
public Matrix3 getR1to0() {return CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_R1to0_get(swigCPtr, this);}
public void setAR(Matrix3 value) {CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_AR_set(swigCPtr, this, value);}
public Matrix3 getAR() {return CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_AR_get(swigCPtr, this);}
public void calc_absolute_matrix() {CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_calc_absolute_matrix(swigCPtr, this);}
public void calc_from_homogenic(Matrix4 trans0, Matrix4 trans1) {CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_calc_from_homogenic(swigCPtr, this, trans0, trans1);}
public void calc_from_full_invert(Matrix4 trans0, Matrix4 trans1) {CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_calc_from_full_invert(swigCPtr, this, trans0, trans1);}
public Vector3 transform(Vector3 point) {return CollisionJNI.BT_BOX_BOX_TRANSFORM_CACHE_transform(swigCPtr, this, point);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btMultiSphereShapeData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btMultiSphereShapeData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setConvexInternalShapeData(btConvexInternalShapeData value) {CollisionJNI.btMultiSphereShapeData_convexInternalShapeData_set(swigCPtr, this, btConvexInternalShapeData.getCPtr(value), value);}
public btConvexInternalShapeData getConvexInternalShapeData() {long cPtr = CollisionJNI.btMultiSphereShapeData_convexInternalShapeData_get(swigCPtr, this);return (cPtr == 0) ? null : new btConvexInternalShapeData(cPtr, false);}
public void setLocalPositionArrayPtr(btPositionAndRadius value) {CollisionJNI.btMultiSphereShapeData_localPositionArrayPtr_set(swigCPtr, this, btPositionAndRadius.getCPtr(value), value);}
public btPositionAndRadius getLocalPositionArrayPtr() {long cPtr = CollisionJNI.btMultiSphereShapeData_localPositionArrayPtr_get(swigCPtr, this);return (cPtr == 0) ? null : new btPositionAndRadius(cPtr, false);}
public void setLocalPositionArraySize(int value) {CollisionJNI.btMultiSphereShapeData_localPositionArraySize_set(swigCPtr, this, value);}
public int getLocalPositionArraySize() {return CollisionJNI.btMultiSphereShapeData_localPositionArraySize_get(swigCPtr, this);}
public void setPadding(String value) {CollisionJNI.btMultiSphereShapeData_padding_set(swigCPtr, this, value);}
public String getPadding() {return CollisionJNI.btMultiSphereShapeData_padding_get(swigCPtr, this);}public void update(final Camera camera) {update(tmpV.set(camera.direction).scl(halfHeight), camera.direction);}
public void update(final Vector3 center, final Vector3 forward) {// cam.position.set(10,10,10);cam.position.set(direction).scl(-halfDepth).add(center);cam.direction.set(direction).nor();// cam.up.set(forward).nor();cam.normalizeUp();cam.update();}
public void begin(final Camera camera) {update(camera);begin();}
public void begin(final Vector3 center, final Vector3 forward) {update(center, forward);begin();}
public void begin() {final int w = fbo.getWidth();final int h = fbo.getHeight();fbo.begin();Gdx.gl.glViewport(0, 0, w, h);Gdx.gl.glClearColor(1, 1, 1, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);Gdx.gl.glEnable(GL20.GL_SCISSOR_TEST);Gdx.gl.glScissor(1, 1, w - 2, h - 2);}
public void end() {Gdx.gl.glDisable(GL20.GL_SCISSOR_TEST);fbo.end();}
public FrameBuffer getFrameBuffer() {return fbo;}
public Camera getCamera() {return cam;}
public Matrix4 getProjViewTrans() {return cam.combined;}
public TextureDescriptor getDepthMap() {textureDesc.texture = fbo.getColorBufferTexture();return textureDesc;}
public void dispose() {if (fbo != null)fbo.dispose();fbo = null;}protected static long getCPtr(SWIGTYPE_p_btAlignedObjectArrayT_btConvexHullComputer__Edge_t obj) {return (obj == null) ? 0 : obj.swigCPtr;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(InternalTickCallback obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_InternalTickCallback(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void swigDirectorDisconnect() {swigCMemOwn = false;delete();}
public void swigReleaseOwnership() {swigCMemOwn = false;DynamicsJNI.InternalTickCallback_change_ownership(this, swigCPtr, false);}
public void swigTakeOwnership() {swigCMemOwn = true;DynamicsJNI.InternalTickCallback_change_ownership(this, swigCPtr, true);}
public void onInternalTick(btDynamicsWorld dynamicsWorld, float timeStep) {if (getClass() == InternalTickCallback.class)DynamicsJNI.InternalTickCallback_onInternalTick(swigCPtr, this, btDynamicsWorld.getCPtr(dynamicsWorld), dynamicsWorld, timeStep);elseDynamicsJNI.InternalTickCallback_onInternalTickSwigExplicitInternalTickCallback(swigCPtr, this, btDynamicsWorld.getCPtr(dynamicsWorld), dynamicsWorld, timeStep);}
public void detach() {DynamicsJNI.InternalTickCallback_detach__SWIG_0(swigCPtr, this);}
public void attach(btDynamicsWorld dynamicsWorld, boolean isPreTick) {DynamicsJNI.InternalTickCallback_attach__SWIG_0(swigCPtr, this, btDynamicsWorld.getCPtr(dynamicsWorld), dynamicsWorld, isPreTick);}
public void attach() {DynamicsJNI.InternalTickCallback_attach__SWIG_1(swigCPtr, this);}
public static void detach(btDynamicsWorld dynamicsWorld, boolean isPreTick) {DynamicsJNI.InternalTickCallback_detach__SWIG_1(btDynamicsWorld.getCPtr(dynamicsWorld), dynamicsWorld, isPreTick);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btOptimizedBvh_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btOptimizedBvh obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btOptimizedBvh(swigCPtr);}swigCPtr = 0;}super.delete();}
public void build(btStridingMeshInterface triangles, boolean useQuantizedAabbCompression, Vector3 bvhAabbMin, Vector3 bvhAabbMax) {CollisionJNI.btOptimizedBvh_build(swigCPtr, this, btStridingMeshInterface.getCPtr(triangles), triangles, useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax);}
public void refit(btStridingMeshInterface triangles, Vector3 aabbMin, Vector3 aabbMax) {CollisionJNI.btOptimizedBvh_refit(swigCPtr, this, btStridingMeshInterface.getCPtr(triangles), triangles, aabbMin, aabbMax);}
public void refitPartial(btStridingMeshInterface triangles, Vector3 aabbMin, Vector3 aabbMax) {CollisionJNI.btOptimizedBvh_refitPartial(swigCPtr, this, btStridingMeshInterface.getCPtr(triangles), triangles, aabbMin, aabbMax);}
public void updateBvhNodes(btStridingMeshInterface meshInterface, int firstNode, int endNode, int index) {CollisionJNI.btOptimizedBvh_updateBvhNodes(swigCPtr, this, btStridingMeshInterface.getCPtr(meshInterface), meshInterface, firstNode, endNode, index);}
public boolean serializeInPlace(long o_alignedDataBuffer, long i_dataBufferSize, boolean i_swapEndian) {return CollisionJNI.btOptimizedBvh_serializeInPlace(swigCPtr, this, o_alignedDataBuffer, i_dataBufferSize, i_swapEndian);}
public static btOptimizedBvh deSerializeInPlace(long i_alignedDataBuffer, long i_dataBufferSize, boolean i_swapEndian) {long cPtr = CollisionJNI.btOptimizedBvh_deSerializeInPlace(i_alignedDataBuffer, i_dataBufferSize, i_swapEndian);return (cPtr == 0) ? null : new btOptimizedBvh(cPtr, false);}public boolean isGL30Available() {return false;}
public GL20 getGL20() {return null;}
public GL30 getGL30() {return null;}
public int getWidth() {return 0;}
public int getHeight() {return 0;}
public long getFrameId() {return frameId;}
public float getDeltaTime() {return deltaTime;}
public float getRawDeltaTime() {return 0;}
public int getFramesPerSecond() {return 0;}
public GraphicsType getType() {return GraphicsType.Mock;}
public float getPpiX() {return 0;}
public float getPpiY() {return 0;}
public float getPpcX() {return 0;}
public float getPpcY() {return 0;}
public float getDensity() {return 0;}
public boolean supportsDisplayModeChange() {return false;}
public DisplayMode[] getDisplayModes() {return new DisplayMode[0];}
public DisplayMode getDesktopDisplayMode() {return null;}
public boolean setDisplayMode(DisplayMode displayMode) {return false;}
public boolean setDisplayMode(int width, int height, boolean fullscreen) {return false;}
public void setTitle(String title) {}
public void setVSync(boolean vsync) {}
public BufferFormat getBufferFormat() {return null;}
public boolean supportsExtension(String extension) {return false;}
public void setContinuousRendering(boolean isContinuous) {}
public boolean isContinuousRendering() {return false;}
public void requestRendering() {}
public boolean isFullscreen() {return false;}
public void updateTime() {long time = System.nanoTime();deltaTime = (time - lastTime) / 1000000000.0f;lastTime = time;if (time - frameStart >= 1000000000) {fps = frames;frames = 0;frameStart = time;}frames++;}
public void incrementFrameId() {frameId++;}
public Cursor newCursor(Pixmap pixmap, int xHotspot, int yHotspot) {return null;}
public void setCursor(Cursor cursor) {}static ReadWriteShortArrayBuffer copy(ShortArrayBuffer other, int markOfOther) {ReadWriteShortArrayBuffer buf = new ReadWriteShortArrayBuffer(other.capacity(), other.backingArray, other.offset);buf.limit = other.limit();buf.position = other.position();buf.mark = markOfOther;return buf;}
public ShortBuffer asReadOnlyBuffer() {return ReadOnlyShortArrayBuffer.copy(this, mark);}
public ShortBuffer compact() {System.arraycopy(backingArray, position + offset, backingArray, offset, remaining());position = limit - position;limit = capacity;mark = UNSET_MARK;return this;}
public ShortBuffer duplicate() {return copy(this, mark);}
public boolean isReadOnly() {return false;}
protected short[] protectedArray() {return backingArray;}
protected int protectedArrayOffset() {return offset;}
protected boolean protectedHasArray() {return true;}
public ShortBuffer put(short c) {if (position == limit) {throw new BufferOverflowException();}backingArray[offset + position++] = c;return this;}
public ShortBuffer put(int index, short c) {if (index < 0 || index >= limit) {throw new IndexOutOfBoundsException();}backingArray[offset + index] = c;return this;}
public ShortBuffer put(short[] src, int off, int len) {int length = src.length;if (off < 0 || len < 0 || (long) off + (long) len > length) {throw new IndexOutOfBoundsException();}if (len > remaining()) {throw new BufferOverflowException();}System.arraycopy(src, off, backingArray, offset + position, len);position += len;return this;}
public ShortBuffer slice() {return new ReadWriteShortArrayBuffer(remaining(), backingArray, offset + position);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btBox2dShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btBox2dShape obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btBox2dShape(swigCPtr);}swigCPtr = 0;}super.delete();}
public Vector3 getHalfExtentsWithMargin() {return CollisionJNI.btBox2dShape_getHalfExtentsWithMargin(swigCPtr, this);}
public Vector3 getHalfExtentsWithoutMargin() {return CollisionJNI.btBox2dShape_getHalfExtentsWithoutMargin(swigCPtr, this);}
public int getVertexCount() {return CollisionJNI.btBox2dShape_getVertexCount(swigCPtr, this);}
public btVector3 getVertices() {long cPtr = CollisionJNI.btBox2dShape_getVertices(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public btVector3 getNormals() {long cPtr = CollisionJNI.btBox2dShape_getNormals(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public Vector3 getCentroid() {return CollisionJNI.btBox2dShape_getCentroid(swigCPtr, this);}
public void getPlaneEquation(btVector4 plane, int i) {CollisionJNI.btBox2dShape_getPlaneEquation(swigCPtr, this, btVector4.getCPtr(plane), plane, i);}public boolean needsCollision(btCollisionObject body0, btCollisionObject body1) {if (body0.getUserValue() % 2 == 0 || body1.getUserValue() % 2 == 0)return super.needsCollision(body0, body1);return false;}
public boolean needsResponse(btCollisionObject body0, btCollisionObject body1) {if (body0.getUserValue() % 2 == 0 || body1.getUserValue() % 2 == 0)return super.needsCollision(body0, body1);return false;}
public BulletWorld createWorld() {btDefaultCollisionConfiguration collisionConfiguration = new btDefaultCollisionConfiguration();MyCollisionDispatcher dispatcher = new MyCollisionDispatcher(collisionConfiguration);btDbvtBroadphase broadphase = new btDbvtBroadphase();btSequentialImpulseConstraintSolver solver = new btSequentialImpulseConstraintSolver();btDiscreteDynamicsWorld collisionWorld = new btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);return new BulletWorld(collisionConfiguration, dispatcher, broadphase, solver, collisionWorld);}
public void create() {super.create();// Create the entitiesworld.add("ground", 0f, 0f, 0f).setColor(0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 1f);for (float x = -5f; x <= 5f; x += 2f) {for (float y = 5f; y <= 15f; y += 2f) {world.add("box", x + 0.1f * MathUtils.random(), y + 0.1f * MathUtils.random(), 0.1f * MathUtils.random()).body.setUserValue((int) ((x + 5f) / 2f + .5f));}}}
public boolean tap(float x, float y, int count, int button) {shoot(x, y);return true;}public int getStatusCode() {return statusCode;}public TextureDataType getType() {return TextureDataType.Custom;}
public boolean isPrepared() {return isPrepared;}
public void prepare() {if (isPrepared)throw new GdxRuntimeException("Already prepared");this.buffer = BufferUtils.newFloatBuffer(width * height * 4);isPrepared = true;}
public void consumeCustomData(int target) {if (Gdx.app.getType() == ApplicationType.Android || Gdx.app.getType() == ApplicationType.iOS || Gdx.app.getType() == ApplicationType.WebGL) {if (!Gdx.graphics.supportsExtension("OES_texture_float"))throw new GdxRuntimeException("Extension OES_texture_float not supported!");// so to get a float texture one needs to supply GL_RGBA and GL_FLOAT there.Gdx.gl.glTexImage2D(target, 0, GL20.GL_RGBA, width, height, 0, GL20.GL_RGBA, GL20.GL_FLOAT, buffer);} else {if (!Gdx.graphics.supportsExtension("GL_ARB_texture_float"))throw new GdxRuntimeException("Extension GL_ARB_texture_float not supported!");// this is a const from GL 3.0, used only on desktopsfinal int GL_RGBA32F = 34836;// hence we need to use GL_RGBA32F there (this constant is unavailable in GLES/WebGL)Gdx.gl.glTexImage2D(target, 0, GL_RGBA32F, width, height, 0, GL20.GL_RGBA, GL20.GL_FLOAT, buffer);}}
public Pixmap consumePixmap() {throw new GdxRuntimeException("This TextureData implementation does not return a Pixmap");}
public boolean disposePixmap() {throw new GdxRuntimeException("This TextureData implementation does not return a Pixmap");}
public int getWidth() {return width;}
public int getHeight() {return height;}
public Format getFormat() {// it's not true, but FloatTextureData.getFormat() isn't used anywherereturn Format.RGBA8888;}
public boolean useMipMaps() {return false;}
public boolean isManaged() {return true;}protected Vector3 newObject() {return new Vector3();}
protected Quaternion newObject() {return new Quaternion();}
protected Matrix3 newObject() {return new Matrix3();}
protected Matrix4 newObject() {return new Matrix4();}public int floatToIntBits(float f) {return Numbers.floatToIntBits(f);}
public float intBitsToFloat(int i) {return Numbers.intBitsToFloat(i);}
public String createString(byte[] b, int ofs, int length) {// TODO Auto-generated method stubreturn null;}
public String getOriginatingServerAddress() {// TODO Auto-generated method stubreturn null;}
public void printStackTrace(Throwable e) {}
public String createString(byte[] b, String encoding) {// TODO Auto-generated method stubreturn null;}
public void sleep(int i) {}static CharBuffer wrap(ByteBuffer byteBuffer) {return new CharToByteBufferAdapter(byteBuffer.slice());}
public CharBuffer asReadOnlyBuffer() {CharToByteBufferAdapter buf = new CharToByteBufferAdapter(byteBuffer.asReadOnlyBuffer());buf.limit = limit;buf.position = position;buf.mark = mark;return buf;}
public CharBuffer compact() {if (byteBuffer.isReadOnly()) {throw new ReadOnlyBufferException();}byteBuffer.limit(limit << 1);byteBuffer.position(position << 1);byteBuffer.compact();byteBuffer.clear();position = limit - position;limit = capacity;mark = UNSET_MARK;return this;}
public CharBuffer duplicate() {CharToByteBufferAdapter buf = new CharToByteBufferAdapter(byteBuffer.duplicate());buf.limit = limit;buf.position = position;buf.mark = mark;return buf;}
public char get() {if (position == limit) {throw new BufferUnderflowException();}return byteBuffer.getChar(position++ << 1);}
public char get(int index) {if (index < 0 || index >= limit) {throw new IndexOutOfBoundsException();}return byteBuffer.getChar(index << 1);}
public boolean isDirect() {return byteBuffer.isDirect();}
public boolean isReadOnly() {return byteBuffer.isReadOnly();}
public ByteOrder order() {return byteBuffer.order();}
protected char[] protectedArray() {throw new UnsupportedOperationException();}
protected int protectedArrayOffset() {throw new UnsupportedOperationException();}
protected boolean protectedHasArray() {return false;}
public CharBuffer put(char c) {if (position == limit) {throw new BufferOverflowException();}byteBuffer.putChar(position++ << 1, c);return this;}
public CharBuffer put(int index, char c) {if (index < 0 || index >= limit) {throw new IndexOutOfBoundsException();}byteBuffer.putChar(index << 1, c);return this;}
public CharBuffer slice() {byteBuffer.limit(limit << 1);byteBuffer.position(position << 1);CharBuffer result = new CharToByteBufferAdapter(byteBuffer.slice());byteBuffer.clear();return result;}
public CharSequence subSequence(int start, int end) {if (start < 0 || end < start || end > remaining()) {throw new IndexOutOfBoundsException();}CharBuffer result = duplicate();result.limit(position + end);result.position(position + start);return result;}static ReadWriteLongArrayBuffer copy(LongArrayBuffer other, int markOfOther) {ReadWriteLongArrayBuffer buf = new ReadWriteLongArrayBuffer(other.capacity(), other.backingArray, other.offset);buf.limit = other.limit();buf.position = other.position();buf.mark = markOfOther;return buf;}
public LongBuffer asReadOnlyBuffer() {return ReadOnlyLongArrayBuffer.copy(this, mark);}
public LongBuffer compact() {System.arraycopy(backingArray, position + offset, backingArray, offset, remaining());position = limit - position;limit = capacity;mark = UNSET_MARK;return this;}
public LongBuffer duplicate() {return copy(this, mark);}
public boolean isReadOnly() {return false;}
protected long[] protectedArray() {return backingArray;}
protected int protectedArrayOffset() {return offset;}
protected boolean protectedHasArray() {return true;}
public LongBuffer put(long c) {if (position == limit) {throw new BufferOverflowException();}backingArray[offset + position++] = c;return this;}
public LongBuffer put(int index, long c) {if (index < 0 || index >= limit) {throw new IndexOutOfBoundsException();}backingArray[offset + index] = c;return this;}
public LongBuffer put(long[] src, int off, int len) {int length = src.length;if (off < 0 || len < 0 || (long) off + (long) len > length) {throw new IndexOutOfBoundsException();}if (len > remaining()) {throw new BufferOverflowException();}System.arraycopy(src, off, backingArray, offset + position, len);position += len;return this;}
public LongBuffer slice() {return new ReadWriteLongArrayBuffer(remaining(), backingArray, offset + position);}public void set(final ManifoldPoint cp) {localPoint.set(cp.localPoint);normalImpulse = cp.normalImpulse;tangentImpulse = cp.tangentImpulse;id.set(cp.id);}public long nextLong() {long s1 = this.seed0;final long s0 = this.seed1;this.seed0 = s0;s1 ^= s1 << 23;return (this.seed1 = (s1 ^ s0 ^ (s1 >>> 17) ^ (s0 >>> 26))) + s0;}
protected final int next(int bits) {return (int) (nextLong() & ((1L << bits) - 1));}
public int nextInt() {return (int) nextLong();}
public int nextInt(final int n) {return (int) nextLong(n);}
public long nextLong(final long n) {if (n <= 0)throw new IllegalArgumentException("n must be positive");for (; ; ) {final long bits = nextLong() >>> 1;final long value = bits % n;if (bits - value + (n - 1) >= 0)return value;}}
public double nextDouble() {return (nextLong() >>> 11) * NORM_DOUBLE;}
public float nextFloat() {return (float) ((nextLong() >>> 40) * NORM_FLOAT);}
public boolean nextBoolean() {return (nextLong() & 1) != 0;}
public void nextBytes(final byte[] bytes) {int n = 0;int i = bytes.length;while (i != 0) {// min(i, 8);n = i < 8 ? i : 8;for (long bits = nextLong(); n-- != 0; bits >>= 8) bytes[--i] = (byte) bits;}}
public void setSeed(final long seed) {long seed0 = murmurHash3(seed == 0 ? Long.MIN_VALUE : seed);setState(seed0, murmurHash3(seed0));}
public void setState(final long seed0, final long seed1) {this.seed0 = seed0;this.seed1 = seed1;}
public long getState(int seed) {return seed == 0 ? seed0 : seed1;}
private static final long murmurHash3(long x) {x ^= x >>> 33;x *= 0xff51afd7ed558ccdL;x ^= x >>> 33;x *= 0xc4ceb9fe1a85ec53L;x ^= x >>> 33;return x;}public void create() {modelBatch = new ModelBatch();environment = new Environment();environment.set(new ColorAttribute(ColorAttribute.AmbientLight, 0.4f, 0.4f, 0.4f, 1.f));environment.set(new ColorAttribute(ColorAttribute.Fog, 0.13f, 0.13f, 0.13f, 1f));environment.add(new DirectionalLight().set(0.8f, 0.8f, 0.8f, -1f, -0.8f, -0.2f));cam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());cam.position.set(30f, 10f, 30f);cam.lookAt(0, 0, 0);cam.near = 0.1f;cam.far = 45f;cam.update();ModelBuilder modelBuilder = new ModelBuilder();model = modelBuilder.createBox(5f, 5f, 5f, new Material(ColorAttribute.createDiffuse(Color.GREEN)), Usage.Position | Usage.Normal);instance = new ModelInstance(model);Gdx.input.setInputProcessor(new InputMultiplexer(this, inputController = new CameraInputController(cam)));}
public void render() {animate();inputController.update();Gdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);Gdx.gl.glClearColor(0.13f, 0.13f, 0.13f, 1);modelBatch.begin(cam);modelBatch.render(instance, environment);modelBatch.end();}
private void animate() {delta = Gdx.graphics.getDeltaTime();instance.transform.val[14] += delta * 4 * dir;if (Math.abs(instance.transform.val[14]) > 5) {dir *= -1;}}
public void dispose() {modelBatch.dispose();model.dispose();}
public boolean needsGL20() {return true;}
public void resume() {}
public void resize(int width, int height) {}
public void pause() {}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btEmptyAlgorithm_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btEmptyAlgorithm obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btEmptyAlgorithm(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(CreateFunc obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btEmptyAlgorithm_CreateFunc(swigCPtr);}swigCPtr = 0;}super.delete();}
public btCollisionAlgorithm CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo ci, btCollisionObjectWrapper body0Wrap, btCollisionObjectWrapper body1Wrap) {long cPtr = CollisionJNI.btEmptyAlgorithm_CreateFunc_CreateCollisionAlgorithm(swigCPtr, this, btCollisionAlgorithmConstructionInfo.getCPtr(ci), ci, btCollisionObjectWrapper.getCPtr(body0Wrap), body0Wrap, btCollisionObjectWrapper.getCPtr(body1Wrap), body1Wrap);return (cPtr == 0) ? null : new btCollisionAlgorithm(cPtr, false);}public void setValue(ModelInfluencer value) {super.setValue(value);if (value == null)return;pickerPanel.setValue(value.models);}
protected void initializeComponents() {super.initializeComponents();pickerPanel = new TemplatePickerPanel<Model>(editor, null, this, Model.class, new LoaderButton.ModelLoaderButton(editor));pickerPanel.setIsAlwayShown(true);contentPanel.add(pickerPanel, new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(0, 0, 0, 6), 0, 0));}
public void onTemplateChecked(Model model, boolean isChecked) {editor.restart();}
public void handle(int aEventType, Object aEventData) {if (aEventType == FlameMain.EVT_ASSET_RELOADED) {Object[] data = (Object[]) aEventData;if (data[0] instanceof Model) {if (value.models.removeValue((Model) data[0], true)) {value.models.add((Model) data[1]);pickerPanel.reloadTemplates();pickerPanel.setValue(value.models);editor.restart();}}}}public void dispose() {recorder.stop();recorder.release();}
public void read(short[] samples, int offset, int numSamples) {int read = 0;while (read != numSamples) {read += recorder.read(samples, offset + read, numSamples - read);}}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btGeneric6DofSpringConstraintData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btGeneric6DofSpringConstraintData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void set6dofData(btGeneric6DofConstraintData value) {DynamicsJNI.btGeneric6DofSpringConstraintData_6dofData_set(swigCPtr, this, btGeneric6DofConstraintData.getCPtr(value), value);}
public btGeneric6DofConstraintData get6dofData() {long cPtr = DynamicsJNI.btGeneric6DofSpringConstraintData_6dofData_get(swigCPtr, this);return (cPtr == 0) ? null : new btGeneric6DofConstraintData(cPtr, false);}
public void setSpringEnabled(int[] value) {DynamicsJNI.btGeneric6DofSpringConstraintData_springEnabled_set(swigCPtr, this, value);}
public int[] getSpringEnabled() {return DynamicsJNI.btGeneric6DofSpringConstraintData_springEnabled_get(swigCPtr, this);}
public void setEquilibriumPoint(float[] value) {DynamicsJNI.btGeneric6DofSpringConstraintData_equilibriumPoint_set(swigCPtr, this, value);}
public float[] getEquilibriumPoint() {return DynamicsJNI.btGeneric6DofSpringConstraintData_equilibriumPoint_get(swigCPtr, this);}
public void setSpringStiffness(float[] value) {DynamicsJNI.btGeneric6DofSpringConstraintData_springStiffness_set(swigCPtr, this, value);}
public float[] getSpringStiffness() {return DynamicsJNI.btGeneric6DofSpringConstraintData_springStiffness_get(swigCPtr, this);}
public void setSpringDamping(float[] value) {DynamicsJNI.btGeneric6DofSpringConstraintData_springDamping_set(swigCPtr, this, value);}
public float[] getSpringDamping() {return DynamicsJNI.btGeneric6DofSpringConstraintData_springDamping_get(swigCPtr, this);}public boolean act(float delta) {if (!removed) {removed = true;target.remove();}return true;}
public void restart() {removed = false;}public void create() {texture = new Texture(Gdx.files.internal("data/badlogic.jpg"), true);texture.setFilter(TextureFilter.MipMap, TextureFilter.Linear);ObjLoader objLoader = new ObjLoader();mesh = objLoader.loadModel(Gdx.files.internal("data/cube.obj"));mesh.materials.get(0).set(new TextureAttribute(TextureAttribute.Diffuse, texture));modelInstance = new ModelInstance(mesh);modelBatch = new ModelBatch();cam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());cam.position.set(3, 3, 3);cam.direction.set(-1, -1, -1);batch = new SpriteBatch();font = new BitmapFont();}
public void render() {Gdx.gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());Gdx.gl.glClearColor(clearColor.g, clearColor.g, clearColor.b, clearColor.a);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT);Gdx.gl.glEnable(GL20.GL_DEPTH_TEST);Gdx.gl.glEnable(GL20.GL_TEXTURE_2D);cam.update();modelInstance.transform.rotate(Vector3.Y, 45 * Gdx.graphics.getDeltaTime());modelBatch.begin(cam);modelBatch.render(modelInstance);modelBatch.end();if (Gdx.input.justTouched() || fbTexture == null) {if (fbTexture != null)fbTexture.getTexture().dispose();fbTexture = ScreenUtils.getFrameBufferTexture();}batch.begin();if (fbTexture != null) {batch.draw(fbTexture, 0, 0, 100, 100);}font.draw(batch, "Touch screen to take a snapshot", 10, 40);batch.end();}
public void pause() {fbTexture = null;}public Dependency getDependency(ProjectDependency gdx) {return gdxDependencies.get(gdx);}
public String[] getDependencies(ProjectType type) {switch(type) {case CORE:return coreDependencies;case DESKTOP:return desktopDependencies;case ANDROID:return androidDependencies;case IOS:return iosDependencies;case HTML:return gwtDependencies;}return null;}
public String[] getGwtInherits() {return gwtInherits;}
public String getDescription() {return description;}
public String getName() {return name;}
public String[] getPlugins() {return plugins;}public void create() {music = Gdx.audio.newMusic(Gdx.files.internal("data/8.12.mp3"));music.play();buttons = new TextureRegion(new Texture(Gdx.files.internal("data/playback.png")));batch = new SpriteBatch();font = new BitmapFont(Gdx.files.internal("data/arial-15.fnt"), false);stage = new Stage();Skin skin = new Skin(Gdx.files.internal("data/uiskin.json"));slider = new Slider(0, 100, 0.1f, false, skin);slider.setPosition(200, 20);slider.addListener(new ChangeListener() {
@Overridepublic void changed(ChangeEvent event, Actor actor) {if (!sliderUpdating && slider.isDragging())music.setPosition((slider.getValue() / 100f) * songDuration);}});stage.addActor(slider);Gdx.input.setInputProcessor(stage);}
public void changed(ChangeEvent event, Actor actor) {if (!sliderUpdating && slider.isDragging())music.setPosition((slider.getValue() / 100f) * songDuration);}
public void resize(int width, int height) {batch.getProjectionMatrix().setToOrtho2D(0, 0, width, height);}
public void resume() {System.out.println(Gdx.graphics.getDeltaTime());}
public void render() {currentPosition = music.getPosition();Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);batch.begin();batch.draw(buttons, 0, 0);font.draw(batch, (int) currentPosition / 60 + ":" + (int) currentPosition % 60, 365, 35);batch.end();sliderUpdating = true;slider.setValue((currentPosition / songDuration) * 100f);sliderUpdating = false;stage.act();stage.draw();if (Gdx.input.justTouched()) {if (Gdx.input.getY() > Gdx.graphics.getHeight() - 64) {if (Gdx.input.getX() < 64) {music.play();}if (Gdx.input.getX() > 64 && Gdx.input.getX() < 128) {music.stop();}if (Gdx.input.getX() > 128 && Gdx.input.getX() < 192) {music.pause();}}}}
public void dispose() {batch.dispose();buttons.getTexture().dispose();music.dispose();}public static void copyStream(InputStream input, OutputStream output) {copyStream(input, output, new byte[DEFAULT_BUFFER_SIZE]);}
public static void copyStream(InputStream input, OutputStream output, int bufferSize) {copyStream(input, output, new byte[bufferSize]);}
public static void copyStream(InputStream input, OutputStream output, byte[] buffer) {int bytesRead;while ((bytesRead = input.read(buffer)) != -1) {output.write(buffer, 0, bytesRead);}}
public static void copyStream(InputStream input, ByteBuffer output) {copyStream(input, output, new byte[DEFAULT_BUFFER_SIZE]);}
public static void copyStream(InputStream input, ByteBuffer output, int bufferSize) {copyStream(input, output, new byte[bufferSize]);}
public static int copyStream(InputStream input, ByteBuffer output, byte[] buffer) {int startPosition = output.position(), total = 0, bytesRead;while ((bytesRead = input.read(buffer)) != -1) {BufferUtils.copy(buffer, 0, output, bytesRead);total += bytesRead;output.position(startPosition + total);}output.position(startPosition);return total;}
public static byte[] copyStreamToByteArray(InputStream input) {return copyStreamToByteArray(input, input.available());}
public static byte[] copyStreamToByteArray(InputStream input, int estimatedSize) {ByteArrayOutputStream baos = new OptimizedByteArrayOutputStream(Math.max(0, estimatedSize));copyStream(input, baos);return baos.toByteArray();}
public static String copyStreamToString(InputStream input) {return copyStreamToString(input, input.available(), null);}
public static String copyStreamToString(InputStream input, int estimatedSize) {return copyStreamToString(input, estimatedSize, null);}
public static String copyStreamToString(InputStream input, int estimatedSize, String charset) {InputStreamReader reader = charset == null ? new InputStreamReader(input) : new InputStreamReader(input, charset);StringWriter writer = new StringWriter(Math.max(0, estimatedSize));char[] buffer = new char[DEFAULT_BUFFER_SIZE];int charsRead;while ((charsRead = reader.read(buffer)) != -1) {writer.write(buffer, 0, charsRead);}return writer.toString();}
public static void closeQuietly(Closeable c) {if (c != null) {try {c.close();} catch (Exception ignored) {}}}
public synchronized byte[] toByteArray() {if (count == buf.length)return buf;return super.toByteArray();}
public byte[] getBuffer() {return buf;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btOptimizedBvhNode obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btOptimizedBvhNode(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setAabbMinOrg(btVector3 value) {CollisionJNI.btOptimizedBvhNode_aabbMinOrg_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getAabbMinOrg() {long cPtr = CollisionJNI.btOptimizedBvhNode_aabbMinOrg_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setAabbMaxOrg(btVector3 value) {CollisionJNI.btOptimizedBvhNode_aabbMaxOrg_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getAabbMaxOrg() {long cPtr = CollisionJNI.btOptimizedBvhNode_aabbMaxOrg_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setEscapeIndex(int value) {CollisionJNI.btOptimizedBvhNode_escapeIndex_set(swigCPtr, this, value);}
public int getEscapeIndex() {return CollisionJNI.btOptimizedBvhNode_escapeIndex_get(swigCPtr, this);}
public void setSubPart(int value) {CollisionJNI.btOptimizedBvhNode_subPart_set(swigCPtr, this, value);}
public int getSubPart() {return CollisionJNI.btOptimizedBvhNode_subPart_get(swigCPtr, this);}
public void setTriangleIndex(int value) {CollisionJNI.btOptimizedBvhNode_triangleIndex_set(swigCPtr, this, value);}
public int getTriangleIndex() {return CollisionJNI.btOptimizedBvhNode_triangleIndex_get(swigCPtr, this);}
public void setPadding(String value) {CollisionJNI.btOptimizedBvhNode_padding_set(swigCPtr, this, value);}
public String getPadding() {return CollisionJNI.btOptimizedBvhNode_padding_get(swigCPtr, this);}public void create() {Gdx.net.openURI("http://libgdx.badlogicgames.com");}public Texture load(String fileName) {Texture result = new Texture(Gdx.files.internal(fileName));result.setFilter(Texture.TextureFilter.Linear, Texture.TextureFilter.Linear);result.setWrap(Texture.TextureWrap.Repeat, Texture.TextureWrap.Repeat);return result;}
public Texture load(String fileName) {return assetManager.get(fileName, Texture.class);}public void create() {font = new BitmapFont(Gdx.files.internal("data/arial-15.fnt"), false);batch = new SpriteBatch();texture = new Texture(Gdx.files.internal("data/badlogicsmall.jpg"));}
public void render() {Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);batch.begin();float width = (int) (Gdx.graphics.getPpcX() * 2);float height = (int) (Gdx.graphics.getPpcY() * 1);batch.draw(texture, 10, 100, width, height, 0, 0, 64, 32, false, false);font.draw(batch, "button is 2x1 cm (" + width + "x" + height + "px), ppi: (" + Gdx.graphics.getPpiX() + "," + Gdx.graphics.getPpiY() + "), ppc: (" + Gdx.graphics.getPpcX() + "," + Gdx.graphics.getPpcY() + ")", 10, 50);batch.end();}
public void dispose() {font.dispose();batch.dispose();texture.dispose();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.AllHitsRayResultCallback_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(AllHitsRayResultCallback obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_AllHitsRayResultCallback(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void swigDirectorDisconnect() {swigCMemOwn = false;delete();}
public void swigReleaseOwnership() {swigCMemOwn = false;CollisionJNI.AllHitsRayResultCallback_change_ownership(this, swigCPtr, false);}
public void swigTakeOwnership() {swigCMemOwn = true;CollisionJNI.AllHitsRayResultCallback_change_ownership(this, swigCPtr, true);}
public void setCollisionObjects(btCollisionObjectConstArray value) {CollisionJNI.AllHitsRayResultCallback_collisionObjects_set(swigCPtr, this, btCollisionObjectConstArray.getCPtr(value), value);}
public btCollisionObjectConstArray getCollisionObjects() {long cPtr = CollisionJNI.AllHitsRayResultCallback_collisionObjects_get(swigCPtr, this);return (cPtr == 0) ? null : new btCollisionObjectConstArray(cPtr, false);}
public void setHitNormalWorld(btVector3Array value) {CollisionJNI.AllHitsRayResultCallback_hitNormalWorld_set(swigCPtr, this, btVector3Array.getCPtr(value), value);}
public btVector3Array getHitNormalWorld() {long cPtr = CollisionJNI.AllHitsRayResultCallback_hitNormalWorld_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3Array(cPtr, false);}
public void setHitPointWorld(btVector3Array value) {CollisionJNI.AllHitsRayResultCallback_hitPointWorld_set(swigCPtr, this, btVector3Array.getCPtr(value), value);}
public btVector3Array getHitPointWorld() {long cPtr = CollisionJNI.AllHitsRayResultCallback_hitPointWorld_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3Array(cPtr, false);}
public void setHitFractions(btScalarArray value) {CollisionJNI.AllHitsRayResultCallback_hitFractions_set(swigCPtr, this, btScalarArray.getCPtr(value), value);}
public btScalarArray getHitFractions() {long cPtr = CollisionJNI.AllHitsRayResultCallback_hitFractions_get(swigCPtr, this);return (cPtr == 0) ? null : new btScalarArray(cPtr, false);}
public float addSingleResult(LocalRayResult rayResult, boolean normalInWorldSpace) {return (getClass() == AllHitsRayResultCallback.class) ? CollisionJNI.AllHitsRayResultCallback_addSingleResult(swigCPtr, this, LocalRayResult.getCPtr(rayResult), rayResult, normalInWorldSpace) : CollisionJNI.AllHitsRayResultCallback_addSingleResultSwigExplicitAllHitsRayResultCallback(swigCPtr, this, LocalRayResult.getCPtr(rayResult), rayResult, normalInWorldSpace);}
public void getRayFromWorld(Vector3 out) {CollisionJNI.AllHitsRayResultCallback_getRayFromWorld(swigCPtr, this, out);}
public void setRayFromWorld(Vector3 value) {CollisionJNI.AllHitsRayResultCallback_setRayFromWorld(swigCPtr, this, value);}
public void getRayToWorld(Vector3 out) {CollisionJNI.AllHitsRayResultCallback_getRayToWorld(swigCPtr, this, out);}
public void setRayToWorld(Vector3 value) {CollisionJNI.AllHitsRayResultCallback_setRayToWorld(swigCPtr, this, value);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btCapsuleShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btCapsuleShape obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btCapsuleShape(swigCPtr);}swigCPtr = 0;}super.delete();}
public int getUpAxis() {return CollisionJNI.btCapsuleShape_getUpAxis(swigCPtr, this);}
public float getRadius() {return CollisionJNI.btCapsuleShape_getRadius(swigCPtr, this);}
public float getHalfHeight() {return CollisionJNI.btCapsuleShape_getHalfHeight(swigCPtr, this);}
public void deSerializeFloat(btCapsuleShapeData dataBuffer) {CollisionJNI.btCapsuleShape_deSerializeFloat(swigCPtr, this, btCapsuleShapeData.getCPtr(dataBuffer), dataBuffer);}protected static long getCPtr(SWIGTYPE_p_btAlignedObjectArrayT_btSoftBody__SContact_t obj) {return (obj == null) ? 0 : obj.swigCPtr;}public void draw(Batch batch, float parentAlpha) {// if this actor is not within the view of the camera we don't draw it.if (isCulled())return;// otherwise we draw via the super class methodsuper.draw(batch, parentAlpha);}
private boolean isCulled() {// Group.float stageX = getX();float stageY = getY();// parents are rotated or scaled!Actor parent = this.getParent();while (parent != null) {stageX += parent.getX();stageY += parent.getY();parent = parent.getParent();}// not rotated!actorRect.set(stageX, stageY, getWidth(), getHeight());camRect.set(camera.position.x - camera.viewportWidth / 2.0f, camera.position.y - camera.viewportHeight / 2.0f, camera.viewportWidth, camera.viewportHeight);visible = camRect.overlaps(actorRect);return !visible;}
public void create() {// create a stage and a camera controller so we can pan the view.stage = new Stage();;// we know it's an ortho cam at this point!camController = new OrthoCamController((OrthographicCamera) stage.getCamera());Gdx.input.setInputProcessor(camController);// load a dummy texturetexture = new Texture(Gdx.files.internal("data/badlogicsmall.jpg"));// populate the stage with some actors and groups.for (int i = 0; i < 5000; i++) {Actor img = new CullableActor("img" + i, texture, (OrthographicCamera) stage.getCamera());img.setX((float) Math.random() * 480 * 10);img.setY((float) Math.random() * 320 * 10);stage.addActor(img);}// we also want to output the number of visible actors, so we need a SpriteBatch and a BitmapFontbatch = new SpriteBatch();font = new BitmapFont(Gdx.files.internal("data/arial-15.fnt"), false);}
public void render() {Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);stage.draw();// check how many actors are visible.Array<Actor> actors = stage.getActors();int numVisible = 0;for (int i = 0; i < actors.size; i++) {numVisible += ((CullableActor) actors.get(i)).visible ? 1 : 0;}batch.begin();font.draw(batch, "Visible: " + numVisible + ", fps: " + Gdx.graphics.getFramesPerSecond(), 20, 30);batch.end();}
public void dispose() {stage.dispose();texture.dispose();batch.dispose();font.dispose();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btElement obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btElement(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setId(int value) {CollisionJNI.btElement_id_set(swigCPtr, this, value);}
public int getId() {return CollisionJNI.btElement_id_get(swigCPtr, this);}
public void setSz(int value) {CollisionJNI.btElement_sz_set(swigCPtr, this, value);}
public int getSz() {return CollisionJNI.btElement_sz_get(swigCPtr, this);}public boolean isPrepared() {return isPrepared;}
public void prepare() {if (isPrepared)throw new GdxRuntimeException("Already prepared");if (pixmap == null) {if (file.extension().equals("cim"))pixmap = PixmapIO.readCIM(file);elsepixmap = ensurePot(new Pixmap(file));width = pixmap.getWidth();height = pixmap.getHeight();if (format == null)format = pixmap.getFormat();}isPrepared = true;}
private Pixmap ensurePot(Pixmap pixmap) {if (Gdx.gl20 == null && copyToPOT) {int pixmapWidth = pixmap.getWidth();int pixmapHeight = pixmap.getHeight();int potWidth = MathUtils.nextPowerOfTwo(pixmapWidth);int potHeight = MathUtils.nextPowerOfTwo(pixmapHeight);if (pixmapWidth != potWidth || pixmapHeight != potHeight) {Pixmap tmp = new Pixmap(potWidth, potHeight, pixmap.getFormat());tmp.drawPixmap(pixmap, 0, 0, 0, 0, pixmapWidth, pixmapHeight);pixmap.dispose();return tmp;}}return pixmap;}
public Pixmap consumePixmap() {if (!isPrepared)throw new GdxRuntimeException("Call prepare() before calling getPixmap()");isPrepared = false;Pixmap pixmap = this.pixmap;this.pixmap = null;return pixmap;}
public boolean disposePixmap() {return true;}
public int getWidth() {return width;}
public int getHeight() {return height;}
public Format getFormat() {return format;}
public boolean useMipMaps() {return useMipMaps;}
public boolean isManaged() {return true;}
public FileHandle getFileHandle() {return file;}
public TextureDataType getType() {return TextureDataType.Pixmap;}
public void consumeCustomData(int target) {throw new GdxRuntimeException("This TextureData implementation does not upload data itself");}public void setStyle(ButtonStyle style) {if (!(style instanceof ImageButtonStyle))throw new IllegalArgumentException("style must be an ImageButtonStyle.");super.setStyle(style);this.style = (ImageButtonStyle) style;if (image != null)updateImage();}
public ImageButtonStyle getStyle() {return style;}
private void updateImage() {Drawable drawable = null;if (isDisabled() && style.imageDisabled != null)drawable = style.imageDisabled;else if (isPressed() && style.imageDown != null)drawable = style.imageDown;else if (isChecked && style.imageChecked != null)drawable = (style.imageCheckedOver != null && isOver()) ? style.imageCheckedOver : style.imageChecked;else if (isOver() && style.imageOver != null)drawable = style.imageOver;else if (//style.imageUp != null)drawable = style.imageUp;image.setDrawable(drawable);}
public void draw(Batch batch, float parentAlpha) {updateImage();super.draw(batch, parentAlpha);}
public Image getImage() {return image;}
public Cell getImageCell() {return getCell(image);}public long play() {return play(1, 1, 0, false);}
public long play(float volume) {return play(volume, 1, 0, false);}
public long play(float volume, float pitch, float pan) {return play(volume, pitch, pan, false);}
public long play(float volume, float pitch, float pan, boolean loop) {if (streamIds.size == 8)streamIds.pop();ALSource soundSource = OALSimpleAudio.sharedInstance().playBuffer(soundBuffer, volume, pitch, pan, loop);if (soundSource == null)return -1;if (soundSource.getSourceId() == -1)return -1;streamIds.insert(0, soundSource.getSourceId());return soundSource.getSourceId();}
public long loop() {return play(1, 1, 0, true);}
public long loop(float volume) {return play(volume, 1, 0, true);}
public long loop(float volume, float pitch, float pan) {return play(volume, pitch, pan, true);}
public void stop() {ALSource source;for (int i = 0; i < streamIds.size; i++) {if ((source = getSoundSource(streamIds.get(i))) != null)source.stop();}}
public void dispose() {stop();soundBuffer.dispose();}
public void stop(long soundId) {ALSource source;if ((source = getSoundSource(soundId)) != null)source.stop();}
public void setLooping(long soundId, boolean looping) {ALSource source;if ((source = getSoundSource(soundId)) != null)source.setLooping(looping);}
public void setPitch(long soundId, float pitch) {ALSource source;if ((source = getSoundSource(soundId)) != null)source.setPitch(pitch);}
public void setVolume(long soundId, float volume) {ALSource source;if ((source = getSoundSource(soundId)) != null)source.setVolume(volume);}
public void setPan(long soundId, float pan, float volume) {ALSource source;if ((source = getSoundSource(soundId)) != null) {source.setPan(pan);source.setVolume(volume);}}
public void setPriority(long soundId, int priority) {}
public void pause() {ALSource source;for (int i = 0; i < streamIds.size; i++) {if ((source = getSoundSource(streamIds.get(i))) != null)source.setPaused(true);}}
public void resume() {ALSource source;for (int i = 0; i < streamIds.size; i++) {if ((source = getSoundSource(streamIds.get(i))) != null)source.setPaused(false);}}
public void pause(long soundId) {ALSource source;if ((source = getSoundSource(soundId)) != null)source.setPaused(true);}
public void resume(long soundId) {ALSource source;if ((source = getSoundSource(soundId)) != null)source.setPaused(false);}
private ALSource getSoundSource(long soundId) {for (ALSource source : sourcePool) {if (source.getSourceId() == soundId)return source;}return null;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btDispatcher obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btDispatcher(swigCPtr);}swigCPtr = 0;}super.delete();}
public btCollisionAlgorithm findAlgorithm(btCollisionObjectWrapper body0Wrap, btCollisionObjectWrapper body1Wrap, btPersistentManifold sharedManifold) {long cPtr = CollisionJNI.btDispatcher_findAlgorithm__SWIG_0(swigCPtr, this, btCollisionObjectWrapper.getCPtr(body0Wrap), body0Wrap, btCollisionObjectWrapper.getCPtr(body1Wrap), body1Wrap, btPersistentManifold.getCPtr(sharedManifold), sharedManifold);return (cPtr == 0) ? null : new btCollisionAlgorithm(cPtr, false);}
public btCollisionAlgorithm findAlgorithm(btCollisionObjectWrapper body0Wrap, btCollisionObjectWrapper body1Wrap) {long cPtr = CollisionJNI.btDispatcher_findAlgorithm__SWIG_1(swigCPtr, this, btCollisionObjectWrapper.getCPtr(body0Wrap), body0Wrap, btCollisionObjectWrapper.getCPtr(body1Wrap), body1Wrap);return (cPtr == 0) ? null : new btCollisionAlgorithm(cPtr, false);}
public btPersistentManifold getNewManifold(btCollisionObject b0, btCollisionObject b1) {long cPtr = CollisionJNI.btDispatcher_getNewManifold(swigCPtr, this, btCollisionObject.getCPtr(b0), b0, btCollisionObject.getCPtr(b1), b1);return (cPtr == 0) ? null : new btPersistentManifold(cPtr, false);}
public void releaseManifold(btPersistentManifold manifold) {CollisionJNI.btDispatcher_releaseManifold(swigCPtr, this, btPersistentManifold.getCPtr(manifold), manifold);}
public void clearManifold(btPersistentManifold manifold) {CollisionJNI.btDispatcher_clearManifold(swigCPtr, this, btPersistentManifold.getCPtr(manifold), manifold);}
public boolean needsCollision(btCollisionObject body0, btCollisionObject body1) {return CollisionJNI.btDispatcher_needsCollision(swigCPtr, this, btCollisionObject.getCPtr(body0), body0, btCollisionObject.getCPtr(body1), body1);}
public boolean needsResponse(btCollisionObject body0, btCollisionObject body1) {return CollisionJNI.btDispatcher_needsResponse(swigCPtr, this, btCollisionObject.getCPtr(body0), body0, btCollisionObject.getCPtr(body1), body1);}
public void dispatchAllCollisionPairs(btOverlappingPairCache pairCache, btDispatcherInfo dispatchInfo, btDispatcher dispatcher) {CollisionJNI.btDispatcher_dispatchAllCollisionPairs(swigCPtr, this, btOverlappingPairCache.getCPtr(pairCache), pairCache, btDispatcherInfo.getCPtr(dispatchInfo), dispatchInfo, btDispatcher.getCPtr(dispatcher), dispatcher);}
public int getNumManifolds() {return CollisionJNI.btDispatcher_getNumManifolds(swigCPtr, this);}
public btPersistentManifold getManifoldByIndexInternal(int index) {long cPtr = CollisionJNI.btDispatcher_getManifoldByIndexInternal(swigCPtr, this, index);return (cPtr == 0) ? null : new btPersistentManifold(cPtr, false);}
public SWIGTYPE_p_p_btPersistentManifold getInternalManifoldPointer() {long cPtr = CollisionJNI.btDispatcher_getInternalManifoldPointer(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_p_btPersistentManifold(cPtr, false);}
public btPoolAllocator getInternalManifoldPool() {long cPtr = CollisionJNI.btDispatcher_getInternalManifoldPool__SWIG_0(swigCPtr, this);return (cPtr == 0) ? null : new btPoolAllocator(cPtr, false);}
public long allocateCollisionAlgorithm(int size) {return CollisionJNI.btDispatcher_allocateCollisionAlgorithm(swigCPtr, this, size);}
public void freeCollisionAlgorithm(long ptr) {CollisionJNI.btDispatcher_freeCollisionAlgorithm(swigCPtr, this, ptr);}public void create() {FreeTypeFontGenerator generator = new FreeTypeFontGenerator(Gdx.files.internal("data/unbom.ttf"));FreeTypeFontParameter parameter = new FreeTypeFontParameter();parameter.size = 18;parameter.characters = "한국어/조선�?";koreanFont = generator.generateFont(parameter);generator.dispose();parameter.characters = FreeTypeFontGenerator.DEFAULT_CHARS;generator = new FreeTypeFontGenerator(Gdx.files.internal("data/russkij.ttf"));cyrillicFont = generator.generateFont(parameter);generator.dispose();parameter.characters = "วรณยุ�?ต์";generator = new FreeTypeFontGenerator(Gdx.files.internal("data/garuda.ttf"));thaiFont = generator.generateFont(parameter);generator.dispose();batch = new SpriteBatch();cam = new OrthographicCamera();cam.setToOrtho(false, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());cam.update();}
public void render() {Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);batch.setProjectionMatrix(cam.combined);batch.begin();koreanFont.draw(batch, "한국어/조선�?", 0, 22);cyrillicFont.draw(batch, "cyrillic text", 0, 44);thaiFont.draw(batch, "วรรณยุ�?ต์", 0, 66);batch.end();}
public void resize(int width, int height) {cam.setToOrtho(false, width, height);}public void dispose() {texture.dispose();vbo.dispose();indices.dispose();shader.dispose();}
public void render() {GL20 gl = Gdx.gl20;gl.glViewport(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());Gdx.gl.glClearColor(0.7f, 0, 0, 1);gl.glClear(GL20.GL_COLOR_BUFFER_BIT);gl.glEnable(GL20.GL_TEXTURE_2D);shader.begin();shader.setUniformi("u_texture", 0);texture.bind();vbo.bind(shader);indices.bind();gl.glDrawElements(GL20.GL_TRIANGLES, 3, GL20.GL_UNSIGNED_SHORT, indices.getBuffer().position());indices.unbind();vbo.unbind(shader);shader.end();}
public void create() {String vertexShader = "attribute vec4 a_position;\n" + "attribute vec4 a_color;\n" + "attribute vec2 a_texCoords;\n" + "varying vec4 v_color;" + "varying vec2 v_texCoords;" + "void main()  \n" + "{\n" + "   v_color = vec4(a_color.x, a_color.y, a_color.z, 1); \n" + "   v_texCoords = a_texCoords; \n" + "   gl_Position =  a_position;  \n" + "}\n";String fragmentShader = "#ifdef GL_ES\n" + "precision mediump float;\n" + "#endif\n" + "varying vec4 v_color;\n" + "varying vec2 v_texCoords;\n" + "uniform sampler2D u_texture;\n" + "void main()  \n" + "{\n" + "  gl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n" + "}";shader = new ShaderProgram(vertexShader, fragmentShader);vbo = new VertexBufferObject(true, 3, new VertexAttribute(VertexAttributes.Usage.Position, 2, "a_position"), new VertexAttribute(VertexAttributes.Usage.TextureCoordinates, 2, "a_texCoords"), new VertexAttribute(VertexAttributes.Usage.ColorPacked, 4, "a_color"));float[] vertices = new float[] { -1, -1, 0, 0, Color.toFloatBits(1f, 0f, 0f, 1f), 0, 1, 0.5f, 1.0f, Color.toFloatBits(0f, 1f, 0f, 1f), 1, -1, 1, 0, Color.toFloatBits(0f, 0f, 1f, 1f) };vbo.setVertices(vertices, 0, vertices.length);indices = new IndexBufferObject(3);indices.setIndices(new short[] { 0, 1, 2 }, 0, 3);texture = new Texture(Gdx.files.internal("data/badlogic.jpg"));}
public void resume() {vbo.invalidate();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.bt32BitAxisSweep3_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(bt32BitAxisSweep3 obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_bt32BitAxisSweep3(swigCPtr);}swigCPtr = 0;}super.delete();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btContactSolverInfoData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btContactSolverInfoData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setTau(float value) {DynamicsJNI.btContactSolverInfoData_tau_set(swigCPtr, this, value);}
public float getTau() {return DynamicsJNI.btContactSolverInfoData_tau_get(swigCPtr, this);}
public void setDamping(float value) {DynamicsJNI.btContactSolverInfoData_damping_set(swigCPtr, this, value);}
public float getDamping() {return DynamicsJNI.btContactSolverInfoData_damping_get(swigCPtr, this);}
public void setFriction(float value) {DynamicsJNI.btContactSolverInfoData_friction_set(swigCPtr, this, value);}
public float getFriction() {return DynamicsJNI.btContactSolverInfoData_friction_get(swigCPtr, this);}
public void setTimeStep(float value) {DynamicsJNI.btContactSolverInfoData_timeStep_set(swigCPtr, this, value);}
public float getTimeStep() {return DynamicsJNI.btContactSolverInfoData_timeStep_get(swigCPtr, this);}
public void setRestitution(float value) {DynamicsJNI.btContactSolverInfoData_restitution_set(swigCPtr, this, value);}
public float getRestitution() {return DynamicsJNI.btContactSolverInfoData_restitution_get(swigCPtr, this);}
public void setNumIterations(int value) {DynamicsJNI.btContactSolverInfoData_numIterations_set(swigCPtr, this, value);}
public int getNumIterations() {return DynamicsJNI.btContactSolverInfoData_numIterations_get(swigCPtr, this);}
public void setMaxErrorReduction(float value) {DynamicsJNI.btContactSolverInfoData_maxErrorReduction_set(swigCPtr, this, value);}
public float getMaxErrorReduction() {return DynamicsJNI.btContactSolverInfoData_maxErrorReduction_get(swigCPtr, this);}
public void setSor(float value) {DynamicsJNI.btContactSolverInfoData_sor_set(swigCPtr, this, value);}
public float getSor() {return DynamicsJNI.btContactSolverInfoData_sor_get(swigCPtr, this);}
public void setErp(float value) {DynamicsJNI.btContactSolverInfoData_erp_set(swigCPtr, this, value);}
public float getErp() {return DynamicsJNI.btContactSolverInfoData_erp_get(swigCPtr, this);}
public void setErp2(float value) {DynamicsJNI.btContactSolverInfoData_erp2_set(swigCPtr, this, value);}
public float getErp2() {return DynamicsJNI.btContactSolverInfoData_erp2_get(swigCPtr, this);}
public void setGlobalCfm(float value) {DynamicsJNI.btContactSolverInfoData_globalCfm_set(swigCPtr, this, value);}
public float getGlobalCfm() {return DynamicsJNI.btContactSolverInfoData_globalCfm_get(swigCPtr, this);}
public void setSplitImpulse(int value) {DynamicsJNI.btContactSolverInfoData_splitImpulse_set(swigCPtr, this, value);}
public int getSplitImpulse() {return DynamicsJNI.btContactSolverInfoData_splitImpulse_get(swigCPtr, this);}
public void setSplitImpulsePenetrationThreshold(float value) {DynamicsJNI.btContactSolverInfoData_splitImpulsePenetrationThreshold_set(swigCPtr, this, value);}
public float getSplitImpulsePenetrationThreshold() {return DynamicsJNI.btContactSolverInfoData_splitImpulsePenetrationThreshold_get(swigCPtr, this);}
public void setSplitImpulseTurnErp(float value) {DynamicsJNI.btContactSolverInfoData_splitImpulseTurnErp_set(swigCPtr, this, value);}
public float getSplitImpulseTurnErp() {return DynamicsJNI.btContactSolverInfoData_splitImpulseTurnErp_get(swigCPtr, this);}
public void setLinearSlop(float value) {DynamicsJNI.btContactSolverInfoData_linearSlop_set(swigCPtr, this, value);}
public float getLinearSlop() {return DynamicsJNI.btContactSolverInfoData_linearSlop_get(swigCPtr, this);}
public void setWarmstartingFactor(float value) {DynamicsJNI.btContactSolverInfoData_warmstartingFactor_set(swigCPtr, this, value);}
public float getWarmstartingFactor() {return DynamicsJNI.btContactSolverInfoData_warmstartingFactor_get(swigCPtr, this);}
public void setSolverMode(int value) {DynamicsJNI.btContactSolverInfoData_solverMode_set(swigCPtr, this, value);}
public int getSolverMode() {return DynamicsJNI.btContactSolverInfoData_solverMode_get(swigCPtr, this);}
public void setRestingContactRestitutionThreshold(int value) {DynamicsJNI.btContactSolverInfoData_restingContactRestitutionThreshold_set(swigCPtr, this, value);}
public int getRestingContactRestitutionThreshold() {return DynamicsJNI.btContactSolverInfoData_restingContactRestitutionThreshold_get(swigCPtr, this);}
public void setMinimumSolverBatchSize(int value) {DynamicsJNI.btContactSolverInfoData_minimumSolverBatchSize_set(swigCPtr, this, value);}
public int getMinimumSolverBatchSize() {return DynamicsJNI.btContactSolverInfoData_minimumSolverBatchSize_get(swigCPtr, this);}
public void setMaxGyroscopicForce(float value) {DynamicsJNI.btContactSolverInfoData_maxGyroscopicForce_set(swigCPtr, this, value);}
public float getMaxGyroscopicForce() {return DynamicsJNI.btContactSolverInfoData_maxGyroscopicForce_get(swigCPtr, this);}
public void setSingleAxisRollingFrictionThreshold(float value) {DynamicsJNI.btContactSolverInfoData_singleAxisRollingFrictionThreshold_set(swigCPtr, this, value);}
public float getSingleAxisRollingFrictionThreshold() {return DynamicsJNI.btContactSolverInfoData_singleAxisRollingFrictionThreshold_get(swigCPtr, this);}public TextureDataType getType() {return TextureDataType.Custom;}
public boolean isPrepared() {return isPrepared;}
public void prepare() {if (isPrepared)throw new GdxRuntimeException("Already prepared");isPrepared = true;}
public void consumeCustomData(int target) {Gdx.gl.glTexImage2D(target, mipLevel, internalFormat, width, height, 0, format, type, null);}
public Pixmap consumePixmap() {throw new GdxRuntimeException("This TextureData implementation does not return a Pixmap");}
public boolean disposePixmap() {throw new GdxRuntimeException("This TextureData implementation does not return a Pixmap");}
public int getWidth() {return width;}
public int getHeight() {return height;}
public Format getFormat() {return Format.RGBA8888;}
public boolean useMipMaps() {return false;}
public boolean isManaged() {return false;}public void create() {stage = new Stage();Gdx.input.setInputProcessor(stage);skin = new Skin(Gdx.files.internal("data/uiskin.json"));for (int i = 0; i < 1; i++) {TextButton t = new TextButton("Button" + i, skin);t.setX(MathUtils.random(0, Gdx.graphics.getWidth()));t.setY(MathUtils.random(0, Gdx.graphics.getHeight()));t.setWidth(MathUtils.random(50, 200));t.setHeight(MathUtils.random(0, 100));stage.addActor(t);}}
public void render() {Gdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);stage.draw();Gdx.app.log("X", "FPS: " + Gdx.graphics.getFramesPerSecond());SpriteBatch spriteBatch = (SpriteBatch) stage.getBatch();Gdx.app.log("X", "render calls: " + spriteBatch.totalRenderCalls);spriteBatch.totalRenderCalls = 0;}
public void resize(int width, int height) {stage.getViewport().update(width, height, true);}
public void dispose() {stage.dispose();skin.dispose();}protected static long getCPtr(SWIGTYPE_p_f_r_btBroadphasePair_r_btCollisionDispatcher_r_q_const__btDispatcherInfo__void obj) {return (obj == null) ? 0 : obj.swigCPtr;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btEigen obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;SoftbodyJNI.delete_btEigen(swigCPtr);}swigCPtr = 0;}super.delete();}
public static int system(Matrix3 a, SWIGTYPE_p_btMatrix3x3 vectors, btVector3 values) {return SoftbodyJNI.btEigen_system__SWIG_0(a, SWIGTYPE_p_btMatrix3x3.getCPtr(vectors), btVector3.getCPtr(values), values);}
public static int system(Matrix3 a, SWIGTYPE_p_btMatrix3x3 vectors) {return SoftbodyJNI.btEigen_system__SWIG_1(a, SWIGTYPE_p_btMatrix3x3.getCPtr(vectors));}public void initialize(Body b1, Body b2, Vec2 anchor, Vec2 axis) {bodyA = b1;bodyB = b2;b1.getLocalPointToOut(anchor, localAnchorA);b2.getLocalPointToOut(anchor, localAnchorB);bodyA.getLocalVectorToOut(axis, localAxisA);}public void reset() {resetMillis = now();}
public float getMilliseconds() {return (float) (now() - resetMillis);}static CharSequenceAdapter copy(CharSequenceAdapter other) {CharSequenceAdapter buf = new CharSequenceAdapter(other.sequence);buf.limit = other.limit;buf.position = other.position;buf.mark = other.mark;return buf;}
public CharBuffer asReadOnlyBuffer() {return duplicate();}
public CharBuffer compact() {throw new ReadOnlyBufferException();}
public CharBuffer duplicate() {return copy(this);}
public char get() {if (position == limit) {throw new BufferUnderflowException();}return sequence.charAt(position++);}
public char get(int index) {if (index < 0 || index >= limit) {throw new IndexOutOfBoundsException();}return sequence.charAt(index);}
public final CharBuffer get(char[] dest, int off, int len) {int length = dest.length;if ((off < 0) || (len < 0) || (long) off + (long) len > length) {throw new IndexOutOfBoundsException();}if (len > remaining()) {throw new BufferUnderflowException();}int newPosition = position + len;sequence.toString().getChars(position, newPosition, dest, off);position = newPosition;return this;}
public boolean isDirect() {return false;}
public boolean isReadOnly() {return true;}
public ByteOrder order() {return ByteOrder.nativeOrder();}
protected char[] protectedArray() {throw new UnsupportedOperationException();}
protected int protectedArrayOffset() {throw new UnsupportedOperationException();}
protected boolean protectedHasArray() {return false;}
public CharBuffer put(char c) {throw new ReadOnlyBufferException();}
public CharBuffer put(int index, char c) {throw new ReadOnlyBufferException();}
public final CharBuffer put(char[] src, int off, int len) {if ((off < 0) || (len < 0) || (long) off + (long) len > src.length) {throw new IndexOutOfBoundsException();}if (len > remaining()) {throw new BufferOverflowException();}throw new ReadOnlyBufferException();}
public CharBuffer put(String src, int start, int end) {if ((start < 0) || (end < 0) || (long) start + (long) end > src.length()) {throw new IndexOutOfBoundsException();}throw new ReadOnlyBufferException();}
public CharBuffer slice() {return new CharSequenceAdapter(sequence.subSequence(position, limit));}
public CharSequence subSequence(int start, int end) {if (end < start || start < 0 || end > remaining()) {throw new IndexOutOfBoundsException();}CharSequenceAdapter result = copy(this);result.position = position + start;result.limit = position + end;return result;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(DynamicsJNI.btDynamicsWorld_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btDynamicsWorld obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btDynamicsWorld(swigCPtr);}swigCPtr = 0;}super.delete();}
public int stepSimulation(float timeStep, int maxSubSteps, float fixedTimeStep) {return DynamicsJNI.btDynamicsWorld_stepSimulation__SWIG_0(swigCPtr, this, timeStep, maxSubSteps, fixedTimeStep);}
public int stepSimulation(float timeStep, int maxSubSteps) {return DynamicsJNI.btDynamicsWorld_stepSimulation__SWIG_1(swigCPtr, this, timeStep, maxSubSteps);}
public int stepSimulation(float timeStep) {return DynamicsJNI.btDynamicsWorld_stepSimulation__SWIG_2(swigCPtr, this, timeStep);}
public void addConstraint(btTypedConstraint constraint, boolean disableCollisionsBetweenLinkedBodies) {DynamicsJNI.btDynamicsWorld_addConstraint__SWIG_0(swigCPtr, this, btTypedConstraint.getCPtr(constraint), constraint, disableCollisionsBetweenLinkedBodies);}
public void addConstraint(btTypedConstraint constraint) {DynamicsJNI.btDynamicsWorld_addConstraint__SWIG_1(swigCPtr, this, btTypedConstraint.getCPtr(constraint), constraint);}
public void removeConstraint(btTypedConstraint constraint) {DynamicsJNI.btDynamicsWorld_removeConstraint(swigCPtr, this, btTypedConstraint.getCPtr(constraint), constraint);}
public void addAction(btActionInterface action) {DynamicsJNI.btDynamicsWorld_addAction(swigCPtr, this, btActionInterface.getCPtr(action), action);}
public void removeAction(btActionInterface action) {DynamicsJNI.btDynamicsWorld_removeAction(swigCPtr, this, btActionInterface.getCPtr(action), action);}
public void setGravity(Vector3 gravity) {DynamicsJNI.btDynamicsWorld_setGravity(swigCPtr, this, gravity);}
public Vector3 getGravity() {return DynamicsJNI.btDynamicsWorld_getGravity(swigCPtr, this);}
public void synchronizeMotionStates() {DynamicsJNI.btDynamicsWorld_synchronizeMotionStates(swigCPtr, this);}
public void addRigidBody(btRigidBody body) {DynamicsJNI.btDynamicsWorld_addRigidBody__SWIG_0(swigCPtr, this, btRigidBody.getCPtr(body), body);}
public void addRigidBody(btRigidBody body, short group, short mask) {DynamicsJNI.btDynamicsWorld_addRigidBody__SWIG_1(swigCPtr, this, btRigidBody.getCPtr(body), body, group, mask);}
public void removeRigidBody(btRigidBody body) {DynamicsJNI.btDynamicsWorld_removeRigidBody(swigCPtr, this, btRigidBody.getCPtr(body), body);}
public void setConstraintSolver(btConstraintSolver solver) {DynamicsJNI.btDynamicsWorld_setConstraintSolver(swigCPtr, this, btConstraintSolver.getCPtr(solver), solver);}
public btConstraintSolver getConstraintSolver() {long cPtr = DynamicsJNI.btDynamicsWorld_getConstraintSolver(swigCPtr, this);return (cPtr == 0) ? null : new btConstraintSolver(cPtr, false);}
public int getNumConstraints() {return DynamicsJNI.btDynamicsWorld_getNumConstraints(swigCPtr, this);}
public btTypedConstraint getConstraint(int index) {long cPtr = DynamicsJNI.btDynamicsWorld_getConstraint__SWIG_0(swigCPtr, this, index);return (cPtr == 0) ? null : new btTypedConstraint(cPtr, false);}
public int getWorldType() {return DynamicsJNI.btDynamicsWorld_getWorldType(swigCPtr, this);}
public void clearForces() {DynamicsJNI.btDynamicsWorld_clearForces(swigCPtr, this);}
public void setInternalTickCallback(SWIGTYPE_p_f_p_btDynamicsWorld_float__void cb, long worldUserInfo, boolean isPreTick) {DynamicsJNI.btDynamicsWorld_setInternalTickCallback__SWIG_0(swigCPtr, this, SWIGTYPE_p_f_p_btDynamicsWorld_float__void.getCPtr(cb), worldUserInfo, isPreTick);}
public void setInternalTickCallback(SWIGTYPE_p_f_p_btDynamicsWorld_float__void cb, long worldUserInfo) {DynamicsJNI.btDynamicsWorld_setInternalTickCallback__SWIG_1(swigCPtr, this, SWIGTYPE_p_f_p_btDynamicsWorld_float__void.getCPtr(cb), worldUserInfo);}
public void setInternalTickCallback(SWIGTYPE_p_f_p_btDynamicsWorld_float__void cb) {DynamicsJNI.btDynamicsWorld_setInternalTickCallback__SWIG_2(swigCPtr, this, SWIGTYPE_p_f_p_btDynamicsWorld_float__void.getCPtr(cb));}
public void setWorldUserInfo(long worldUserInfo) {DynamicsJNI.btDynamicsWorld_setWorldUserInfo(swigCPtr, this, worldUserInfo);}
public long getWorldUserInfo() {return DynamicsJNI.btDynamicsWorld_getWorldUserInfo(swigCPtr, this);}
public btContactSolverInfo getSolverInfo() {return new btContactSolverInfo(DynamicsJNI.btDynamicsWorld_getSolverInfo(swigCPtr, this), false);}
public void addVehicle(btActionInterface vehicle) {DynamicsJNI.btDynamicsWorld_addVehicle(swigCPtr, this, btActionInterface.getCPtr(vehicle), vehicle);}
public void removeVehicle(btActionInterface vehicle) {DynamicsJNI.btDynamicsWorld_removeVehicle(swigCPtr, this, btActionInterface.getCPtr(vehicle), vehicle);}
public void addCharacter(btActionInterface character) {DynamicsJNI.btDynamicsWorld_addCharacter(swigCPtr, this, btActionInterface.getCPtr(character), character);}
public void removeCharacter(btActionInterface character) {DynamicsJNI.btDynamicsWorld_removeCharacter(swigCPtr, this, btActionInterface.getCPtr(character), character);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btTriangleIndexVertexMaterialArray_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btTriangleIndexVertexMaterialArray obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btTriangleIndexVertexMaterialArray(swigCPtr);}swigCPtr = 0;}super.delete();}
private static long SwigConstructbtTriangleIndexVertexMaterialArray(int numTriangles, java.nio.IntBuffer triangleIndexBase, int triangleIndexStride, int numVertices, java.nio.FloatBuffer vertexBase, int vertexStride, int numMaterials, java.nio.ByteBuffer materialBase, int materialStride, java.nio.IntBuffer triangleMaterialsBase, int materialIndexStride) {assert triangleIndexBase.isDirect() : "Buffer must be allocated direct.";assert vertexBase.isDirect() : "Buffer must be allocated direct.";assert materialBase.isDirect() : "Buffer must be allocated direct.";assert triangleMaterialsBase.isDirect() : "Buffer must be allocated direct.";return CollisionJNI.new_btTriangleIndexVertexMaterialArray__SWIG_1(numTriangles, triangleIndexBase, triangleIndexStride, numVertices, vertexBase, vertexStride, numMaterials, materialBase, materialStride, triangleMaterialsBase, materialIndexStride);}
public void addMaterialProperties(btMaterialProperties mat, int triangleType) {CollisionJNI.btTriangleIndexVertexMaterialArray_addMaterialProperties__SWIG_0(swigCPtr, this, btMaterialProperties.getCPtr(mat), mat, triangleType);}
public void addMaterialProperties(btMaterialProperties mat) {CollisionJNI.btTriangleIndexVertexMaterialArray_addMaterialProperties__SWIG_1(swigCPtr, this, btMaterialProperties.getCPtr(mat), mat);}
public void getLockedMaterialBase(SWIGTYPE_p_p_unsigned_char materialBase, SWIGTYPE_p_int numMaterials, SWIGTYPE_p_PHY_ScalarType materialType, SWIGTYPE_p_int materialStride, SWIGTYPE_p_p_unsigned_char triangleMaterialBase, SWIGTYPE_p_int numTriangles, SWIGTYPE_p_int triangleMaterialStride, SWIGTYPE_p_PHY_ScalarType triangleType, int subpart) {CollisionJNI.btTriangleIndexVertexMaterialArray_getLockedMaterialBase__SWIG_0(swigCPtr, this, SWIGTYPE_p_p_unsigned_char.getCPtr(materialBase), SWIGTYPE_p_int.getCPtr(numMaterials), SWIGTYPE_p_PHY_ScalarType.getCPtr(materialType), SWIGTYPE_p_int.getCPtr(materialStride), SWIGTYPE_p_p_unsigned_char.getCPtr(triangleMaterialBase), SWIGTYPE_p_int.getCPtr(numTriangles), SWIGTYPE_p_int.getCPtr(triangleMaterialStride), SWIGTYPE_p_PHY_ScalarType.getCPtr(triangleType), subpart);}
public void getLockedMaterialBase(SWIGTYPE_p_p_unsigned_char materialBase, SWIGTYPE_p_int numMaterials, SWIGTYPE_p_PHY_ScalarType materialType, SWIGTYPE_p_int materialStride, SWIGTYPE_p_p_unsigned_char triangleMaterialBase, SWIGTYPE_p_int numTriangles, SWIGTYPE_p_int triangleMaterialStride, SWIGTYPE_p_PHY_ScalarType triangleType) {CollisionJNI.btTriangleIndexVertexMaterialArray_getLockedMaterialBase__SWIG_1(swigCPtr, this, SWIGTYPE_p_p_unsigned_char.getCPtr(materialBase), SWIGTYPE_p_int.getCPtr(numMaterials), SWIGTYPE_p_PHY_ScalarType.getCPtr(materialType), SWIGTYPE_p_int.getCPtr(materialStride), SWIGTYPE_p_p_unsigned_char.getCPtr(triangleMaterialBase), SWIGTYPE_p_int.getCPtr(numTriangles), SWIGTYPE_p_int.getCPtr(triangleMaterialStride), SWIGTYPE_p_PHY_ScalarType.getCPtr(triangleType));}
public void getLockedReadOnlyMaterialBase(SWIGTYPE_p_p_unsigned_char materialBase, SWIGTYPE_p_int numMaterials, SWIGTYPE_p_PHY_ScalarType materialType, SWIGTYPE_p_int materialStride, SWIGTYPE_p_p_unsigned_char triangleMaterialBase, SWIGTYPE_p_int numTriangles, SWIGTYPE_p_int triangleMaterialStride, SWIGTYPE_p_PHY_ScalarType triangleType, int subpart) {CollisionJNI.btTriangleIndexVertexMaterialArray_getLockedReadOnlyMaterialBase__SWIG_0(swigCPtr, this, SWIGTYPE_p_p_unsigned_char.getCPtr(materialBase), SWIGTYPE_p_int.getCPtr(numMaterials), SWIGTYPE_p_PHY_ScalarType.getCPtr(materialType), SWIGTYPE_p_int.getCPtr(materialStride), SWIGTYPE_p_p_unsigned_char.getCPtr(triangleMaterialBase), SWIGTYPE_p_int.getCPtr(numTriangles), SWIGTYPE_p_int.getCPtr(triangleMaterialStride), SWIGTYPE_p_PHY_ScalarType.getCPtr(triangleType), subpart);}
public void getLockedReadOnlyMaterialBase(SWIGTYPE_p_p_unsigned_char materialBase, SWIGTYPE_p_int numMaterials, SWIGTYPE_p_PHY_ScalarType materialType, SWIGTYPE_p_int materialStride, SWIGTYPE_p_p_unsigned_char triangleMaterialBase, SWIGTYPE_p_int numTriangles, SWIGTYPE_p_int triangleMaterialStride, SWIGTYPE_p_PHY_ScalarType triangleType) {CollisionJNI.btTriangleIndexVertexMaterialArray_getLockedReadOnlyMaterialBase__SWIG_1(swigCPtr, this, SWIGTYPE_p_p_unsigned_char.getCPtr(materialBase), SWIGTYPE_p_int.getCPtr(numMaterials), SWIGTYPE_p_PHY_ScalarType.getCPtr(materialType), SWIGTYPE_p_int.getCPtr(materialStride), SWIGTYPE_p_p_unsigned_char.getCPtr(triangleMaterialBase), SWIGTYPE_p_int.getCPtr(numTriangles), SWIGTYPE_p_int.getCPtr(triangleMaterialStride), SWIGTYPE_p_PHY_ScalarType.getCPtr(triangleType));}public void setViewportTransform(IViewportTransform viewportTransform) {this.viewportTransform = viewportTransform;}
public void setFlags(int flags) {m_drawFlags = flags;}
public int getFlags() {return m_drawFlags;}
public void appendFlags(int flags) {m_drawFlags |= flags;}
public void clearFlags(int flags) {m_drawFlags &= ~flags;}
public void drawPolygon(Vec2[] vertices, int vertexCount, Color3f color) {if (vertexCount == 1) {drawSegment(vertices[0], vertices[0], color);return;}for (int i = 0; i < vertexCount - 1; i += 1) {drawSegment(vertices[i], vertices[i + 1], color);}if (vertexCount > 2) {drawSegment(vertices[vertexCount - 1], vertices[0], color);}}
public void drawCircle(Vec2 center, float radius, Vec2 axis, Color3f color) {drawCircle(center, radius, color);}
public void flush() {}
public void drawString(Vec2 pos, String s, Color3f color) {drawString(pos.x, pos.y, s, color);}
public IViewportTransform getViewportTranform() {return viewportTransform;}
public void setCamera(float x, float y, float scale) {viewportTransform.setCamera(x, y, scale);}
public void getScreenToWorldToOut(Vec2 argScreen, Vec2 argWorld) {viewportTransform.getScreenToWorld(argScreen, argWorld);}
public void getWorldToScreenToOut(Vec2 argWorld, Vec2 argScreen) {viewportTransform.getWorldToScreen(argWorld, argScreen);}
public void getWorldToScreenToOut(float worldX, float worldY, Vec2 argScreen) {argScreen.set(worldX, worldY);viewportTransform.getWorldToScreen(argScreen, argScreen);}
public Vec2 getWorldToScreen(Vec2 argWorld) {Vec2 screen = new Vec2();viewportTransform.getWorldToScreen(argWorld, screen);return screen;}
public Vec2 getWorldToScreen(float worldX, float worldY) {Vec2 argScreen = new Vec2(worldX, worldY);viewportTransform.getWorldToScreen(argScreen, argScreen);return argScreen;}
public void getScreenToWorldToOut(float screenX, float screenY, Vec2 argWorld) {argWorld.set(screenX, screenY);viewportTransform.getScreenToWorld(argWorld, argWorld);}
public Vec2 getScreenToWorld(Vec2 argScreen) {Vec2 world = new Vec2();viewportTransform.getScreenToWorld(argScreen, world);return world;}
public Vec2 getScreenToWorld(float screenX, float screenY) {Vec2 screen = new Vec2(screenX, screenY);viewportTransform.getScreenToWorld(screen, screen);return screen;}public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {if (pressed)return false;if (pointer == 0 && this.button != -1 && button != this.button)return false;pressed = true;pressedPointer = pointer;pressedButton = button;touchDownX = x;touchDownY = y;visualPressedTime = TimeUtils.millis() + (long) (visualPressedDuration * 1000);return true;}
public void touchDragged(InputEvent event, float x, float y, int pointer) {if (pointer != pressedPointer || cancelled)return;pressed = isOver(event.getListenerActor(), x, y);if (pressed && pointer == 0 && button != -1 && !Gdx.input.isButtonPressed(button))pressed = false;if (!pressed) {// Once outside the tap square, don't use the tap square anymore.invalidateTapSquare();}}
public void touchUp(InputEvent event, float x, float y, int pointer, int button) {if (pointer == pressedPointer) {if (!cancelled) {boolean touchUpOver = isOver(event.getListenerActor(), x, y);// Ignore touch up if the wrong mouse button.if (touchUpOver && pointer == 0 && this.button != -1 && button != this.button)touchUpOver = false;if (touchUpOver) {long time = TimeUtils.nanoTime();if (time - lastTapTime > tapCountInterval)tapCount = 0;tapCount++;lastTapTime = time;clicked(event, x, y);}}pressed = false;pressedPointer = -1;pressedButton = -1;cancelled = false;}}
public void enter(InputEvent event, float x, float y, int pointer, Actor fromActor) {if (pointer == -1 && !cancelled)over = true;}
public void exit(InputEvent event, float x, float y, int pointer, Actor toActor) {if (pointer == -1 && !cancelled)over = false;}
public void cancel() {if (pressedPointer == -1)return;cancelled = true;pressed = false;}
public void clicked(InputEvent event, float x, float y) {}
public boolean isOver(Actor actor, float x, float y) {Actor hit = actor.hit(x, y, true);if (hit == null || !hit.isDescendantOf(actor))return inTapSquare(x, y);return true;}
public boolean inTapSquare(float x, float y) {if (touchDownX == -1 && touchDownY == -1)return false;return Math.abs(x - touchDownX) < tapSquareSize && Math.abs(y - touchDownY) < tapSquareSize;}
public boolean inTapSquare() {return touchDownX != -1;}
public void invalidateTapSquare() {touchDownX = -1;touchDownY = -1;}
public boolean isPressed() {return pressed;}
public boolean isVisualPressed() {if (pressed)return true;if (visualPressedTime <= 0)return false;if (visualPressedTime > TimeUtils.millis())return true;visualPressedTime = 0;return false;}
public boolean isOver() {return over || pressed;}
public void setTapSquareSize(float halfTapSquareSize) {tapSquareSize = halfTapSquareSize;}
public float getTapSquareSize() {return tapSquareSize;}
public void setTapCountInterval(float tapCountInterval) {this.tapCountInterval = (long) (tapCountInterval * 1000000000l);}
public int getTapCount() {return tapCount;}
public float getTouchDownX() {return touchDownX;}
public float getTouchDownY() {return touchDownY;}
public int getPressedButton() {return pressedButton;}
public int getPressedPointer() {return pressedPointer;}
public int getButton() {return button;}
public void setButton(int button) {this.button = button;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btPrimitiveManagerBase obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btPrimitiveManagerBase(swigCPtr);}swigCPtr = 0;}super.delete();}
public boolean is_trimesh() {return CollisionJNI.btPrimitiveManagerBase_is_trimesh(swigCPtr, this);}
public int get_primitive_count() {return CollisionJNI.btPrimitiveManagerBase_get_primitive_count(swigCPtr, this);}
public void get_primitive_box(int prim_index, btAABB primbox) {CollisionJNI.btPrimitiveManagerBase_get_primitive_box(swigCPtr, this, prim_index, btAABB.getCPtr(primbox), primbox);}
public void get_primitive_triangle(int prim_index, btPrimitiveTriangle triangle) {CollisionJNI.btPrimitiveManagerBase_get_primitive_triangle(swigCPtr, this, prim_index, btPrimitiveTriangle.getCPtr(triangle), triangle);}public final double get() {if (position == limit) {throw new BufferUnderflowException();}return backingArray[offset + position++];}
public final double get(int index) {if (index < 0 || index >= limit) {throw new IndexOutOfBoundsException();}return backingArray[offset + index];}
public final DoubleBuffer get(double[] dest, int off, int len) {int length = dest.length;if (off < 0 || len < 0 || (long) off + (long) len > length) {throw new IndexOutOfBoundsException();}if (len > remaining()) {throw new BufferUnderflowException();}System.arraycopy(backingArray, offset + position, dest, off, len);position += len;return this;}
public final boolean isDirect() {return false;}
public final ByteOrder order() {return ByteOrder.nativeOrder();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(GIM_CONTACT obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_GIM_CONTACT(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setPoint(btVector3 value) {CollisionJNI.GIM_CONTACT_point_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getPoint() {long cPtr = CollisionJNI.GIM_CONTACT_point_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setNormal(btVector3 value) {CollisionJNI.GIM_CONTACT_normal_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getNormal() {long cPtr = CollisionJNI.GIM_CONTACT_normal_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setDepth(float value) {CollisionJNI.GIM_CONTACT_depth_set(swigCPtr, this, value);}
public float getDepth() {return CollisionJNI.GIM_CONTACT_depth_get(swigCPtr, this);}
public void setDistance(float value) {CollisionJNI.GIM_CONTACT_distance_set(swigCPtr, this, value);}
public float getDistance() {return CollisionJNI.GIM_CONTACT_distance_get(swigCPtr, this);}
public void setFeature1(int value) {CollisionJNI.GIM_CONTACT_feature1_set(swigCPtr, this, value);}
public int getFeature1() {return CollisionJNI.GIM_CONTACT_feature1_get(swigCPtr, this);}
public void setFeature2(int value) {CollisionJNI.GIM_CONTACT_feature2_set(swigCPtr, this, value);}
public int getFeature2() {return CollisionJNI.GIM_CONTACT_feature2_get(swigCPtr, this);}
public long calc_key_contact() {return CollisionJNI.GIM_CONTACT_calc_key_contact(swigCPtr, this);}
public void interpolate_normals(btVector3 normals, int normal_count) {CollisionJNI.GIM_CONTACT_interpolate_normals(swigCPtr, this, btVector3.getCPtr(normals), normals, normal_count);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btHashString obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;LinearMathJNI.delete_btHashString(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setString(String value) {LinearMathJNI.btHashString_string_set(swigCPtr, this, value);}
public String getString() {return LinearMathJNI.btHashString_string_get(swigCPtr, this);}
public void setHash(long value) {LinearMathJNI.btHashString_hash_set(swigCPtr, this, value);}
public long getHash() {return LinearMathJNI.btHashString_hash_get(swigCPtr, this);}
public int portableStringCompare(String src, String dst) {return LinearMathJNI.btHashString_portableStringCompare(swigCPtr, this, src, dst);}
public boolean equals(btHashString other) {return LinearMathJNI.btHashString_equals(swigCPtr, this, btHashString.getCPtr(other), other);}public void Init() {Decoder.InitBitModels(Models);}
public void Encode(Encoder rangeEncoder, int symbol) {int m = 1;for (int bitIndex = NumBitLevels; bitIndex != 0; ) {bitIndex--;int bit = (symbol >>> bitIndex) & 1;rangeEncoder.Encode(Models, m, bit);m = (m << 1) | bit;}}
public void ReverseEncode(Encoder rangeEncoder, int symbol) {int m = 1;for (int i = 0; i < NumBitLevels; i++) {int bit = symbol & 1;rangeEncoder.Encode(Models, m, bit);m = (m << 1) | bit;symbol >>= 1;}}
public int GetPrice(int symbol) {int price = 0;int m = 1;for (int bitIndex = NumBitLevels; bitIndex != 0; ) {bitIndex--;int bit = (symbol >>> bitIndex) & 1;price += Encoder.GetPrice(Models[m], bit);m = (m << 1) + bit;}return price;}
public int ReverseGetPrice(int symbol) {int price = 0;int m = 1;for (int i = NumBitLevels; i != 0; i--) {int bit = symbol & 1;symbol >>>= 1;price += Encoder.GetPrice(Models[m], bit);m = (m << 1) | bit;}return price;}
public static int ReverseGetPrice(short[] Models, int startIndex, int NumBitLevels, int symbol) {int price = 0;int m = 1;for (int i = NumBitLevels; i != 0; i--) {int bit = symbol & 1;symbol >>>= 1;price += Encoder.GetPrice(Models[startIndex + m], bit);m = (m << 1) | bit;}return price;}
public static void ReverseEncode(short[] Models, int startIndex, Encoder rangeEncoder, int NumBitLevels, int symbol) {int m = 1;for (int i = 0; i < NumBitLevels; i++) {int bit = symbol & 1;rangeEncoder.Encode(Models, startIndex + m, bit);m = (m << 1) | bit;symbol >>= 1;}}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(SoftbodyJNI.btSoftClusterCollisionShape_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btSoftClusterCollisionShape obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;SoftbodyJNI.delete_btSoftClusterCollisionShape(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setCluster(btSoftBody.Cluster value) {SoftbodyJNI.btSoftClusterCollisionShape_cluster_set(swigCPtr, this, btSoftBody.Cluster.getCPtr(value), value);}
public btSoftBody.Cluster getCluster() {long cPtr = SoftbodyJNI.btSoftClusterCollisionShape_cluster_get(swigCPtr, this);return (cPtr == 0) ? null : new btSoftBody.Cluster(cPtr, false);}
public int getShapeType() {return SoftbodyJNI.btSoftClusterCollisionShape_getShapeType(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(DynamicsJNI.btHinge2Constraint_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btHinge2Constraint obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btHinge2Constraint(swigCPtr);}swigCPtr = 0;}super.delete();}
public Vector3 getAnchor() {return DynamicsJNI.btHinge2Constraint_getAnchor(swigCPtr, this);}
public Vector3 getAnchor2() {return DynamicsJNI.btHinge2Constraint_getAnchor2(swigCPtr, this);}
public Vector3 getAxis1() {return DynamicsJNI.btHinge2Constraint_getAxis1(swigCPtr, this);}
public Vector3 getAxis2() {return DynamicsJNI.btHinge2Constraint_getAxis2(swigCPtr, this);}
public float getAngle1() {return DynamicsJNI.btHinge2Constraint_getAngle1(swigCPtr, this);}
public float getAngle2() {return DynamicsJNI.btHinge2Constraint_getAngle2(swigCPtr, this);}
public void setUpperLimit(float ang1max) {DynamicsJNI.btHinge2Constraint_setUpperLimit(swigCPtr, this, ang1max);}
public void setLowerLimit(float ang1min) {DynamicsJNI.btHinge2Constraint_setLowerLimit(swigCPtr, this, ang1min);}public RaycastResult set(RaycastResult argOther) {lambda = argOther.lambda;normal.set(argOther.normal);return this;}public Vector2 mul(Vector2 v) {float x = vals[POS_X] + vals[COS] * v.x + -vals[SIN] * v.y;float y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;v.x = x;v.y = y;return v;}
public Vector2 getPosition() {return position.set(vals[0], vals[1]);}
public void setRotation(float angle) {float c = (float) Math.cos(angle), s = (float) Math.sin(angle);vals[COS] = c;vals[SIN] = s;}
public float getRotation() {return (float) Math.atan2(vals[SIN], vals[COS]);}
public void setPosition(Vector2 pos) {this.vals[POS_X] = pos.x;this.vals[POS_Y] = pos.y;}public String getContents() {if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.HONEYCOMB) {android.text.ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);if (clipboard.getText() == null)return null;return clipboard.getText().toString();} else {android.content.ClipboardManager clipboard = (android.content.ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);ClipData clip = clipboard.getPrimaryClip();if (clip == null)return null;CharSequence text = clip.getItemAt(0).getText();if (text == null)return null;return text.toString();}}
public void setContents(final String contents) {try {((Activity) context).runOnUiThread(new Runnable() {
public void run() {if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.HONEYCOMB) {android.text.ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);clipboard.setText(contents);} else {android.content.ClipboardManager clipboard = (android.content.ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);ClipData data = ClipData.newPlainText(contents, contents);clipboard.setPrimaryClip(data);}}});} catch (final Exception ex) {}}
public void run() {if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.HONEYCOMB) {android.text.ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);clipboard.setText(contents);} else {android.content.ClipboardManager clipboard = (android.content.ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);ClipData data = ClipData.newPlainText(contents, contents);clipboard.setPrimaryClip(data);}}public String getName() {return name;}
public void setName(String name) {this.name = name;}
public Color getColor() {return color;}
public void setColor(Color color) {this.color = color;}
public float getOpacity() {return opacity;}
public void setOpacity(float opacity) {this.opacity = opacity;}
public boolean isVisible() {return visible;}
public void setVisible(boolean visible) {this.visible = visible;}
public MapProperties getProperties() {return properties;}public FileHandle getFileHandle(String fileName, FileType type) {return new LwjglFileHandle(fileName, type);}
public FileHandle classpath(String path) {return new LwjglFileHandle(path, FileType.Classpath);}
public FileHandle internal(String path) {return new LwjglFileHandle(path, FileType.Internal);}
public FileHandle external(String path) {return new LwjglFileHandle(path, FileType.External);}
public FileHandle absolute(String path) {return new LwjglFileHandle(path, FileType.Absolute);}
public FileHandle local(String path) {return new LwjglFileHandle(path, FileType.Local);}
public String getExternalStoragePath() {return externalPath;}
public boolean isExternalStorageAvailable() {return true;}
public String getLocalStoragePath() {return localPath;}
public boolean isLocalStorageAvailable() {return true;}public void create() {float w = Gdx.graphics.getWidth();float h = Gdx.graphics.getHeight();camera = new OrthographicCamera();camera.setToOrtho(false, (w / h) * 100, 100);camera.zoom = 2;camera.update();cameraController = new OrthoCamController(camera);Gdx.input.setInputProcessor(cameraController);font = new BitmapFont();batch = new SpriteBatch();map = new TmxMapLoader().load("data/maps/tiled-objects/test-load-mapobjects.tmx");MapProperties properties = map.getProperties();shapeRenderer = new ShapeRenderer();}
public void render() {Gdx.gl.glClearColor(0.55f, 0.55f, 0.55f, 1f);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);camera.update();shapeRenderer.setProjectionMatrix(camera.combined);batch.setProjectionMatrix(camera.combined);shapeRenderer.setColor(Color.BLUE);Gdx.gl20.glLineWidth(2);MapLayer layer = map.getLayers().get("Objects");AnimatedTiledMapTile.updateAnimationBaseTime();for (MapObject mapObject : layer.getObjects()) {if (mapObject instanceof TiledMapTileMapObject) {batch.begin();TiledMapTileMapObject tmtObject = (TiledMapTileMapObject) mapObject;TextureRegion textureRegion = tmtObject.getTile().getTextureRegion();// TilEd rotation is clockwise, we need counter-clockwise.float rotation = -tmtObject.getRotation();float scaleX = tmtObject.getScaleX();float scaleY = tmtObject.getScaleY();float xPos = tmtObject.getX();float yPos = tmtObject.getY();textureRegion.flip(tmtObject.isFlipHorizontally(), tmtObject.isFlipVertically());batch.draw(textureRegion, xPos, yPos, tmtObject.getOriginX() * scaleX, tmtObject.getOriginY() * scaleY, textureRegion.getRegionWidth() * scaleX, textureRegion.getRegionHeight() * scaleY, 1f, 1f, rotation);// We flip back to the original state.textureRegion.flip(tmtObject.isFlipHorizontally(), tmtObject.isFlipVertically());batch.end();} else if (mapObject instanceof EllipseMapObject) {shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);Ellipse ellipse = ((EllipseMapObject) mapObject).getEllipse();shapeRenderer.ellipse(ellipse.x, ellipse.y, ellipse.width, ellipse.height);shapeRenderer.end();} else if (mapObject instanceof RectangleMapObject) {shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);Rectangle rectangle = ((RectangleMapObject) mapObject).getRectangle();shapeRenderer.rect(rectangle.x, rectangle.y, rectangle.width, rectangle.height);shapeRenderer.end();} else if (mapObject instanceof PolygonMapObject) {shapeRenderer.begin(ShapeRenderer.ShapeType.Line);Polygon polygon = ((PolygonMapObject) mapObject).getPolygon();shapeRenderer.polygon(polygon.getTransformedVertices());shapeRenderer.end();}}batch.begin();font.draw(batch, "FPS: " + Gdx.graphics.getFramesPerSecond(), 10, 20);batch.end();}
public void dispose() {map.dispose();shapeRenderer.dispose();}public void lookAt(float x, float y, float z) {tmpVec.set(x, y, z).sub(position).nor();if (!tmpVec.isZero()) {// up and direction must ALWAYS be orthonormal vectorsfloat dot = tmpVec.dot(up);if (Math.abs(dot - 1) < 0.000000001f) {// Collinearup.set(direction).scl(-1);} else if (Math.abs(dot + 1) < 0.000000001f) {// Collinear oppositeup.set(direction);}direction.set(tmpVec);normalizeUp();}}
public void lookAt(Vector3 target) {lookAt(target.x, target.y, target.z);}
public void normalizeUp() {tmpVec.set(direction).crs(up).nor();up.set(tmpVec).crs(direction).nor();}
public void rotate(float angle, float axisX, float axisY, float axisZ) {direction.rotate(angle, axisX, axisY, axisZ);up.rotate(angle, axisX, axisY, axisZ);}
public void rotate(Vector3 axis, float angle) {direction.rotate(axis, angle);up.rotate(axis, angle);}
public void rotate(final Matrix4 transform) {direction.rot(transform);up.rot(transform);}
public void rotate(final Quaternion quat) {quat.transform(direction);quat.transform(up);}
public void rotateAround(Vector3 point, Vector3 axis, float angle) {tmpVec.set(point);tmpVec.sub(position);translate(tmpVec);rotate(axis, angle);tmpVec.rotate(axis, angle);translate(-tmpVec.x, -tmpVec.y, -tmpVec.z);}
public void transform(final Matrix4 transform) {position.mul(transform);rotate(transform);}
public void translate(float x, float y, float z) {position.add(x, y, z);}
public void translate(Vector3 vec) {position.add(vec);}
public Vector3 unproject(Vector3 screenCoords, float viewportX, float viewportY, float viewportWidth, float viewportHeight) {float x = screenCoords.x, y = screenCoords.y;x = x - viewportX;y = Gdx.graphics.getHeight() - y - 1;y = y - viewportY;screenCoords.x = (2 * x) / viewportWidth - 1;screenCoords.y = (2 * y) / viewportHeight - 1;screenCoords.z = 2 * screenCoords.z - 1;screenCoords.prj(invProjectionView);return screenCoords;}
public Vector3 unproject(Vector3 screenCoords) {unproject(screenCoords, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());return screenCoords;}
public Vector3 project(Vector3 worldCoords) {project(worldCoords, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());return worldCoords;}
public Vector3 project(Vector3 worldCoords, float viewportX, float viewportY, float viewportWidth, float viewportHeight) {worldCoords.prj(combined);worldCoords.x = viewportWidth * (worldCoords.x + 1) / 2 + viewportX;worldCoords.y = viewportHeight * (worldCoords.y + 1) / 2 + viewportY;worldCoords.z = (worldCoords.z + 1) / 2;return worldCoords;}
public Ray getPickRay(float screenX, float screenY, float viewportX, float viewportY, float viewportWidth, float viewportHeight) {unproject(ray.origin.set(screenX, screenY, 0), viewportX, viewportY, viewportWidth, viewportHeight);unproject(ray.direction.set(screenX, screenY, 1), viewportX, viewportY, viewportWidth, viewportHeight);ray.direction.sub(ray.origin).nor();return ray;}
public Ray getPickRay(float screenX, float screenY) {return getPickRay(screenX, screenY, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());}public int getWidth() {return width;}
public int getHeight() {return height;}
public float getTileWidth() {return tileWidth;}
public float getTileHeight() {return tileHeight;}
public Cell getCell(int x, int y) {if (x < 0 || x >= width)return null;if (y < 0 || y >= height)return null;return cells[x][y];}
public void setCell(int x, int y, Cell cell) {if (x < 0 || x >= width)return;if (y < 0 || y >= height)return;cells[x][y] = cell;}
public TiledMapTile getTile() {return tile;}
public void setTile(TiledMapTile tile) {this.tile = tile;}
public boolean getFlipHorizontally() {return flipHorizontally;}
public void setFlipHorizontally(boolean flipHorizontally) {this.flipHorizontally = flipHorizontally;}
public boolean getFlipVertically() {return flipVertically;}
public void setFlipVertically(boolean flipVertically) {this.flipVertically = flipVertically;}
public int getRotation() {return rotation;}
public void setRotation(int rotation) {this.rotation = rotation;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(BT_QUANTIZED_BVH_NODE obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_BT_QUANTIZED_BVH_NODE(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setQuantizedAabbMin(int[] value) {CollisionJNI.BT_QUANTIZED_BVH_NODE_quantizedAabbMin_set(swigCPtr, this, value);}
public int[] getQuantizedAabbMin() {return CollisionJNI.BT_QUANTIZED_BVH_NODE_quantizedAabbMin_get(swigCPtr, this);}
public void setQuantizedAabbMax(int[] value) {CollisionJNI.BT_QUANTIZED_BVH_NODE_quantizedAabbMax_set(swigCPtr, this, value);}
public int[] getQuantizedAabbMax() {return CollisionJNI.BT_QUANTIZED_BVH_NODE_quantizedAabbMax_get(swigCPtr, this);}
public void setEscapeIndexOrDataIndex(int value) {CollisionJNI.BT_QUANTIZED_BVH_NODE_escapeIndexOrDataIndex_set(swigCPtr, this, value);}
public int getEscapeIndexOrDataIndex() {return CollisionJNI.BT_QUANTIZED_BVH_NODE_escapeIndexOrDataIndex_get(swigCPtr, this);}
public boolean isLeafNode() {return CollisionJNI.BT_QUANTIZED_BVH_NODE_isLeafNode(swigCPtr, this);}
public int getEscapeIndex() {return CollisionJNI.BT_QUANTIZED_BVH_NODE_getEscapeIndex(swigCPtr, this);}
public void setEscapeIndex(int index) {CollisionJNI.BT_QUANTIZED_BVH_NODE_setEscapeIndex(swigCPtr, this, index);}
public int getDataIndex() {return CollisionJNI.BT_QUANTIZED_BVH_NODE_getDataIndex(swigCPtr, this);}
public void setDataIndex(int index) {CollisionJNI.BT_QUANTIZED_BVH_NODE_setDataIndex(swigCPtr, this, index);}
public boolean testQuantizedBoxOverlapp(java.nio.IntBuffer quantizedMin, java.nio.IntBuffer quantizedMax) {assert quantizedMin.isDirect() : "Buffer must be allocated direct.";assert quantizedMax.isDirect() : "Buffer must be allocated direct.";{return CollisionJNI.BT_QUANTIZED_BVH_NODE_testQuantizedBoxOverlapp(swigCPtr, this, quantizedMin, quantizedMax);}}protected static long getCPtr(SWIGTYPE_p_btSoftBody__eFeature___ obj) {return (obj == null) ? 0 : obj.swigCPtr;}protected void begin() {startWidth = target.getWidth();startHeight = target.getHeight();}
protected void update(float percent) {target.setSize(startWidth + (endWidth - startWidth) * percent, startHeight + (endHeight - startHeight) * percent);}
public void setSize(float width, float height) {endWidth = width;endHeight = height;}
public float getWidth() {return endWidth;}
public void setWidth(float width) {endWidth = width;}
public float getHeight() {return endHeight;}
public void setHeight(float height) {endHeight = height;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btRigidBodyFloatData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btRigidBodyFloatData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setCollisionObjectData(btCollisionObjectFloatData value) {DynamicsJNI.btRigidBodyFloatData_collisionObjectData_set(swigCPtr, this, btCollisionObjectFloatData.getCPtr(value), value);}
public btCollisionObjectFloatData getCollisionObjectData() {long cPtr = DynamicsJNI.btRigidBodyFloatData_collisionObjectData_get(swigCPtr, this);return (cPtr == 0) ? null : new btCollisionObjectFloatData(cPtr, false);}
public void setInvInertiaTensorWorld(SWIGTYPE_p_btMatrix3x3FloatData value) {DynamicsJNI.btRigidBodyFloatData_invInertiaTensorWorld_set(swigCPtr, this, SWIGTYPE_p_btMatrix3x3FloatData.getCPtr(value));}
public SWIGTYPE_p_btMatrix3x3FloatData getInvInertiaTensorWorld() {return new SWIGTYPE_p_btMatrix3x3FloatData(DynamicsJNI.btRigidBodyFloatData_invInertiaTensorWorld_get(swigCPtr, this), true);}
public void setLinearVelocity(btVector3FloatData value) {DynamicsJNI.btRigidBodyFloatData_linearVelocity_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getLinearVelocity() {long cPtr = DynamicsJNI.btRigidBodyFloatData_linearVelocity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setAngularVelocity(btVector3FloatData value) {DynamicsJNI.btRigidBodyFloatData_angularVelocity_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getAngularVelocity() {long cPtr = DynamicsJNI.btRigidBodyFloatData_angularVelocity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setAngularFactor(btVector3FloatData value) {DynamicsJNI.btRigidBodyFloatData_angularFactor_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getAngularFactor() {long cPtr = DynamicsJNI.btRigidBodyFloatData_angularFactor_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setLinearFactor(btVector3FloatData value) {DynamicsJNI.btRigidBodyFloatData_linearFactor_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getLinearFactor() {long cPtr = DynamicsJNI.btRigidBodyFloatData_linearFactor_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setGravity(btVector3FloatData value) {DynamicsJNI.btRigidBodyFloatData_gravity_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getGravity() {long cPtr = DynamicsJNI.btRigidBodyFloatData_gravity_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setGravity_acceleration(btVector3FloatData value) {DynamicsJNI.btRigidBodyFloatData_gravity_acceleration_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getGravity_acceleration() {long cPtr = DynamicsJNI.btRigidBodyFloatData_gravity_acceleration_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setInvInertiaLocal(btVector3FloatData value) {DynamicsJNI.btRigidBodyFloatData_invInertiaLocal_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getInvInertiaLocal() {long cPtr = DynamicsJNI.btRigidBodyFloatData_invInertiaLocal_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setTotalForce(btVector3FloatData value) {DynamicsJNI.btRigidBodyFloatData_totalForce_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getTotalForce() {long cPtr = DynamicsJNI.btRigidBodyFloatData_totalForce_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setTotalTorque(btVector3FloatData value) {DynamicsJNI.btRigidBodyFloatData_totalTorque_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getTotalTorque() {long cPtr = DynamicsJNI.btRigidBodyFloatData_totalTorque_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setInverseMass(float value) {DynamicsJNI.btRigidBodyFloatData_inverseMass_set(swigCPtr, this, value);}
public float getInverseMass() {return DynamicsJNI.btRigidBodyFloatData_inverseMass_get(swigCPtr, this);}
public void setLinearDamping(float value) {DynamicsJNI.btRigidBodyFloatData_linearDamping_set(swigCPtr, this, value);}
public float getLinearDamping() {return DynamicsJNI.btRigidBodyFloatData_linearDamping_get(swigCPtr, this);}
public void setAngularDamping(float value) {DynamicsJNI.btRigidBodyFloatData_angularDamping_set(swigCPtr, this, value);}
public float getAngularDamping() {return DynamicsJNI.btRigidBodyFloatData_angularDamping_get(swigCPtr, this);}
public void setAdditionalDampingFactor(float value) {DynamicsJNI.btRigidBodyFloatData_additionalDampingFactor_set(swigCPtr, this, value);}
public float getAdditionalDampingFactor() {return DynamicsJNI.btRigidBodyFloatData_additionalDampingFactor_get(swigCPtr, this);}
public void setAdditionalLinearDampingThresholdSqr(float value) {DynamicsJNI.btRigidBodyFloatData_additionalLinearDampingThresholdSqr_set(swigCPtr, this, value);}
public float getAdditionalLinearDampingThresholdSqr() {return DynamicsJNI.btRigidBodyFloatData_additionalLinearDampingThresholdSqr_get(swigCPtr, this);}
public void setAdditionalAngularDampingThresholdSqr(float value) {DynamicsJNI.btRigidBodyFloatData_additionalAngularDampingThresholdSqr_set(swigCPtr, this, value);}
public float getAdditionalAngularDampingThresholdSqr() {return DynamicsJNI.btRigidBodyFloatData_additionalAngularDampingThresholdSqr_get(swigCPtr, this);}
public void setAdditionalAngularDampingFactor(float value) {DynamicsJNI.btRigidBodyFloatData_additionalAngularDampingFactor_set(swigCPtr, this, value);}
public float getAdditionalAngularDampingFactor() {return DynamicsJNI.btRigidBodyFloatData_additionalAngularDampingFactor_get(swigCPtr, this);}
public void setLinearSleepingThreshold(float value) {DynamicsJNI.btRigidBodyFloatData_linearSleepingThreshold_set(swigCPtr, this, value);}
public float getLinearSleepingThreshold() {return DynamicsJNI.btRigidBodyFloatData_linearSleepingThreshold_get(swigCPtr, this);}
public void setAngularSleepingThreshold(float value) {DynamicsJNI.btRigidBodyFloatData_angularSleepingThreshold_set(swigCPtr, this, value);}
public float getAngularSleepingThreshold() {return DynamicsJNI.btRigidBodyFloatData_angularSleepingThreshold_get(swigCPtr, this);}
public void setAdditionalDamping(int value) {DynamicsJNI.btRigidBodyFloatData_additionalDamping_set(swigCPtr, this, value);}
public int getAdditionalDamping() {return DynamicsJNI.btRigidBodyFloatData_additionalDamping_get(swigCPtr, this);}protected void createWorld(World world) {{BodyDef bd = new BodyDef();Body ground = world.createBody(bd);EdgeShape shape = new EdgeShape();shape.set(new Vector2(-40, 0), new Vector2(40, 0));ground.createFixture(shape, 0.0f);shape.set(new Vector2(20, 0), new Vector2(20, 20));ground.createFixture(shape, 0);shape.dispose();}float xs[] = { 0, -10, -5, 5, 10 };for (int j = 0; j < e_columnCount; j++) {PolygonShape shape = new PolygonShape();shape.setAsBox(0.5f, 0.5f);FixtureDef fd = new FixtureDef();fd.shape = shape;fd.density = 1.0f;fd.friction = 0.3f;for (int i = 0; i < e_rowCount; i++) {BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;int n = j * e_rowCount + i;m_indices[n] = n;float x = 0;bd.position.set(xs[j] + x, 0.752f + 1.54f * i);Body body = world.createBody(bd);body.setUserData(n);m_bodies[n] = body;body.createFixture(fd);}shape.dispose();}m_bullet = null;}
public boolean keyDown(int keyCode) {if (keyCode == Input.Keys.COMMA) {if (m_bullet != null) {world.destroyBody(m_bullet);m_bullet = null;}{CircleShape shape = new CircleShape();shape.setRadius(0.25f);FixtureDef fd = new FixtureDef();fd.shape = shape;fd.density = 20.0f;fd.restitution = 0.05f;BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.bullet = true;bd.position.set(-31, 5);m_bullet = world.createBody(bd);m_bullet.createFixture(fd);m_bullet.setLinearVelocity(new Vector2(400, 0));}}return false;}
public void render() {super.render();}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btHingeConstraintDoubleData2 obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;DynamicsJNI.delete_btHingeConstraintDoubleData2(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setTypeConstraintData(btTypedConstraintDoubleData value) {DynamicsJNI.btHingeConstraintDoubleData2_typeConstraintData_set(swigCPtr, this, btTypedConstraintDoubleData.getCPtr(value), value);}
public btTypedConstraintDoubleData getTypeConstraintData() {long cPtr = DynamicsJNI.btHingeConstraintDoubleData2_typeConstraintData_get(swigCPtr, this);return (cPtr == 0) ? null : new btTypedConstraintDoubleData(cPtr, false);}
public void setRbAFrame(btTransformDoubleData value) {DynamicsJNI.btHingeConstraintDoubleData2_rbAFrame_set(swigCPtr, this, btTransformDoubleData.getCPtr(value), value);}
public btTransformDoubleData getRbAFrame() {long cPtr = DynamicsJNI.btHingeConstraintDoubleData2_rbAFrame_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransformDoubleData(cPtr, false);}
public void setRbBFrame(btTransformDoubleData value) {DynamicsJNI.btHingeConstraintDoubleData2_rbBFrame_set(swigCPtr, this, btTransformDoubleData.getCPtr(value), value);}
public btTransformDoubleData getRbBFrame() {long cPtr = DynamicsJNI.btHingeConstraintDoubleData2_rbBFrame_get(swigCPtr, this);return (cPtr == 0) ? null : new btTransformDoubleData(cPtr, false);}
public void setUseReferenceFrameA(int value) {DynamicsJNI.btHingeConstraintDoubleData2_useReferenceFrameA_set(swigCPtr, this, value);}
public int getUseReferenceFrameA() {return DynamicsJNI.btHingeConstraintDoubleData2_useReferenceFrameA_get(swigCPtr, this);}
public void setAngularOnly(int value) {DynamicsJNI.btHingeConstraintDoubleData2_angularOnly_set(swigCPtr, this, value);}
public int getAngularOnly() {return DynamicsJNI.btHingeConstraintDoubleData2_angularOnly_get(swigCPtr, this);}
public void setEnableAngularMotor(int value) {DynamicsJNI.btHingeConstraintDoubleData2_enableAngularMotor_set(swigCPtr, this, value);}
public int getEnableAngularMotor() {return DynamicsJNI.btHingeConstraintDoubleData2_enableAngularMotor_get(swigCPtr, this);}
public void setMotorTargetVelocity(double value) {DynamicsJNI.btHingeConstraintDoubleData2_motorTargetVelocity_set(swigCPtr, this, value);}
public double getMotorTargetVelocity() {return DynamicsJNI.btHingeConstraintDoubleData2_motorTargetVelocity_get(swigCPtr, this);}
public void setMaxMotorImpulse(double value) {DynamicsJNI.btHingeConstraintDoubleData2_maxMotorImpulse_set(swigCPtr, this, value);}
public double getMaxMotorImpulse() {return DynamicsJNI.btHingeConstraintDoubleData2_maxMotorImpulse_get(swigCPtr, this);}
public void setLowerLimit(double value) {DynamicsJNI.btHingeConstraintDoubleData2_lowerLimit_set(swigCPtr, this, value);}
public double getLowerLimit() {return DynamicsJNI.btHingeConstraintDoubleData2_lowerLimit_get(swigCPtr, this);}
public void setUpperLimit(double value) {DynamicsJNI.btHingeConstraintDoubleData2_upperLimit_set(swigCPtr, this, value);}
public double getUpperLimit() {return DynamicsJNI.btHingeConstraintDoubleData2_upperLimit_get(swigCPtr, this);}
public void setLimitSoftness(double value) {DynamicsJNI.btHingeConstraintDoubleData2_limitSoftness_set(swigCPtr, this, value);}
public double getLimitSoftness() {return DynamicsJNI.btHingeConstraintDoubleData2_limitSoftness_get(swigCPtr, this);}
public void setBiasFactor(double value) {DynamicsJNI.btHingeConstraintDoubleData2_biasFactor_set(swigCPtr, this, value);}
public double getBiasFactor() {return DynamicsJNI.btHingeConstraintDoubleData2_biasFactor_get(swigCPtr, this);}
public void setRelaxationFactor(double value) {DynamicsJNI.btHingeConstraintDoubleData2_relaxationFactor_set(swigCPtr, this, value);}
public double getRelaxationFactor() {return DynamicsJNI.btHingeConstraintDoubleData2_relaxationFactor_get(swigCPtr, this);}
public void setPadding1(String value) {DynamicsJNI.btHingeConstraintDoubleData2_padding1_set(swigCPtr, this, value);}
public String getPadding1() {return DynamicsJNI.btHingeConstraintDoubleData2_padding1_get(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btGjkPairDetector_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btGjkPairDetector obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btGjkPairDetector(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setLastUsedMethod(int value) {CollisionJNI.btGjkPairDetector_lastUsedMethod_set(swigCPtr, this, value);}
public int getLastUsedMethod() {return CollisionJNI.btGjkPairDetector_lastUsedMethod_get(swigCPtr, this);}
public void setCurIter(int value) {CollisionJNI.btGjkPairDetector_curIter_set(swigCPtr, this, value);}
public int getCurIter() {return CollisionJNI.btGjkPairDetector_curIter_get(swigCPtr, this);}
public void setDegenerateSimplex(int value) {CollisionJNI.btGjkPairDetector_degenerateSimplex_set(swigCPtr, this, value);}
public int getDegenerateSimplex() {return CollisionJNI.btGjkPairDetector_degenerateSimplex_get(swigCPtr, this);}
public void setCatchDegeneracies(int value) {CollisionJNI.btGjkPairDetector_catchDegeneracies_set(swigCPtr, this, value);}
public int getCatchDegeneracies() {return CollisionJNI.btGjkPairDetector_catchDegeneracies_get(swigCPtr, this);}
public void setFixContactNormalDirection(int value) {CollisionJNI.btGjkPairDetector_fixContactNormalDirection_set(swigCPtr, this, value);}
public int getFixContactNormalDirection() {return CollisionJNI.btGjkPairDetector_fixContactNormalDirection_get(swigCPtr, this);}
public void getClosestPoints(btDiscreteCollisionDetectorInterface.ClosestPointInput input, btDiscreteCollisionDetectorInterface.Result output, btIDebugDraw debugDraw, boolean swapResults) {CollisionJNI.btGjkPairDetector_getClosestPoints__SWIG_0(swigCPtr, this, btDiscreteCollisionDetectorInterface.ClosestPointInput.getCPtr(input), input, btDiscreteCollisionDetectorInterface.Result.getCPtr(output), output, btIDebugDraw.getCPtr(debugDraw), debugDraw, swapResults);}
public void getClosestPoints(btDiscreteCollisionDetectorInterface.ClosestPointInput input, btDiscreteCollisionDetectorInterface.Result output, btIDebugDraw debugDraw) {CollisionJNI.btGjkPairDetector_getClosestPoints__SWIG_1(swigCPtr, this, btDiscreteCollisionDetectorInterface.ClosestPointInput.getCPtr(input), input, btDiscreteCollisionDetectorInterface.Result.getCPtr(output), output, btIDebugDraw.getCPtr(debugDraw), debugDraw);}
public void getClosestPointsNonVirtual(btDiscreteCollisionDetectorInterface.ClosestPointInput input, btDiscreteCollisionDetectorInterface.Result output, btIDebugDraw debugDraw) {CollisionJNI.btGjkPairDetector_getClosestPointsNonVirtual(swigCPtr, this, btDiscreteCollisionDetectorInterface.ClosestPointInput.getCPtr(input), input, btDiscreteCollisionDetectorInterface.Result.getCPtr(output), output, btIDebugDraw.getCPtr(debugDraw), debugDraw);}
public void setMinkowskiA(btConvexShape minkA) {CollisionJNI.btGjkPairDetector_setMinkowskiA(swigCPtr, this, btConvexShape.getCPtr(minkA), minkA);}
public void setMinkowskiB(btConvexShape minkB) {CollisionJNI.btGjkPairDetector_setMinkowskiB(swigCPtr, this, btConvexShape.getCPtr(minkB), minkB);}
public void setCachedSeperatingAxis(Vector3 seperatingAxis) {CollisionJNI.btGjkPairDetector_setCachedSeperatingAxis(swigCPtr, this, seperatingAxis);}
public Vector3 getCachedSeparatingAxis() {return CollisionJNI.btGjkPairDetector_getCachedSeparatingAxis(swigCPtr, this);}
public float getCachedSeparatingDistance() {return CollisionJNI.btGjkPairDetector_getCachedSeparatingDistance(swigCPtr, this);}
public void setPenetrationDepthSolver(btConvexPenetrationDepthSolver penetrationDepthSolver) {CollisionJNI.btGjkPairDetector_setPenetrationDepthSolver(swigCPtr, this, btConvexPenetrationDepthSolver.getCPtr(penetrationDepthSolver), penetrationDepthSolver);}
public void setIgnoreMargin(boolean ignoreMargin) {CollisionJNI.btGjkPairDetector_setIgnoreMargin(swigCPtr, this, ignoreMargin);}public static TextureData loadFromFile(FileHandle file, boolean useMipMaps) {return loadFromFile(file, null, useMipMaps);}
public static TextureData loadFromFile(FileHandle file, Format format, boolean useMipMaps) {if (file == null)return null;if (file.name().endsWith(".cim"))return new FileTextureData(file, PixmapIO.readCIM(file), format, useMipMaps);if (file.name().endsWith(".etc1"))return new ETC1TextureData(file, useMipMaps);if (file.name().endsWith(".ktx") || file.name().endsWith(".zktx"))return new KTXTextureData(file, useMipMaps);return new FileTextureData(file, new Pixmap(file), format, useMipMaps);}public void didFinishPlaying(NSObject player, boolean success) {final OnCompletionListener listener = onCompletionListener;if (listener != null) {Gdx.app.postRunnable(new Runnable() {
@Overridepublic void run() {listener.onCompletion(IOSMusic.this);}});}}
public void run() {listener.onCompletion(IOSMusic.this);}
public void play() {if (track.isPaused()) {track.setPaused(false);} else if (!track.isPlaying()) {track.play();}}
public void pause() {if (track.isPlaying()) {track.setPaused(true);}}
public void stop() {track.stop();}
public boolean isPlaying() {return track.isPlaying() && !track.isPaused();}
public void setLooping(boolean isLooping) {track.setNumberOfLoops(isLooping ? -1 : 0);}
public boolean isLooping() {return track.getNumberOfLoops() == -1;}
public void setVolume(float volume) {track.setVolume(volume);}
public void setPosition(float position) {track.setCurrentTime(position);}
public float getPosition() {return (float) (track.getCurrentTime());}
public void dispose() {track.clear();}
public float getVolume() {return track.getVolume();}
public void setPan(float pan, float volume) {track.setPan(pan);track.setVolume(volume);}
public void setOnCompletionListener(OnCompletionListener listener) {this.onCompletionListener = listener;}public void update(int screenWidth, int screenHeight, boolean centerCamera) {// Fit min size to the screen.float worldWidth = minWorldWidth;float worldHeight = minWorldHeight;Vector2 scaled = Scaling.fit.apply(worldWidth, worldHeight, screenWidth, screenHeight);// Extend in the short direction.int viewportWidth = Math.round(scaled.x);int viewportHeight = Math.round(scaled.y);if (viewportWidth < screenWidth) {float toViewportSpace = viewportHeight / worldHeight;float toWorldSpace = worldHeight / viewportHeight;float lengthen = (screenWidth - viewportWidth) * toWorldSpace;if (maxWorldWidth > 0)lengthen = Math.min(lengthen, maxWorldWidth - minWorldWidth);worldWidth += lengthen;viewportWidth += Math.round(lengthen * toViewportSpace);} else if (viewportHeight < screenHeight) {float toViewportSpace = viewportWidth / worldWidth;float toWorldSpace = worldWidth / viewportWidth;float lengthen = (screenHeight - viewportHeight) * toWorldSpace;if (maxWorldHeight > 0)lengthen = Math.min(lengthen, maxWorldHeight - minWorldHeight);worldHeight += lengthen;viewportHeight += Math.round(lengthen * toViewportSpace);}setWorldSize(worldWidth, worldHeight);// Center.setScreenBounds((screenWidth - viewportWidth) / 2, (screenHeight - viewportHeight) / 2, viewportWidth, viewportHeight);apply(centerCamera);}
public float getMinWorldWidth() {return minWorldWidth;}
public void setMinWorldWidth(float minWorldWidth) {this.minWorldWidth = minWorldWidth;}
public float getMinWorldHeight() {return minWorldHeight;}
public void setMinWorldHeight(float minWorldHeight) {this.minWorldHeight = minWorldHeight;}
public float getMaxWorldWidth() {return maxWorldWidth;}
public void setMaxWorldWidth(float maxWorldWidth) {this.maxWorldWidth = maxWorldWidth;}
public float getMaxWorldHeight() {return maxWorldHeight;}
public void setMaxWorldHeight(float maxWorldHeight) {this.maxWorldHeight = maxWorldHeight;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btHashInt obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;LinearMathJNI.delete_btHashInt(swigCPtr);}swigCPtr = 0;}super.delete();}
public int getUid1() {return LinearMathJNI.btHashInt_getUid1(swigCPtr, this);}
public void setUid1(int uid) {LinearMathJNI.btHashInt_setUid1(swigCPtr, this, uid);}
public boolean equals(btHashInt other) {return LinearMathJNI.btHashInt_equals(swigCPtr, this, btHashInt.getCPtr(other), other);}
public long getHash() {return LinearMathJNI.btHashInt_getHash(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btAxisSweep3InternalInt_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btAxisSweep3InternalInt obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btAxisSweep3InternalInt(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(Edge obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btAxisSweep3InternalInt_Edge(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setPos(long value) {CollisionJNI.btAxisSweep3InternalInt_Edge_pos_set(swigCPtr, this, value);}
public long getPos() {return CollisionJNI.btAxisSweep3InternalInt_Edge_pos_get(swigCPtr, this);}
public void setHandle(long value) {CollisionJNI.btAxisSweep3InternalInt_Edge_handle_set(swigCPtr, this, value);}
public long getHandle() {return CollisionJNI.btAxisSweep3InternalInt_Edge_handle_get(swigCPtr, this);}
public long IsMax() {return CollisionJNI.btAxisSweep3InternalInt_Edge_IsMax(swigCPtr, this);}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btAxisSweep3InternalInt_Handle_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(Handle obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btAxisSweep3InternalInt_Handle(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setMinEdges(long[] value) {CollisionJNI.btAxisSweep3InternalInt_Handle_minEdges_set(swigCPtr, this, value);}
public long[] getMinEdges() {return CollisionJNI.btAxisSweep3InternalInt_Handle_minEdges_get(swigCPtr, this);}
public void setMaxEdges(long[] value) {CollisionJNI.btAxisSweep3InternalInt_Handle_maxEdges_set(swigCPtr, this, value);}
public long[] getMaxEdges() {return CollisionJNI.btAxisSweep3InternalInt_Handle_maxEdges_get(swigCPtr, this);}
public void setDbvtProxy(btBroadphaseProxy value) {CollisionJNI.btAxisSweep3InternalInt_Handle_dbvtProxy_set(swigCPtr, this, btBroadphaseProxy.getCPtr(value), value);}
public btBroadphaseProxy getDbvtProxy() {return btBroadphaseProxy.internalTemp(CollisionJNI.btAxisSweep3InternalInt_Handle_dbvtProxy_get(swigCPtr, this), false);}
public void SetNextFree(long next) {CollisionJNI.btAxisSweep3InternalInt_Handle_SetNextFree(swigCPtr, this, next);}
public long GetNextFree() {return CollisionJNI.btAxisSweep3InternalInt_Handle_GetNextFree(swigCPtr, this);}
public long getNumHandles() {return CollisionJNI.btAxisSweep3InternalInt_getNumHandles(swigCPtr, this);}
public long addHandle(Vector3 aabbMin, Vector3 aabbMax, long pOwner, short collisionFilterGroup, short collisionFilterMask, btDispatcher dispatcher, long multiSapProxy) {return CollisionJNI.btAxisSweep3InternalInt_addHandle(swigCPtr, this, aabbMin, aabbMax, pOwner, collisionFilterGroup, collisionFilterMask, btDispatcher.getCPtr(dispatcher), dispatcher, multiSapProxy);}
public void removeHandle(long handle, btDispatcher dispatcher) {CollisionJNI.btAxisSweep3InternalInt_removeHandle(swigCPtr, this, handle, btDispatcher.getCPtr(dispatcher), dispatcher);}
public void updateHandle(long handle, Vector3 aabbMin, Vector3 aabbMax, btDispatcher dispatcher) {CollisionJNI.btAxisSweep3InternalInt_updateHandle(swigCPtr, this, handle, aabbMin, aabbMax, btDispatcher.getCPtr(dispatcher), dispatcher);}
public btAxisSweep3InternalInt.Handle getHandle(long index) {long cPtr = CollisionJNI.btAxisSweep3InternalInt_getHandle(swigCPtr, this, index);return (cPtr == 0) ? null : new btAxisSweep3InternalInt.Handle(cPtr, false);}
public void rayTest(Vector3 rayFrom, Vector3 rayTo, btBroadphaseRayCallback rayCallback, Vector3 aabbMin, Vector3 aabbMax) {CollisionJNI.btAxisSweep3InternalInt_rayTest__SWIG_0(swigCPtr, this, rayFrom, rayTo, btBroadphaseRayCallback.getCPtr(rayCallback), rayCallback, aabbMin, aabbMax);}
public void rayTest(Vector3 rayFrom, Vector3 rayTo, btBroadphaseRayCallback rayCallback, Vector3 aabbMin) {CollisionJNI.btAxisSweep3InternalInt_rayTest__SWIG_1(swigCPtr, this, rayFrom, rayTo, btBroadphaseRayCallback.getCPtr(rayCallback), rayCallback, aabbMin);}
public void rayTest(Vector3 rayFrom, Vector3 rayTo, btBroadphaseRayCallback rayCallback) {CollisionJNI.btAxisSweep3InternalInt_rayTest__SWIG_2(swigCPtr, this, rayFrom, rayTo, btBroadphaseRayCallback.getCPtr(rayCallback), rayCallback);}
public void quantize(java.nio.LongBuffer out, Vector3 point, int isMax) {assert out.isDirect() : "Buffer must be allocated direct.";{CollisionJNI.btAxisSweep3InternalInt_quantize(swigCPtr, this, out, point, isMax);}}
public void unQuantize(btBroadphaseProxy proxy, Vector3 aabbMin, Vector3 aabbMax) {CollisionJNI.btAxisSweep3InternalInt_unQuantize(swigCPtr, this, btBroadphaseProxy.getCPtr(proxy), proxy, aabbMin, aabbMax);}
public boolean testAabbOverlap(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1) {return CollisionJNI.btAxisSweep3InternalInt_testAabbOverlap(swigCPtr, this, btBroadphaseProxy.getCPtr(proxy0), proxy0, btBroadphaseProxy.getCPtr(proxy1), proxy1);}
public btOverlappingPairCache getOverlappingPairCache() {long cPtr = CollisionJNI.btAxisSweep3InternalInt_getOverlappingPairCache__SWIG_0(swigCPtr, this);return (cPtr == 0) ? null : new btOverlappingPairCache(cPtr, false);}
public void setOverlappingPairUserCallback(btOverlappingPairCallback pairCallback) {CollisionJNI.btAxisSweep3InternalInt_setOverlappingPairUserCallback(swigCPtr, this, btOverlappingPairCallback.getCPtr(pairCallback), pairCallback);}
public btOverlappingPairCallback getOverlappingPairUserCallback() {long cPtr = CollisionJNI.btAxisSweep3InternalInt_getOverlappingPairUserCallback(swigCPtr, this);return (cPtr == 0) ? null : new btOverlappingPairCallback(cPtr, false);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(ICollide obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_ICollide(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void swigDirectorDisconnect() {swigCMemOwn = false;delete();}
public void swigReleaseOwnership() {swigCMemOwn = false;CollisionJNI.ICollide_change_ownership(this, swigCPtr, false);}
public void swigTakeOwnership() {swigCMemOwn = true;CollisionJNI.ICollide_change_ownership(this, swigCPtr, true);}
public void Process(btDbvtNode arg0, btDbvtNode arg1) {if (getClass() == ICollide.class)CollisionJNI.ICollide_Process__SWIG_0(swigCPtr, this, btDbvtNode.getCPtr(arg0), arg0, btDbvtNode.getCPtr(arg1), arg1);elseCollisionJNI.ICollide_ProcessSwigExplicitICollide__SWIG_0(swigCPtr, this, btDbvtNode.getCPtr(arg0), arg0, btDbvtNode.getCPtr(arg1), arg1);}
public void Process(btDbvtNode arg0) {if (getClass() == ICollide.class)CollisionJNI.ICollide_Process__SWIG_1(swigCPtr, this, btDbvtNode.getCPtr(arg0), arg0);elseCollisionJNI.ICollide_ProcessSwigExplicitICollide__SWIG_1(swigCPtr, this, btDbvtNode.getCPtr(arg0), arg0);}
public void Process(btDbvtNode n, float arg1) {if (getClass() == ICollide.class)CollisionJNI.ICollide_Process__SWIG_2(swigCPtr, this, btDbvtNode.getCPtr(n), n, arg1);elseCollisionJNI.ICollide_ProcessSwigExplicitICollide__SWIG_2(swigCPtr, this, btDbvtNode.getCPtr(n), n, arg1);}
public boolean Descent(btDbvtNode arg0) {return (getClass() == ICollide.class) ? CollisionJNI.ICollide_Descent(swigCPtr, this, btDbvtNode.getCPtr(arg0), arg0) : CollisionJNI.ICollide_DescentSwigExplicitICollide(swigCPtr, this, btDbvtNode.getCPtr(arg0), arg0);}
public boolean AllLeaves(btDbvtNode arg0) {return (getClass() == ICollide.class) ? CollisionJNI.ICollide_AllLeaves(swigCPtr, this, btDbvtNode.getCPtr(arg0), arg0) : CollisionJNI.ICollide_AllLeavesSwigExplicitICollide(swigCPtr, this, btDbvtNode.getCPtr(arg0), arg0);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btGImpactQuantizedBvh obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btGImpactQuantizedBvh(swigCPtr);}swigCPtr = 0;}super.delete();}
public btAABB getGlobalBox() {return new btAABB(CollisionJNI.btGImpactQuantizedBvh_getGlobalBox(swigCPtr, this), true);}
public void setPrimitiveManager(btPrimitiveManagerBase primitive_manager) {CollisionJNI.btGImpactQuantizedBvh_setPrimitiveManager(swigCPtr, this, btPrimitiveManagerBase.getCPtr(primitive_manager), primitive_manager);}
public btPrimitiveManagerBase getPrimitiveManager() {long cPtr = CollisionJNI.btGImpactQuantizedBvh_getPrimitiveManager(swigCPtr, this);return (cPtr == 0) ? null : new btPrimitiveManagerBase(cPtr, false);}
public void update() {CollisionJNI.btGImpactQuantizedBvh_update(swigCPtr, this);}
public void buildSet() {CollisionJNI.btGImpactQuantizedBvh_buildSet(swigCPtr, this);}
public boolean boxQuery(btAABB box, SWIGTYPE_p_btAlignedObjectArrayT_int_t collided_results) {return CollisionJNI.btGImpactQuantizedBvh_boxQuery(swigCPtr, this, btAABB.getCPtr(box), box, SWIGTYPE_p_btAlignedObjectArrayT_int_t.getCPtr(collided_results));}
public boolean boxQueryTrans(btAABB box, Matrix4 transform, SWIGTYPE_p_btAlignedObjectArrayT_int_t collided_results) {return CollisionJNI.btGImpactQuantizedBvh_boxQueryTrans(swigCPtr, this, btAABB.getCPtr(box), box, transform, SWIGTYPE_p_btAlignedObjectArrayT_int_t.getCPtr(collided_results));}
public boolean rayQuery(Vector3 ray_dir, Vector3 ray_origin, SWIGTYPE_p_btAlignedObjectArrayT_int_t collided_results) {return CollisionJNI.btGImpactQuantizedBvh_rayQuery(swigCPtr, this, ray_dir, ray_origin, SWIGTYPE_p_btAlignedObjectArrayT_int_t.getCPtr(collided_results));}
public boolean hasHierarchy() {return CollisionJNI.btGImpactQuantizedBvh_hasHierarchy(swigCPtr, this);}
public boolean isTrimesh() {return CollisionJNI.btGImpactQuantizedBvh_isTrimesh(swigCPtr, this);}
public int getNodeCount() {return CollisionJNI.btGImpactQuantizedBvh_getNodeCount(swigCPtr, this);}
public boolean isLeafNode(int nodeindex) {return CollisionJNI.btGImpactQuantizedBvh_isLeafNode(swigCPtr, this, nodeindex);}
public int getNodeData(int nodeindex) {return CollisionJNI.btGImpactQuantizedBvh_getNodeData(swigCPtr, this, nodeindex);}
public void getNodeBound(int nodeindex, btAABB bound) {CollisionJNI.btGImpactQuantizedBvh_getNodeBound(swigCPtr, this, nodeindex, btAABB.getCPtr(bound), bound);}
public void setNodeBound(int nodeindex, btAABB bound) {CollisionJNI.btGImpactQuantizedBvh_setNodeBound(swigCPtr, this, nodeindex, btAABB.getCPtr(bound), bound);}
public int getLeftNode(int nodeindex) {return CollisionJNI.btGImpactQuantizedBvh_getLeftNode(swigCPtr, this, nodeindex);}
public int getRightNode(int nodeindex) {return CollisionJNI.btGImpactQuantizedBvh_getRightNode(swigCPtr, this, nodeindex);}
public int getEscapeNodeIndex(int nodeindex) {return CollisionJNI.btGImpactQuantizedBvh_getEscapeNodeIndex(swigCPtr, this, nodeindex);}
public void getNodeTriangle(int nodeindex, btPrimitiveTriangle triangle) {CollisionJNI.btGImpactQuantizedBvh_getNodeTriangle(swigCPtr, this, nodeindex, btPrimitiveTriangle.getCPtr(triangle), triangle);}
public BT_QUANTIZED_BVH_NODE get_node_pointer(int index) {long cPtr = CollisionJNI.btGImpactQuantizedBvh_get_node_pointer__SWIG_0(swigCPtr, this, index);return (cPtr == 0) ? null : new BT_QUANTIZED_BVH_NODE(cPtr, false);}
public BT_QUANTIZED_BVH_NODE get_node_pointer() {long cPtr = CollisionJNI.btGImpactQuantizedBvh_get_node_pointer__SWIG_1(swigCPtr, this);return (cPtr == 0) ? null : new BT_QUANTIZED_BVH_NODE(cPtr, false);}
public static void find_collision(btGImpactQuantizedBvh boxset1, Matrix4 trans1, btGImpactQuantizedBvh boxset2, Matrix4 trans2, btPairSet collision_pairs) {CollisionJNI.btGImpactQuantizedBvh_find_collision(btGImpactQuantizedBvh.getCPtr(boxset1), boxset1, trans1, btGImpactQuantizedBvh.getCPtr(boxset2), boxset2, trans2, btPairSet.getCPtr(collision_pairs), collision_pairs);}private static void ensureSize(int n) {if (buffer.capacity() < n) {buffer = ByteBuffer.allocateDirect(n).order(ByteOrder.nativeOrder());bufferInt = buffer.asIntBuffer();bufferFloat = buffer.asFloatBuffer();}}
static ByteBuffer toBuffer(boolean[] src, int offset) {int n = src.length - offset;ensureSize(n);buffer.position(0);for (boolean value : src) buffer.put(value ? (byte) 1 : 0);return buffer;}
static IntBuffer toBuffer(int[] src, int offset) {int n = src.length - offset;ensureSize(n * 4);bufferInt.position(0);bufferInt.put(src, offset, n);return bufferInt;}
static FloatBuffer toBuffer(float[] src, int offset) {int n = src.length - offset;ensureSize(n * 4);bufferFloat.position(0);bufferFloat.put(src, offset, n);return bufferFloat;}
static void toArray(ByteBuffer src, boolean[] dst, int offset) {for (int i = 0; i < dst.length - offset; i++) {dst[i + offset] = src.get(i) != 0;}}
static void toArray(IntBuffer src, int[] dst, int offset) {src.position(0);src.get(dst, offset, dst.length - offset);}
static void toArray(FloatBuffer src, float[] dst, int offset) {src.position(0);src.get(dst, offset, dst.length - offset);}public boolean tap(float stageX, float stageY, int count, int button) {actor.stageToLocalCoordinates(tmpCoords.set(stageX, stageY));ActorGestureListener.this.tap(event, tmpCoords.x, tmpCoords.y, count, button);return true;}
public boolean longPress(float stageX, float stageY) {actor.stageToLocalCoordinates(tmpCoords.set(stageX, stageY));return ActorGestureListener.this.longPress(actor, tmpCoords.x, tmpCoords.y);}
public boolean fling(float velocityX, float velocityY, int button) {stageToLocalAmount(tmpCoords.set(velocityX, velocityY));ActorGestureListener.this.fling(event, tmpCoords.x, tmpCoords.y, button);return true;}
public boolean pan(float stageX, float stageY, float deltaX, float deltaY) {stageToLocalAmount(tmpCoords.set(deltaX, deltaY));deltaX = tmpCoords.x;deltaY = tmpCoords.y;actor.stageToLocalCoordinates(tmpCoords.set(stageX, stageY));ActorGestureListener.this.pan(event, tmpCoords.x, tmpCoords.y, deltaX, deltaY);return true;}
public boolean zoom(float initialDistance, float distance) {ActorGestureListener.this.zoom(event, initialDistance, distance);return true;}
public boolean pinch(Vector2 stageInitialPointer1, Vector2 stageInitialPointer2, Vector2 stagePointer1, Vector2 stagePointer2) {actor.stageToLocalCoordinates(initialPointer1.set(stageInitialPointer1));actor.stageToLocalCoordinates(initialPointer2.set(stageInitialPointer2));actor.stageToLocalCoordinates(pointer1.set(stagePointer1));actor.stageToLocalCoordinates(pointer2.set(stagePointer2));ActorGestureListener.this.pinch(event, initialPointer1, initialPointer2, pointer1, pointer2);return true;}
private void stageToLocalAmount(Vector2 amount) {actor.stageToLocalCoordinates(amount);amount.sub(actor.stageToLocalCoordinates(tmpCoords2.set(0, 0)));}
public boolean handle(Event e) {if (!(e instanceof InputEvent))return false;InputEvent event = (InputEvent) e;switch(event.getType()) {case touchDown:actor = event.getListenerActor();touchDownTarget = event.getTarget();detector.touchDown(event.getStageX(), event.getStageY(), event.getPointer(), event.getButton());actor.stageToLocalCoordinates(tmpCoords.set(event.getStageX(), event.getStageY()));touchDown(event, tmpCoords.x, tmpCoords.y, event.getPointer(), event.getButton());return true;case touchUp:if (event.isTouchFocusCancel())return false;this.event = event;actor = event.getListenerActor();detector.touchUp(event.getStageX(), event.getStageY(), event.getPointer(), event.getButton());actor.stageToLocalCoordinates(tmpCoords.set(event.getStageX(), event.getStageY()));touchUp(event, tmpCoords.x, tmpCoords.y, event.getPointer(), event.getButton());return true;case touchDragged:this.event = event;actor = event.getListenerActor();detector.touchDragged(event.getStageX(), event.getStageY(), event.getPointer());return true;}return false;}
public void touchDown(InputEvent event, float x, float y, int pointer, int button) {}
public void touchUp(InputEvent event, float x, float y, int pointer, int button) {}
public void tap(InputEvent event, float x, float y, int count, int button) {}
public boolean longPress(Actor actor, float x, float y) {return false;}
public void fling(InputEvent event, float velocityX, float velocityY, int button) {}
public void pan(InputEvent event, float x, float y, float deltaX, float deltaY) {}
public void zoom(InputEvent event, float initialDistance, float distance) {}
public void pinch(InputEvent event, Vector2 initialPointer1, Vector2 initialPointer2, Vector2 pointer1, Vector2 pointer2) {}
public GestureDetector getGestureDetector() {return detector;}
public Actor getTouchDownTarget() {return touchDownTarget;}public void apply() {apply(false);}
public void apply(boolean centerCamera) {Gdx.gl.glViewport(screenX, screenY, screenWidth, screenHeight);camera.viewportWidth = worldWidth;camera.viewportHeight = worldHeight;if (centerCamera)camera.position.set(worldWidth / 2, worldHeight / 2, 0);camera.update();}
public final void update(int screenWidth, int screenHeight) {update(screenWidth, screenHeight, false);}
public void update(int screenWidth, int screenHeight, boolean centerCamera) {apply(centerCamera);}
public Vector2 unproject(Vector2 screenCoords) {tmp.set(screenCoords.x, screenCoords.y, 1);camera.unproject(tmp, screenX, screenY, screenWidth, screenHeight);screenCoords.set(tmp.x, tmp.y);return screenCoords;}
public Vector2 project(Vector2 worldCoords) {tmp.set(worldCoords.x, worldCoords.y, 1);camera.project(tmp, screenX, screenY, screenWidth, screenHeight);worldCoords.set(tmp.x, tmp.y);return worldCoords;}
public Vector3 unproject(Vector3 screenCoords) {camera.unproject(screenCoords, screenX, screenY, screenWidth, screenHeight);return screenCoords;}
public Vector3 project(Vector3 worldCoords) {camera.project(worldCoords, screenX, screenY, screenWidth, screenHeight);return worldCoords;}
public Ray getPickRay(float screenX, float screenY) {return camera.getPickRay(screenX, screenY, this.screenX, this.screenY, screenWidth, screenHeight);}
public void calculateScissors(Matrix4 batchTransform, Rectangle area, Rectangle scissor) {ScissorStack.calculateScissors(camera, screenX, screenY, screenWidth, screenHeight, batchTransform, area, scissor);}
public Vector2 toScreenCoordinates(Vector2 worldCoords, Matrix4 transformMatrix) {tmp.set(worldCoords.x, worldCoords.y, 0);tmp.mul(transformMatrix);camera.project(tmp);tmp.y = Gdx.graphics.getHeight() - tmp.y;worldCoords.x = tmp.x;worldCoords.y = tmp.y;return worldCoords;}
public Camera getCamera() {return camera;}
public void setCamera(Camera camera) {this.camera = camera;}
public float getWorldWidth() {return worldWidth;}
public void setWorldWidth(float worldWidth) {this.worldWidth = worldWidth;}
public float getWorldHeight() {return worldHeight;}
public void setWorldHeight(float worldHeight) {this.worldHeight = worldHeight;}
public void setWorldSize(float worldWidth, float worldHeight) {this.worldWidth = worldWidth;this.worldHeight = worldHeight;}
public int getScreenX() {return screenX;}
public void setScreenX(int screenX) {this.screenX = screenX;}
public int getScreenY() {return screenY;}
public void setScreenY(int screenY) {this.screenY = screenY;}
public int getScreenWidth() {return screenWidth;}
public void setScreenWidth(int screenWidth) {this.screenWidth = screenWidth;}
public int getScreenHeight() {return screenHeight;}
public void setScreenHeight(int screenHeight) {this.screenHeight = screenHeight;}
public void setScreenPosition(int screenX, int screenY) {this.screenX = screenX;this.screenY = screenY;}
public void setScreenSize(int screenWidth, int screenHeight) {this.screenWidth = screenWidth;this.screenHeight = screenHeight;}
public void setScreenBounds(int screenX, int screenY, int screenWidth, int screenHeight) {this.screenX = screenX;this.screenY = screenY;this.screenWidth = screenWidth;this.screenHeight = screenHeight;}
public int getLeftGutterWidth() {return screenX;}
public int getRightGutterX() {return screenX + screenWidth;}
public int getRightGutterWidth() {return Gdx.graphics.getWidth() - (screenX + screenWidth);}
public int getBottomGutterHeight() {return screenY;}
public int getTopGutterY() {return screenY + screenHeight;}
public int getTopGutterHeight() {return Gdx.graphics.getHeight() - (screenY + screenHeight);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(CollisionJNI.btBoxBoxDetector_SWIGUpcast(swigCPtr = cPtr), cMemoryOwn);}
public static long getCPtr(btBoxBoxDetector obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btBoxBoxDetector(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setBox1(btBoxShape value) {CollisionJNI.btBoxBoxDetector_box1_set(swigCPtr, this, btBoxShape.getCPtr(value), value);}
public btBoxShape getBox1() {long cPtr = CollisionJNI.btBoxBoxDetector_box1_get(swigCPtr, this);return (cPtr == 0) ? null : new btBoxShape(cPtr, false);}
public void setBox2(btBoxShape value) {CollisionJNI.btBoxBoxDetector_box2_set(swigCPtr, this, btBoxShape.getCPtr(value), value);}
public btBoxShape getBox2() {long cPtr = CollisionJNI.btBoxBoxDetector_box2_get(swigCPtr, this);return (cPtr == 0) ? null : new btBoxShape(cPtr, false);}
public void getClosestPoints(btDiscreteCollisionDetectorInterface.ClosestPointInput input, btDiscreteCollisionDetectorInterface.Result output, btIDebugDraw debugDraw, boolean swapResults) {CollisionJNI.btBoxBoxDetector_getClosestPoints__SWIG_0(swigCPtr, this, btDiscreteCollisionDetectorInterface.ClosestPointInput.getCPtr(input), input, btDiscreteCollisionDetectorInterface.Result.getCPtr(output), output, btIDebugDraw.getCPtr(debugDraw), debugDraw, swapResults);}
public void getClosestPoints(btDiscreteCollisionDetectorInterface.ClosestPointInput input, btDiscreteCollisionDetectorInterface.Result output, btIDebugDraw debugDraw) {CollisionJNI.btBoxBoxDetector_getClosestPoints__SWIG_1(swigCPtr, this, btDiscreteCollisionDetectorInterface.ClosestPointInput.getCPtr(input), input, btDiscreteCollisionDetectorInterface.Result.getCPtr(output), output, btIDebugDraw.getCPtr(debugDraw), debugDraw);}public void invalidate() {super.invalidate();sizeInvalid = true;}
private void computeSize() {sizeInvalid = false;SnapshotArray<Actor> children = getChildren();int n = children.size;prefWidth = padLeft + padRight + spacing * (n - 1);prefHeight = 0;for (int i = 0; i < n; i++) {Actor child = children.get(i);if (child instanceof Layout) {Layout layout = (Layout) child;prefWidth += layout.getPrefWidth();prefHeight = Math.max(prefHeight, layout.getPrefHeight());} else {prefWidth += child.getWidth();prefHeight = Math.max(prefHeight, child.getHeight());}}prefHeight += padTop + padBottom;if (round) {prefWidth = Math.round(prefWidth);prefHeight = Math.round(prefHeight);}}
public void layout() {float spacing = this.spacing, padBottom = this.padBottom;int align = this.align;boolean reverse = this.reverse, round = this.round;float groupHeight = getHeight() - padTop - padBottom;float x = !reverse ? padLeft : getWidth() - padRight + spacing;SnapshotArray<Actor> children = getChildren();for (int i = 0, n = children.size; i < n; i++) {Actor child = children.get(i);float width, height;Layout layout = null;if (child instanceof Layout) {layout = (Layout) child;if (fill > 0)height = groupHeight * fill;elseheight = Math.min(layout.getPrefHeight(), groupHeight);height = Math.max(height, layout.getMinHeight());float maxHeight = layout.getMaxHeight();if (maxHeight > 0 && height > maxHeight)height = maxHeight;width = layout.getPrefWidth();} else {width = child.getWidth();height = child.getHeight();if (fill > 0)height *= fill;}float y = padBottom;if ((align & Align.top) != 0)y += groupHeight - height;else if (// center(align & Align.bottom) == 0)y += (groupHeight - height) / 2;if (reverse)x -= (width + spacing);if (round)child.setBounds(Math.round(x), Math.round(y), Math.round(width), Math.round(height));elsechild.setBounds(x, y, width, height);if (!reverse)x += (width + spacing);if (layout != null)layout.validate();}}
public float getPrefWidth() {if (sizeInvalid)computeSize();return prefWidth;}
public float getPrefHeight() {if (sizeInvalid)computeSize();return prefHeight;}
public void setRound(boolean round) {this.round = round;}
public HorizontalGroup reverse() {reverse(true);return this;}
public HorizontalGroup reverse(boolean reverse) {this.reverse = reverse;return this;}
public boolean getReverse() {return reverse;}
public HorizontalGroup space(float spacing) {this.spacing = spacing;return this;}
public float getSpace() {return spacing;}
public HorizontalGroup pad(float pad) {padTop = pad;padLeft = pad;padBottom = pad;padRight = pad;return this;}
public HorizontalGroup pad(float top, float left, float bottom, float right) {padTop = top;padLeft = left;padBottom = bottom;padRight = right;return this;}
public HorizontalGroup padTop(float padTop) {this.padTop = padTop;return this;}
public HorizontalGroup padLeft(float padLeft) {this.padLeft = padLeft;return this;}
public HorizontalGroup padBottom(float padBottom) {this.padBottom = padBottom;return this;}
public HorizontalGroup padRight(float padRight) {this.padRight = padRight;return this;}
public float getPadTop() {return padTop;}
public float getPadLeft() {return padLeft;}
public float getPadBottom() {return padBottom;}
public float getPadRight() {return padRight;}
public HorizontalGroup align(int align) {this.align = align;return this;}
public HorizontalGroup center() {align = Align.center;return this;}
public HorizontalGroup top() {align |= Align.top;align &= ~Align.bottom;return this;}
public HorizontalGroup bottom() {align |= Align.bottom;align &= ~Align.top;return this;}
public int getAlign() {return align;}
public HorizontalGroup fill() {fill = 1f;return this;}
public HorizontalGroup fill(float fill) {this.fill = fill;return this;}
public float getFill() {return fill;}public float addSingleResult(btManifoldPoint cp, btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, btCollisionObjectWrapper colObj1Wrap, int partId1, int index1) {hit = true;other = colObj0Wrap.getCollisionObject() == movingBox.body ? colObj1Wrap.getCollisionObject() : colObj0Wrap.getCollisionObject();return 0f;}
public BulletWorld createWorld() {btDefaultCollisionConfiguration collisionConfig = new btDefaultCollisionConfiguration();btCollisionDispatcher dispatcher = new btCollisionDispatcher(collisionConfig);btDbvtBroadphase broadphase = new btDbvtBroadphase();btCollisionWorld collisionWorld = new btCollisionWorld(dispatcher, broadphase, collisionConfig);return new BulletWorld(collisionConfig, dispatcher, broadphase, null, collisionWorld);}
public void create() {super.create();instructions = "Long press to toggle debug mode\nSwipe for next test\nCtrl+drag to rotate\nScroll to zoom";contactCB = new TestContactResultCallback();Model groundModel = world.getConstructor("ground").model;Model boxModel = world.getConstructor("box").model;world.addConstructor("collisionGround", new BulletConstructor(groundModel));world.addConstructor("collisionBox", new BulletConstructor(boxModel));world.add("collisionGround", 0f, 0f, 0f).setColor(0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 0.25f + 0.5f * (float) Math.random(), 1f);world.add("collisionBox", 0f, 1f, 5f).setColor(0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 1f);world.add("collisionBox", 0f, 1f, -5f).setColor(0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 1f);world.add("collisionBox", 5f, 1f, 0f).setColor(0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 1f);world.add("collisionBox", -5f, 1f, 0f).setColor(0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 1f);movingBox = world.add("collisionBox", -5f, 1f, 0f);normalColor.set(0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 0.5f + 0.5f * (float) Math.random(), 1f);}
public void render() {movingBox.transform.val[Matrix4.M03] = movingBox.transform.val[Matrix4.M13] = movingBox.transform.val[Matrix4.M23] = 0f;movingBox.transform.rotate(Vector3.Y, Gdx.graphics.getDeltaTime() * 45f);movingBox.transform.translate(-5f, 1f, 0f);movingBox.body.setWorldTransform(movingBox.transform);super.render();}
public void update() {super.update();// Not using dynamics, so update the collision world manuallyif (world.performanceCounter != null)world.performanceCounter.start();world.collisionWorld.performDiscreteCollisionDetection();if (world.performanceCounter != null)world.performanceCounter.stop();}
protected void renderWorld() {hit = false;other = null;world.collisionWorld.contactTest(movingBox.body, contactCB);movingBox.setColor(hit ? Color.RED : normalColor);BulletEntity e = null;if (other != null && other.userData != null && other.userData instanceof BulletEntity) {e = (BulletEntity) (other.userData);tmpColor.set(e.getColor());e.setColor(Color.RED);}super.renderWorld();if (e != null)e.setColor(tmpColor);}
public void dispose() {super.dispose();movingBox = null;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btSparseSdf3 obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;SoftbodyJNI.delete_btSparseSdf3(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(IntFrac obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;SoftbodyJNI.delete_btSparseSdf3_IntFrac(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setB(int value) {SoftbodyJNI.btSparseSdf3_IntFrac_b_set(swigCPtr, this, value);}
public int getB() {return SoftbodyJNI.btSparseSdf3_IntFrac_b_get(swigCPtr, this);}
public void setI(int value) {SoftbodyJNI.btSparseSdf3_IntFrac_i_set(swigCPtr, this, value);}
public int getI() {return SoftbodyJNI.btSparseSdf3_IntFrac_i_get(swigCPtr, this);}
public void setF(float value) {SoftbodyJNI.btSparseSdf3_IntFrac_f_set(swigCPtr, this, value);}
public float getF() {return SoftbodyJNI.btSparseSdf3_IntFrac_f_get(swigCPtr, this);}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(Cell obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;SoftbodyJNI.delete_btSparseSdf3_Cell(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setD(SWIGTYPE_p_a_3_1__a_3_1__float value) {SoftbodyJNI.btSparseSdf3_Cell_d_set(swigCPtr, this, SWIGTYPE_p_a_3_1__a_3_1__float.getCPtr(value));}
public SWIGTYPE_p_a_3_1__a_3_1__float getD() {long cPtr = SoftbodyJNI.btSparseSdf3_Cell_d_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_a_3_1__a_3_1__float(cPtr, false);}
public void setC(int[] value) {SoftbodyJNI.btSparseSdf3_Cell_c_set(swigCPtr, this, value);}
public int[] getC() {return SoftbodyJNI.btSparseSdf3_Cell_c_get(swigCPtr, this);}
public void setPuid(int value) {SoftbodyJNI.btSparseSdf3_Cell_puid_set(swigCPtr, this, value);}
public int getPuid() {return SoftbodyJNI.btSparseSdf3_Cell_puid_get(swigCPtr, this);}
public void setHash(long value) {SoftbodyJNI.btSparseSdf3_Cell_hash_set(swigCPtr, this, value);}
public long getHash() {return SoftbodyJNI.btSparseSdf3_Cell_hash_get(swigCPtr, this);}
public void setPclient(btCollisionShape value) {SoftbodyJNI.btSparseSdf3_Cell_pclient_set(swigCPtr, this, btCollisionShape.getCPtr(value), value);}
public btCollisionShape getPclient() {long cPtr = SoftbodyJNI.btSparseSdf3_Cell_pclient_get(swigCPtr, this);return (cPtr == 0) ? null : btCollisionShape.newDerivedObject(cPtr, false);}
public void setNext(btSparseSdf3.Cell value) {SoftbodyJNI.btSparseSdf3_Cell_next_set(swigCPtr, this, btSparseSdf3.Cell.getCPtr(value), value);}
public btSparseSdf3.Cell getNext() {long cPtr = SoftbodyJNI.btSparseSdf3_Cell_next_get(swigCPtr, this);return (cPtr == 0) ? null : new btSparseSdf3.Cell(cPtr, false);}
public void setCells(SWIGTYPE_p_btAlignedObjectArrayT_btSparseSdfT_3_t__Cell_p_t value) {SoftbodyJNI.btSparseSdf3_cells_set(swigCPtr, this, SWIGTYPE_p_btAlignedObjectArrayT_btSparseSdfT_3_t__Cell_p_t.getCPtr(value));}
public SWIGTYPE_p_btAlignedObjectArrayT_btSparseSdfT_3_t__Cell_p_t getCells() {long cPtr = SoftbodyJNI.btSparseSdf3_cells_get(swigCPtr, this);return (cPtr == 0) ? null : new SWIGTYPE_p_btAlignedObjectArrayT_btSparseSdfT_3_t__Cell_p_t(cPtr, false);}
public void setVoxelsz(float value) {SoftbodyJNI.btSparseSdf3_voxelsz_set(swigCPtr, this, value);}
public float getVoxelsz() {return SoftbodyJNI.btSparseSdf3_voxelsz_get(swigCPtr, this);}
public void setPuid(int value) {SoftbodyJNI.btSparseSdf3_puid_set(swigCPtr, this, value);}
public int getPuid() {return SoftbodyJNI.btSparseSdf3_puid_get(swigCPtr, this);}
public void setNcells(int value) {SoftbodyJNI.btSparseSdf3_ncells_set(swigCPtr, this, value);}
public int getNcells() {return SoftbodyJNI.btSparseSdf3_ncells_get(swigCPtr, this);}
public void setClampCells(int value) {SoftbodyJNI.btSparseSdf3_clampCells_set(swigCPtr, this, value);}
public int getClampCells() {return SoftbodyJNI.btSparseSdf3_clampCells_get(swigCPtr, this);}
public void setNprobes(int value) {SoftbodyJNI.btSparseSdf3_nprobes_set(swigCPtr, this, value);}
public int getNprobes() {return SoftbodyJNI.btSparseSdf3_nprobes_get(swigCPtr, this);}
public void setNqueries(int value) {SoftbodyJNI.btSparseSdf3_nqueries_set(swigCPtr, this, value);}
public int getNqueries() {return SoftbodyJNI.btSparseSdf3_nqueries_get(swigCPtr, this);}
public void Initialize(int hashsize, int clampCells) {SoftbodyJNI.btSparseSdf3_Initialize__SWIG_0(swigCPtr, this, hashsize, clampCells);}
public void Initialize(int hashsize) {SoftbodyJNI.btSparseSdf3_Initialize__SWIG_1(swigCPtr, this, hashsize);}
public void Initialize() {SoftbodyJNI.btSparseSdf3_Initialize__SWIG_2(swigCPtr, this);}
public void Reset() {SoftbodyJNI.btSparseSdf3_Reset(swigCPtr, this);}
public void GarbageCollect(int lifetime) {SoftbodyJNI.btSparseSdf3_GarbageCollect__SWIG_0(swigCPtr, this, lifetime);}
public void GarbageCollect() {SoftbodyJNI.btSparseSdf3_GarbageCollect__SWIG_1(swigCPtr, this);}
public int RemoveReferences(btCollisionShape pcs) {return SoftbodyJNI.btSparseSdf3_RemoveReferences(swigCPtr, this, btCollisionShape.getCPtr(pcs), pcs);}
public float Evaluate(Vector3 x, btCollisionShape shape, Vector3 normal, float margin) {return SoftbodyJNI.btSparseSdf3_Evaluate(swigCPtr, this, x, btCollisionShape.getCPtr(shape), shape, normal, margin);}
public void BuildCell(btSparseSdf3.Cell c) {SoftbodyJNI.btSparseSdf3_BuildCell(swigCPtr, this, btSparseSdf3.Cell.getCPtr(c), c);}
public static float DistanceToShape(Vector3 x, btCollisionShape shape) {return SoftbodyJNI.btSparseSdf3_DistanceToShape(x, btCollisionShape.getCPtr(shape), shape);}
public static btSparseSdf3.IntFrac Decompose(float x) {return new btSparseSdf3.IntFrac(SoftbodyJNI.btSparseSdf3_Decompose(x), true);}
public static float Lerp(float a, float b, float t) {return SoftbodyJNI.btSparseSdf3_Lerp(a, b, t);}
public static long Hash(int x, int y, int z, btCollisionShape shape) {return SoftbodyJNI.btSparseSdf3_Hash(x, y, z, btCollisionShape.getCPtr(shape), shape);}public void draw(Batch batch, float x, float y, float width, float height) {float batchColor = batch.getPackedColor();batch.setColor(batch.getColor().mul(color));TextureRegion region = getRegion();float regionWidth = region.getRegionWidth(), regionHeight = region.getRegionHeight();int fullX = (int) (width / regionWidth), fullY = (int) (height / regionHeight);float remainingX = width - regionWidth * fullX, remainingY = height - regionHeight * fullY;float startX = x, startY = y;float endX = x + width - remainingX, endY = y + height - remainingY;for (int i = 0; i < fullX; i++) {y = startY;for (int ii = 0; ii < fullY; ii++) {batch.draw(region, x, y, regionWidth, regionHeight);y += regionHeight;}x += regionWidth;}Texture texture = region.getTexture();float u = region.getU();float v2 = region.getV2();if (remainingX > 0) {// Right edge.float u2 = u + remainingX / texture.getWidth();float v = region.getV();y = startY;for (int ii = 0; ii < fullY; ii++) {batch.draw(texture, x, y, remainingX, regionHeight, u, v2, u2, v);y += regionHeight;}// Upper right corner.if (remainingY > 0) {v = v2 - remainingY / texture.getHeight();batch.draw(texture, x, y, remainingX, remainingY, u, v2, u2, v);}}if (remainingY > 0) {// Top edge.float u2 = region.getU2();float v = v2 - remainingY / texture.getHeight();x = startX;for (int i = 0; i < fullX; i++) {batch.draw(texture, x, y, regionWidth, remainingY, u, v2, u2, v);x += regionWidth;}}batch.setColor(batchColor);}
public Color getColor() {return color;}
public TiledDrawable tint(Color tint) {TiledDrawable drawable = new TiledDrawable(this);drawable.color.set(tint);drawable.setLeftWidth(getLeftWidth());drawable.setRightWidth(getRightWidth());drawable.setTopHeight(getTopHeight());drawable.setBottomHeight(getBottomHeight());return drawable;}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btQuantizedBvhFloatData obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btQuantizedBvhFloatData(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setBvhAabbMin(btVector3FloatData value) {CollisionJNI.btQuantizedBvhFloatData_bvhAabbMin_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getBvhAabbMin() {long cPtr = CollisionJNI.btQuantizedBvhFloatData_bvhAabbMin_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setBvhAabbMax(btVector3FloatData value) {CollisionJNI.btQuantizedBvhFloatData_bvhAabbMax_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getBvhAabbMax() {long cPtr = CollisionJNI.btQuantizedBvhFloatData_bvhAabbMax_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setBvhQuantization(btVector3FloatData value) {CollisionJNI.btQuantizedBvhFloatData_bvhQuantization_set(swigCPtr, this, btVector3FloatData.getCPtr(value), value);}
public btVector3FloatData getBvhQuantization() {long cPtr = CollisionJNI.btQuantizedBvhFloatData_bvhQuantization_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3FloatData(cPtr, false);}
public void setCurNodeIndex(int value) {CollisionJNI.btQuantizedBvhFloatData_curNodeIndex_set(swigCPtr, this, value);}
public int getCurNodeIndex() {return CollisionJNI.btQuantizedBvhFloatData_curNodeIndex_get(swigCPtr, this);}
public void setUseQuantization(int value) {CollisionJNI.btQuantizedBvhFloatData_useQuantization_set(swigCPtr, this, value);}
public int getUseQuantization() {return CollisionJNI.btQuantizedBvhFloatData_useQuantization_get(swigCPtr, this);}
public void setNumContiguousLeafNodes(int value) {CollisionJNI.btQuantizedBvhFloatData_numContiguousLeafNodes_set(swigCPtr, this, value);}
public int getNumContiguousLeafNodes() {return CollisionJNI.btQuantizedBvhFloatData_numContiguousLeafNodes_get(swigCPtr, this);}
public void setNumQuantizedContiguousNodes(int value) {CollisionJNI.btQuantizedBvhFloatData_numQuantizedContiguousNodes_set(swigCPtr, this, value);}
public int getNumQuantizedContiguousNodes() {return CollisionJNI.btQuantizedBvhFloatData_numQuantizedContiguousNodes_get(swigCPtr, this);}
public void setContiguousNodesPtr(btOptimizedBvhNodeFloatData value) {CollisionJNI.btQuantizedBvhFloatData_contiguousNodesPtr_set(swigCPtr, this, btOptimizedBvhNodeFloatData.getCPtr(value), value);}
public btOptimizedBvhNodeFloatData getContiguousNodesPtr() {long cPtr = CollisionJNI.btQuantizedBvhFloatData_contiguousNodesPtr_get(swigCPtr, this);return (cPtr == 0) ? null : new btOptimizedBvhNodeFloatData(cPtr, false);}
public void setQuantizedContiguousNodesPtr(btQuantizedBvhNodeData value) {CollisionJNI.btQuantizedBvhFloatData_quantizedContiguousNodesPtr_set(swigCPtr, this, btQuantizedBvhNodeData.getCPtr(value), value);}
public btQuantizedBvhNodeData getQuantizedContiguousNodesPtr() {long cPtr = CollisionJNI.btQuantizedBvhFloatData_quantizedContiguousNodesPtr_get(swigCPtr, this);return (cPtr == 0) ? null : new btQuantizedBvhNodeData(cPtr, false);}
public void setSubTreeInfoPtr(btBvhSubtreeInfoData value) {CollisionJNI.btQuantizedBvhFloatData_subTreeInfoPtr_set(swigCPtr, this, btBvhSubtreeInfoData.getCPtr(value), value);}
public btBvhSubtreeInfoData getSubTreeInfoPtr() {long cPtr = CollisionJNI.btQuantizedBvhFloatData_subTreeInfoPtr_get(swigCPtr, this);return (cPtr == 0) ? null : new btBvhSubtreeInfoData(cPtr, false);}
public void setTraversalMode(int value) {CollisionJNI.btQuantizedBvhFloatData_traversalMode_set(swigCPtr, this, value);}
public int getTraversalMode() {return CollisionJNI.btQuantizedBvhFloatData_traversalMode_get(swigCPtr, this);}
public void setNumSubtreeHeaders(int value) {CollisionJNI.btQuantizedBvhFloatData_numSubtreeHeaders_set(swigCPtr, this, value);}
public int getNumSubtreeHeaders() {return CollisionJNI.btQuantizedBvhFloatData_numSubtreeHeaders_get(swigCPtr, this);}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btCollisionObject obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;CollisionJNI.delete_btCollisionObject(swigCPtr);}swigCPtr = 0;}super.delete();}
public static btCollisionObject getInstance(final long swigCPtr) {return swigCPtr == 0 ? null : instances.get(swigCPtr);}
public static btCollisionObject getInstance(final long swigCPtr, boolean owner) {if (swigCPtr == 0)return null;btCollisionObject result = instances.get(swigCPtr);if (result == null)result = new btCollisionObject(swigCPtr, owner);return result;}
public static void addInstance(final btCollisionObject obj) {instances.put(getCPtr(obj), obj);}
public static void removeInstance(final btCollisionObject obj) {instances.remove(getCPtr(obj));}
protected void construct() {super.construct();gdxBridge = new GdxCollisionObjectBridge();internalSetGdxBridge(gdxBridge);addInstance(this);}
public void dispose() {if (swigCPtr != 0)removeInstance(this);if (gdxBridge != null)gdxBridge.dispose();gdxBridge = null;if (collisionShape != null)collisionShape.release();collisionShape = null;super.dispose();}
public int getUserValue() {return userValue;}
public void setUserValue(int value) {gdxBridge.setUserValue(userValue = value);}
public int getContactCallbackFlag() {return contactCallbackFlag;}
public void setContactCallbackFlag(int flag) {gdxBridge.setContactCallbackFlag(contactCallbackFlag = flag);}
public int getContactCallbackFilter() {return contactCallbackFilter;}
public void setContactCallbackFilter(int filter) {gdxBridge.setContactCallbackFilter(contactCallbackFilter = filter);}
public void setCollisionShape(btCollisionShape shape) {refCollisionShape(shape);internalSetCollisionShape(shape);}
protected void refCollisionShape(btCollisionShape shape) {if (collisionShape == shape)return;if (collisionShape != null)collisionShape.release();collisionShape = shape;collisionShape.obtain();}
public btCollisionShape getCollisionShape() {return collisionShape;}
public boolean mergesSimulationIslands() {return CollisionJNI.btCollisionObject_mergesSimulationIslands(swigCPtr, this);}
public Vector3 getAnisotropicFriction() {return CollisionJNI.btCollisionObject_getAnisotropicFriction__SWIG_0(swigCPtr, this);}
public void setAnisotropicFriction(Vector3 anisotropicFriction, int frictionMode) {CollisionJNI.btCollisionObject_setAnisotropicFriction__SWIG_0(swigCPtr, this, anisotropicFriction, frictionMode);}
public void setAnisotropicFriction(Vector3 anisotropicFriction) {CollisionJNI.btCollisionObject_setAnisotropicFriction__SWIG_1(swigCPtr, this, anisotropicFriction);}
public boolean hasAnisotropicFriction(int frictionMode) {return CollisionJNI.btCollisionObject_hasAnisotropicFriction__SWIG_0(swigCPtr, this, frictionMode);}
public boolean hasAnisotropicFriction() {return CollisionJNI.btCollisionObject_hasAnisotropicFriction__SWIG_1(swigCPtr, this);}
public void setContactProcessingThreshold(float contactProcessingThreshold) {CollisionJNI.btCollisionObject_setContactProcessingThreshold(swigCPtr, this, contactProcessingThreshold);}
public float getContactProcessingThreshold() {return CollisionJNI.btCollisionObject_getContactProcessingThreshold(swigCPtr, this);}
public boolean isStaticObject() {return CollisionJNI.btCollisionObject_isStaticObject(swigCPtr, this);}
public boolean isKinematicObject() {return CollisionJNI.btCollisionObject_isKinematicObject(swigCPtr, this);}
public boolean isStaticOrKinematicObject() {return CollisionJNI.btCollisionObject_isStaticOrKinematicObject(swigCPtr, this);}
public boolean hasContactResponse() {return CollisionJNI.btCollisionObject_hasContactResponse(swigCPtr, this);}
private void internalSetCollisionShape(btCollisionShape collisionShape) {CollisionJNI.btCollisionObject_internalSetCollisionShape(swigCPtr, this, btCollisionShape.getCPtr(collisionShape), collisionShape);}
private btCollisionShape internalGetCollisionShape() {long cPtr = CollisionJNI.btCollisionObject_internalGetCollisionShape__SWIG_0(swigCPtr, this);return (cPtr == 0) ? null : btCollisionShape.newDerivedObject(cPtr, false);}
public void setIgnoreCollisionCheck(btCollisionObject co, boolean ignoreCollisionCheck) {CollisionJNI.btCollisionObject_setIgnoreCollisionCheck(swigCPtr, this, btCollisionObject.getCPtr(co), co, ignoreCollisionCheck);}
public boolean checkCollideWithOverride(btCollisionObject co) {return CollisionJNI.btCollisionObject_checkCollideWithOverride(swigCPtr, this, btCollisionObject.getCPtr(co), co);}
public long internalGetExtensionPointer() {return CollisionJNI.btCollisionObject_internalGetExtensionPointer(swigCPtr, this);}
public void internalSetExtensionPointer(long pointer) {CollisionJNI.btCollisionObject_internalSetExtensionPointer(swigCPtr, this, pointer);}
public int getActivationState() {return CollisionJNI.btCollisionObject_getActivationState(swigCPtr, this);}
public void setActivationState(int newState) {CollisionJNI.btCollisionObject_setActivationState(swigCPtr, this, newState);}
public void setDeactivationTime(float time) {CollisionJNI.btCollisionObject_setDeactivationTime(swigCPtr, this, time);}
public float getDeactivationTime() {return CollisionJNI.btCollisionObject_getDeactivationTime(swigCPtr, this);}
public void forceActivationState(int newState) {CollisionJNI.btCollisionObject_forceActivationState(swigCPtr, this, newState);}
public void activate(boolean forceActivation) {CollisionJNI.btCollisionObject_activate__SWIG_0(swigCPtr, this, forceActivation);}
public void activate() {CollisionJNI.btCollisionObject_activate__SWIG_1(swigCPtr, this);}
public boolean isActive() {return CollisionJNI.btCollisionObject_isActive(swigCPtr, this);}
public void setRestitution(float rest) {CollisionJNI.btCollisionObject_setRestitution(swigCPtr, this, rest);}
public float getRestitution() {return CollisionJNI.btCollisionObject_getRestitution(swigCPtr, this);}
public void setFriction(float frict) {CollisionJNI.btCollisionObject_setFriction(swigCPtr, this, frict);}
public float getFriction() {return CollisionJNI.btCollisionObject_getFriction(swigCPtr, this);}
public void setRollingFriction(float frict) {CollisionJNI.btCollisionObject_setRollingFriction(swigCPtr, this, frict);}
public float getRollingFriction() {return CollisionJNI.btCollisionObject_getRollingFriction(swigCPtr, this);}
public int getInternalType() {return CollisionJNI.btCollisionObject_getInternalType(swigCPtr, this);}
public Matrix4 getWorldTransform() {return CollisionJNI.btCollisionObject_getWorldTransform__SWIG_0(swigCPtr, this);}
public void setWorldTransform(Matrix4 worldTrans) {CollisionJNI.btCollisionObject_setWorldTransform(swigCPtr, this, worldTrans);}
public btBroadphaseProxy getBroadphaseHandle() {return btBroadphaseProxy.internalTemp(CollisionJNI.btCollisionObject_getBroadphaseHandle__SWIG_0(swigCPtr, this), false);}
public void setBroadphaseHandle(btBroadphaseProxy handle) {CollisionJNI.btCollisionObject_setBroadphaseHandle(swigCPtr, this, btBroadphaseProxy.getCPtr(handle), handle);}
public Matrix4 getInterpolationWorldTransform() {return CollisionJNI.btCollisionObject_getInterpolationWorldTransform__SWIG_0(swigCPtr, this);}
public void setInterpolationWorldTransform(Matrix4 trans) {CollisionJNI.btCollisionObject_setInterpolationWorldTransform(swigCPtr, this, trans);}
public void setInterpolationLinearVelocity(Vector3 linvel) {CollisionJNI.btCollisionObject_setInterpolationLinearVelocity(swigCPtr, this, linvel);}
public void setInterpolationAngularVelocity(Vector3 angvel) {CollisionJNI.btCollisionObject_setInterpolationAngularVelocity(swigCPtr, this, angvel);}
public Vector3 getInterpolationLinearVelocity() {return CollisionJNI.btCollisionObject_getInterpolationLinearVelocity__SWIG_0(swigCPtr, this);}
public Vector3 getInterpolationAngularVelocity() {return CollisionJNI.btCollisionObject_getInterpolationAngularVelocity__SWIG_0(swigCPtr, this);}
public int getIslandTag() {return CollisionJNI.btCollisionObject_getIslandTag(swigCPtr, this);}
public void setIslandTag(int tag) {CollisionJNI.btCollisionObject_setIslandTag(swigCPtr, this, tag);}
public int getCompanionId() {return CollisionJNI.btCollisionObject_getCompanionId(swigCPtr, this);}
public void setCompanionId(int id) {CollisionJNI.btCollisionObject_setCompanionId(swigCPtr, this, id);}
public float getHitFraction() {return CollisionJNI.btCollisionObject_getHitFraction(swigCPtr, this);}
public void setHitFraction(float hitFraction) {CollisionJNI.btCollisionObject_setHitFraction(swigCPtr, this, hitFraction);}
public int getCollisionFlags() {return CollisionJNI.btCollisionObject_getCollisionFlags(swigCPtr, this);}
public void setCollisionFlags(int flags) {CollisionJNI.btCollisionObject_setCollisionFlags(swigCPtr, this, flags);}
public float getCcdSweptSphereRadius() {return CollisionJNI.btCollisionObject_getCcdSweptSphereRadius(swigCPtr, this);}
public void setCcdSweptSphereRadius(float radius) {CollisionJNI.btCollisionObject_setCcdSweptSphereRadius(swigCPtr, this, radius);}
public float getCcdMotionThreshold() {return CollisionJNI.btCollisionObject_getCcdMotionThreshold(swigCPtr, this);}
public float getCcdSquareMotionThreshold() {return CollisionJNI.btCollisionObject_getCcdSquareMotionThreshold(swigCPtr, this);}
public void setCcdMotionThreshold(float ccdMotionThreshold) {CollisionJNI.btCollisionObject_setCcdMotionThreshold(swigCPtr, this, ccdMotionThreshold);}
public long getUserPointer() {return CollisionJNI.btCollisionObject_getUserPointer(swigCPtr, this);}
public int getUserIndex() {return CollisionJNI.btCollisionObject_getUserIndex(swigCPtr, this);}
public void setUserPointer(long userPointer) {CollisionJNI.btCollisionObject_setUserPointer(swigCPtr, this, userPointer);}
public void setUserIndex(int index) {CollisionJNI.btCollisionObject_setUserIndex(swigCPtr, this, index);}
public int getUpdateRevisionInternal() {return CollisionJNI.btCollisionObject_getUpdateRevisionInternal(swigCPtr, this);}
public boolean checkCollideWith(btCollisionObject co) {return CollisionJNI.btCollisionObject_checkCollideWith(swigCPtr, this, btCollisionObject.getCPtr(co), co);}
public int calculateSerializeBufferSize() {return CollisionJNI.btCollisionObject_calculateSerializeBufferSize(swigCPtr, this);}
public String serialize(long dataBuffer, SWIGTYPE_p_btSerializer serializer) {return CollisionJNI.btCollisionObject_serialize(swigCPtr, this, dataBuffer, SWIGTYPE_p_btSerializer.getCPtr(serializer));}
public void serializeSingleObject(SWIGTYPE_p_btSerializer serializer) {CollisionJNI.btCollisionObject_serializeSingleObject(swigCPtr, this, SWIGTYPE_p_btSerializer.getCPtr(serializer));}
private void internalSetGdxBridge(GdxCollisionObjectBridge bridge) {CollisionJNI.btCollisionObject_internalSetGdxBridge(swigCPtr, this, GdxCollisionObjectBridge.getCPtr(bridge), bridge);}
private GdxCollisionObjectBridge internalGetGdxBridge() {long cPtr = CollisionJNI.btCollisionObject_internalGetGdxBridge(swigCPtr, this);return (cPtr == 0) ? null : new GdxCollisionObjectBridge(cPtr, false);}
public void getAnisotropicFriction(Vector3 out) {CollisionJNI.btCollisionObject_getAnisotropicFriction__SWIG_1(swigCPtr, this, out);}
public void getWorldTransform(Matrix4 out) {CollisionJNI.btCollisionObject_getWorldTransform__SWIG_2(swigCPtr, this, out);}
public void getInterpolationWorldTransform(Matrix4 out) {CollisionJNI.btCollisionObject_getInterpolationWorldTransform__SWIG_2(swigCPtr, this, out);}
public void getInterpolationLinearVelocity(Vector3 out) {CollisionJNI.btCollisionObject_getInterpolationLinearVelocity__SWIG_1(swigCPtr, this, out);}
public void getInterpolationAngularVelocity(Vector3 out) {CollisionJNI.btCollisionObject_getInterpolationAngularVelocity__SWIG_1(swigCPtr, this, out);}public void setListener(OisListener listener) {this.listener = listener;}
private void buttonPressed(int buttonIndex) {buttons[buttonIndex] = true;if (listener != null)listener.buttonPressed(this, buttonIndex);}
private void buttonReleased(int buttonIndex) {buttons[buttonIndex] = false;if (listener != null)listener.buttonReleased(this, buttonIndex);}
private void axisMoved(int axisIndex, int value) {// -1 to 1axes[axisIndex] = ((value - MIN_AXIS) << 1) / (float) (MAX_AXIS - MIN_AXIS) - 1;if (listener != null)listener.axisMoved(this, axisIndex, axes[axisIndex]);}
private void povMoved(int povIndex, int value) {povs[povIndex] = value;if (listener != null)listener.povMoved(this, povIndex, getPov(povIndex));}
private void sliderMoved(int sliderIndex, int x, int y) {boolean xChanged = slidersX[sliderIndex] != (x == 1);boolean yChanged = slidersY[sliderIndex] != (y == 1);slidersX[sliderIndex] = x == 1;slidersY[sliderIndex] = y == 1;if (listener != null) {if (xChanged)listener.xSliderMoved(this, sliderIndex, x == 1);if (yChanged)listener.ySliderMoved(this, sliderIndex, y == 1);}}
public void update() {update(joystickPtr, this);}
public int getAxisCount() {return getAxesCount(joystickPtr);}
public int getButtonCount() {return getButtonCount(joystickPtr);}
public int getPovCount() {return getPovCount(joystickPtr);}
public int getSliderCount() {return getSliderCount(joystickPtr);}
public float getAxis(int axisIndex) {if (axisIndex < 0 || axisIndex >= axes.length)return 0;return axes[axisIndex];}
public OisPov getPov(int povIndex) {if (povIndex < 0 || povIndex >= povs.length)return OisPov.Centered;switch(povs[povIndex]) {case 0x00000000:return OisPov.Centered;case 0x00000001:return OisPov.North;case 0x00000010:return OisPov.South;case 0x00000100:return OisPov.East;case 0x00001000:return OisPov.West;case 0x00000101:return OisPov.NorthEast;case 0x00000110:return OisPov.SouthEast;case 0x00001001:return OisPov.NorthWest;case 0x00001010:return OisPov.SouthWest;default:throw new RuntimeException("Unexpected POV value reported by OIS: " + povs[povIndex]);}}
public boolean isButtonPressed(int buttonIndex) {if (buttonIndex < 0 || buttonIndex >= buttons.length)return false;return buttons[buttonIndex];}
public boolean getSliderX(int sliderIndex) {if (sliderIndex < 0 || sliderIndex >= slidersX.length)return false;return slidersX[sliderIndex];}
public boolean getSliderY(int sliderIndex) {if (sliderIndex < 0 || sliderIndex >= slidersY.length)return false;return slidersY[sliderIndex];}
public String getName() {return name;}
public String toString() {return name;}public static int toGlFormat(int format) {switch(format) {case GDX2D_FORMAT_ALPHA:return GL20.GL_ALPHA;case GDX2D_FORMAT_LUMINANCE_ALPHA:return GL20.GL_LUMINANCE_ALPHA;case GDX2D_FORMAT_RGB888:case GDX2D_FORMAT_RGB565:return GL20.GL_RGB;case GDX2D_FORMAT_RGBA8888:case GDX2D_FORMAT_RGBA4444:return GL20.GL_RGBA;default:throw new GdxRuntimeException("unknown format: " + format);}}
public static int toGlType(int format) {switch(format) {case GDX2D_FORMAT_ALPHA:case GDX2D_FORMAT_LUMINANCE_ALPHA:case GDX2D_FORMAT_RGB888:case GDX2D_FORMAT_RGBA8888:return GL20.GL_UNSIGNED_BYTE;case GDX2D_FORMAT_RGB565:return GL20.GL_UNSIGNED_SHORT_5_6_5;case GDX2D_FORMAT_RGBA4444:return GL20.GL_UNSIGNED_SHORT_4_4_4_4;default:throw new GdxRuntimeException("unknown format: " + format);}}
private void convert(int requestedFormat) {Gdx2DPixmap pixmap = new Gdx2DPixmap(width, height, requestedFormat);pixmap.drawPixmap(this, 0, 0, 0, 0, width, height);dispose();this.basePtr = pixmap.basePtr;this.format = pixmap.format;this.height = pixmap.height;this.nativeData = pixmap.nativeData;this.pixelPtr = pixmap.pixelPtr;this.width = pixmap.width;}
public void dispose() {free(basePtr);}
public void clear(int color) {clear(basePtr, color);}
public void setPixel(int x, int y, int color) {setPixel(basePtr, x, y, color);}
public int getPixel(int x, int y) {return getPixel(basePtr, x, y);}
public void drawLine(int x, int y, int x2, int y2, int color) {drawLine(basePtr, x, y, x2, y2, color);}
public void drawRect(int x, int y, int width, int height, int color) {drawRect(basePtr, x, y, width, height, color);}
public void drawCircle(int x, int y, int radius, int color) {drawCircle(basePtr, x, y, radius, color);}
public void fillRect(int x, int y, int width, int height, int color) {fillRect(basePtr, x, y, width, height, color);}
public void fillCircle(int x, int y, int radius, int color) {fillCircle(basePtr, x, y, radius, color);}
public void fillTriangle(int x1, int y1, int x2, int y2, int x3, int y3, int color) {fillTriangle(basePtr, x1, y1, x2, y2, x3, y3, color);}
public void drawPixmap(Gdx2DPixmap src, int srcX, int srcY, int dstX, int dstY, int width, int height) {drawPixmap(src.basePtr, basePtr, srcX, srcY, width, height, dstX, dstY, width, height);}
public void drawPixmap(Gdx2DPixmap src, int srcX, int srcY, int srcWidth, int srcHeight, int dstX, int dstY, int dstWidth, int dstHeight) {drawPixmap(src.basePtr, basePtr, srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight);}
public static Gdx2DPixmap newPixmap(InputStream in, int requestedFormat) {try {return new Gdx2DPixmap(in, requestedFormat);} catch (IOException e) {return null;}}
public static Gdx2DPixmap newPixmap(int width, int height, int format) {try {return new Gdx2DPixmap(width, height, format);} catch (IllegalArgumentException e) {return null;}}
public ByteBuffer getPixels() {return pixelPtr;}
public int getHeight() {return height;}
public int getWidth() {return width;}
public int getFormat() {return format;}
public int getGLInternalFormat() {return toGlFormat(format);}
public int getGLFormat() {return getGLInternalFormat();}
public int getGLType() {return toGlType(format);}
public String getFormatString() {switch(format) {case GDX2D_FORMAT_ALPHA:return "alpha";case GDX2D_FORMAT_LUMINANCE_ALPHA:return "luminance alpha";case GDX2D_FORMAT_RGB888:return "rgb888";case GDX2D_FORMAT_RGBA8888:return "rgba8888";case GDX2D_FORMAT_RGB565:return "rgb565";case GDX2D_FORMAT_RGBA4444:return "rgba4444";default:return "unknown";}}public void create() {Vector2 trn = new Vector2(30, 50);float rot = 35;float cos = (float) Math.cos(MathUtils.degreesToRadians * rot);float sin = (float) Math.sin(MathUtils.degreesToRadians * rot);Vector2 scl = new Vector2(0.42f, 1.19f);Vector2 shear = new Vector2(0.35f, 0.71f);Matrix3 mat1 = new Matrix3();Matrix3 mat2 = new Matrix3();Affine2 afn1 = new Affine2();Affine2 afn2 = new Affine2();// check setter - identitycheckEqual(mat1, new float[] { 1, 0, 0, 0, 1, 0, 0, 0, 1 });checkEqual(mat1, mat2.idt());checkEqual(mat1, afn1);checkEqual(mat1, afn1.idt());// check setter - translationmat1.setToTranslation(trn);checkEqual(mat1, new float[] { 1, 0, 0, 0, 1, 0, trn.x, trn.y, 1 });afn1.setToTranslation(trn);checkEqual(mat1, afn1);// check setter - scalemat1.setToScaling(scl);checkEqual(mat1, new float[] { scl.x, 0, 0, 0, scl.y, 0, 0, 0, 1 });afn1.setToScaling(scl);checkEqual(mat1, afn1);// check setter - rotationmat1.setToRotation(rot);checkEqual(mat1, new float[] { cos, sin, 0, -sin, cos, 0, 0, 0, 1 });afn1.setToRotation(rot);checkEqual(mat1, afn1);mat1.setToRotationRad(MathUtils.degreesToRadians * rot);checkEqual(mat1, afn1);afn1.setToRotationRad(MathUtils.degreesToRadians * rot);checkEqual(mat1, afn1);// check setter - shearingafn1.setToShearing(shear);checkEqual(mat1.set(afn1), new float[] { 1, shear.y, 0, shear.x, 1, 0, 0, 0, 1 });// check setter - translation x rotation x scaleafn1.setToTrnRotScl(trn, rot, scl);afn2.setToTrnRotRadScl(trn, MathUtils.degreesToRadians * rot, scl);checkEqual(afn1, afn2);afn2.setToTranslation(trn).rotate(rot).scale(scl);checkEqual(afn1, afn2);// check setter - translation x scaleafn1.setToTrnRotScl(trn, 0, scl);afn2.setToTrnScl(trn, scl);checkEqual(afn1, afn2);// check post-multiplicationmat1.idt().scale(scl).rotate(rot).translate(trn).mul(mat2.set(afn2.setToShearing(shear)));afn1.idt().scale(scl).rotate(rot).translate(trn).shear(shear);checkEqual(mat1, afn1);afn1.idt().mul(afn2.setToScaling(scl)).mul(afn2.setToRotation(rot)).mul(afn2.setToTranslation(trn)).mul(afn2.setToShearing(shear));checkEqual(mat1, afn1);// check pre-multiplicationafn1.idt().preShear(shear).preTranslate(trn).preRotate(rot).preScale(scl);checkEqual(mat1, afn1);afn1.idt().preMul(afn2.setToShearing(shear)).preMul(afn2.setToTranslation(trn)).preMul(afn2.setToRotation(rot)).preMul(afn2.setToScaling(scl));checkEqual(mat1, afn1);mat1.set(afn2.setToShearing(shear)).trn(trn).mulLeft(mat2.setToRotation(rot)).mulLeft(mat2.setToScaling(scl));checkEqual(mat1, afn1);// check determinant and inversecheckEqual(mat1.det(), afn1.det());check(afn1.det() == (afn1.m00 * afn1.m11 - afn1.m01 * afn1.m10));mat1.inv();afn2.set(afn1).inv();checkEqual(mat1, afn2);checkEqual(afn1.det(), 1 / afn2.det());// check for exception when trying to invert singular matricesboolean didThrow = false;afn1.setToShearing(1, 1);try {afn1.inv();} catch (GdxRuntimeException e) {didThrow = true;}check(didThrow);System.out.println("All tests passed.");}
private static void check(boolean condition) {if (!condition)throw new GdxRuntimeException("");}
private static void check(boolean condition, String msg) {if (!condition)throw new GdxRuntimeException(msg);}
private static void checkEqual(Matrix3 matrix, Affine2 affine) {checkEqual(matrix, new Matrix3().set(affine));}
private static void checkEqual(Affine2 a, Affine2 b) {checkEqual(new Matrix3().set(a), new Matrix3().set(b));}
private static void checkEqual(Matrix3 a, Matrix3 b) {for (int i = 0; i < 9; i++) check(MathUtils.isEqual(a.val[i], b.val[i], TOLERANCE), "matrices are not equal");}
private static void checkEqual(Matrix3 matrix, float[] vals) {for (int i = 0; i < 9; i++) check(MathUtils.isEqual(matrix.val[i], vals[i], TOLERANCE), "matrices are not equal");}
private static void checkEqual(float a, float b) {check(MathUtils.isEqual(a, b, TOLERANCE));}public void writeSamples(short[] samples, int offset, int numSamples) {if (bytes == null || bytes.length < numSamples * 2)bytes = new byte[numSamples * 2];int end = Math.min(offset + numSamples, samples.length);for (int i = offset, ii = 0; i < end; i++) {short sample = samples[i];bytes[ii++] = (byte) (sample & 0xFF);bytes[ii++] = (byte) ((sample >> 8) & 0xFF);}writeSamples(bytes, 0, numSamples * 2);}
public void writeSamples(float[] samples, int offset, int numSamples) {if (bytes == null || bytes.length < numSamples * 2)bytes = new byte[numSamples * 2];int end = Math.min(offset + numSamples, samples.length);for (int i = offset, ii = 0; i < end; i++) {float floatSample = samples[i];floatSample = MathUtils.clamp(floatSample, -1f, 1f);int intSample = (int) (floatSample * 32767);bytes[ii++] = (byte) (intSample & 0xFF);bytes[ii++] = (byte) ((intSample >> 8) & 0xFF);}writeSamples(bytes, 0, numSamples * 2);}
public void writeSamples(byte[] data, int offset, int length) {if (length < 0)throw new IllegalArgumentException("length cannot be < 0.");if (sourceID == -1) {sourceID = audio.obtainSource(true);if (sourceID == -1)return;if (buffers == null) {buffers = BufferUtils.createIntBuffer(bufferCount);alGenBuffers(buffers);if (alGetError() != AL_NO_ERROR)throw new GdxRuntimeException("Unabe to allocate audio buffers.");}alSourcei(sourceID, AL_LOOPING, AL_FALSE);alSourcef(sourceID, AL_GAIN, volume);// Fill initial buffers.int queuedBuffers = 0;for (int i = 0; i < bufferCount; i++) {int bufferID = buffers.get(i);int written = Math.min(bufferSize, length);tempBuffer.clear();tempBuffer.put(data, offset, written).flip();alBufferData(bufferID, format, tempBuffer, sampleRate);alSourceQueueBuffers(sourceID, bufferID);length -= written;offset += written;queuedBuffers++;}// Queue rest of buffers, empty.tempBuffer.clear().flip();for (int i = queuedBuffers; i < bufferCount; i++) {int bufferID = buffers.get(i);alBufferData(bufferID, format, tempBuffer, sampleRate);alSourceQueueBuffers(sourceID, bufferID);}alSourcePlay(sourceID);isPlaying = true;}while (length > 0) {int written = fillBuffer(data, offset, length);length -= written;offset += written;}}
private int fillBuffer(byte[] data, int offset, int length) {int written = Math.min(bufferSize, length);outer: while (true) {int buffers = alGetSourcei(sourceID, AL_BUFFERS_PROCESSED);while (buffers-- > 0) {int bufferID = alSourceUnqueueBuffers(sourceID);if (bufferID == AL_INVALID_VALUE)break;renderedSeconds += secondsPerBuffer;tempBuffer.clear();tempBuffer.put(data, offset, written).flip();alBufferData(bufferID, format, tempBuffer, sampleRate);alSourceQueueBuffers(sourceID, bufferID);break outer;}// Wait for buffer to be free.try {Thread.sleep((long) (1000 * secondsPerBuffer / bufferCount));} catch (InterruptedException ignored) {}}// A buffer underflow will cause the source to stop.if (!isPlaying || alGetSourcei(sourceID, AL_SOURCE_STATE) != AL_PLAYING) {alSourcePlay(sourceID);isPlaying = true;}return written;}
public void stop() {if (sourceID == -1)return;audio.freeSource(sourceID);sourceID = -1;renderedSeconds = 0;isPlaying = false;}
public boolean isPlaying() {if (sourceID == -1)return false;return isPlaying;}
public void setVolume(float volume) {this.volume = volume;if (sourceID != -1)alSourcef(sourceID, AL_GAIN, volume);}
public float getPosition() {if (sourceID == -1)return 0;return renderedSeconds + alGetSourcef(sourceID, AL11.AL_SEC_OFFSET);}
public void setPosition(float position) {renderedSeconds = position;}
public int getChannels() {return format == AL_FORMAT_STEREO16 ? 2 : 1;}
public int getRate() {return sampleRate;}
public void dispose() {if (buffers == null)return;if (sourceID != -1) {audio.freeSource(sourceID);sourceID = -1;}alDeleteBuffers(buffers);buffers = null;}
public boolean isMono() {return channels == 1;}
public int getLatency() {return (int) (secondsPerBuffer * bufferCount * 1000);}protected void createWorld(World world) {Body ground;{BodyDef bd = new BodyDef();ground = world.createBody(bd);EdgeShape shape = new EdgeShape();shape.set(new Vector2(-20, 0), new Vector2(20, 0));FixtureDef fd = new FixtureDef();fd.shape = shape;ground.createFixture(fd);shape.dispose();}{BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.position.set(0, 3.0f);m_attachment = world.createBody(bd);PolygonShape shape = new PolygonShape();shape.setAsBox(0.5f, 2.0f);m_attachment.createFixture(shape, 2.0f);shape.dispose();}{BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.position.set(-4.0f, 5.0f);m_platform = world.createBody(bd);PolygonShape shape = new PolygonShape();shape.setAsBox(0.5f, 4.0f, new Vector2(4.0f, 0), 0.5f * (float) Math.PI);FixtureDef fd = new FixtureDef();fd.shape = shape;fd.friction = 0.6f;fd.density = 2.0f;m_platform.createFixture(fd);shape.dispose();RevoluteJointDef rjd = new RevoluteJointDef();rjd.initialize(m_attachment, m_platform, new Vector2(0, 5.0f));rjd.maxMotorTorque = 50.0f;rjd.enableMotor = true;world.createJoint(rjd);PrismaticJointDef pjd = new PrismaticJointDef();pjd.initialize(ground, m_platform, new Vector2(0, 5.0f), new Vector2(1, 0));pjd.maxMotorForce = 1000.0f;pjd.enableMotor = true;pjd.lowerTranslation = -10f;pjd.upperTranslation = 10.0f;pjd.enableLimit = true;world.createJoint(pjd);m_speed = 3.0f;}{BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.position.set(0, 8.0f);Body body = world.createBody(bd);PolygonShape shape = new PolygonShape();shape.setAsBox(0.75f, 0.75f);FixtureDef fd = new FixtureDef();fd.shape = shape;fd.friction = 0.6f;fd.density = 2.0f;body.createFixture(fd);shape.dispose();}}
public boolean keyDown(int keyCode) {if (keyCode == Keys.D)m_platform.setType(BodyType.DynamicBody);if (keyCode == Keys.S)m_platform.setType(BodyType.StaticBody);if (keyCode == Keys.K) {m_platform.setType(BodyType.KinematicBody);m_platform.setLinearVelocity(tmp.set(-m_speed, 0));m_platform.setAngularVelocity(0);}return false;}
public void render() {if (m_platform.getType() == BodyType.KinematicBody) {Vector2 p = m_platform.getTransform().getPosition();Vector2 v = m_platform.getLinearVelocity();if ((p.x < -10 && v.x < 0) || (p.x > 10 && v.x > 0)) {v.x = -v.x;m_platform.setLinearVelocity(v);}}super.render();}public boolean touchDown(InputEvent event, float x, float y, int pointer, int button) {event.cancel();return false;}
private void initialize() {setModal(true);defaults().space(6);add(contentTable = new Table(skin)).expand().fill();row();add(buttonTable = new Table(skin));contentTable.defaults().space(6);buttonTable.defaults().space(6);buttonTable.addListener(new ChangeListener() {
public void changed(ChangeEvent event, Actor actor) {if (!values.containsKey(actor))return;while (actor.getParent() != buttonTable) actor = actor.getParent();result(values.get(actor));if (!cancelHide)hide();cancelHide = false;}});focusListener = new FocusListener() {
public void keyboardFocusChanged(FocusEvent event, Actor actor, boolean focused) {if (!focused)focusChanged(event);}
public void scrollFocusChanged(FocusEvent event, Actor actor, boolean focused) {if (!focused)focusChanged(event);}
private void focusChanged(FocusEvent event) {Stage stage = getStage();if (isModal && stage != null && stage.getRoot().getChildren().size > 0 && stage.getRoot().getChildren().peek() == Dialog.this) {// Dialog is top most actor.Actor newFocusedActor = event.getRelatedActor();if (newFocusedActor != null && !newFocusedActor.isDescendantOf(Dialog.this) && !(newFocusedActor.equals(previousKeyboardFocus) || newFocusedActor.equals(previousScrollFocus)))event.cancel();}}};}
public void changed(ChangeEvent event, Actor actor) {if (!values.containsKey(actor))return;while (actor.getParent() != buttonTable) actor = actor.getParent();result(values.get(actor));if (!cancelHide)hide();cancelHide = false;}
public void keyboardFocusChanged(FocusEvent event, Actor actor, boolean focused) {if (!focused)focusChanged(event);}
public void scrollFocusChanged(FocusEvent event, Actor actor, boolean focused) {if (!focused)focusChanged(event);}
private void focusChanged(FocusEvent event) {Stage stage = getStage();if (isModal && stage != null && stage.getRoot().getChildren().size > 0 && stage.getRoot().getChildren().peek() == Dialog.this) {// Dialog is top most actor.Actor newFocusedActor = event.getRelatedActor();if (newFocusedActor != null && !newFocusedActor.isDescendantOf(Dialog.this) && !(newFocusedActor.equals(previousKeyboardFocus) || newFocusedActor.equals(previousScrollFocus)))event.cancel();}}
protected void setStage(Stage stage) {if (stage == null)addListener(focusListener);elseremoveListener(focusListener);super.setStage(stage);}
public Table getContentTable() {return contentTable;}
public Table getButtonTable() {return buttonTable;}
public Dialog text(String text) {if (skin == null)throw new IllegalStateException("This method may only be used if the dialog was constructed with a Skin.");return text(text, skin.get(LabelStyle.class));}
public Dialog text(String text, LabelStyle labelStyle) {return text(new Label(text, labelStyle));}
public Dialog text(Label label) {contentTable.add(label);return this;}
public Dialog button(String text) {return button(text, null);}
public Dialog button(String text, Object object) {if (skin == null)throw new IllegalStateException("This method may only be used if the dialog was constructed with a Skin.");return button(text, object, skin.get(TextButtonStyle.class));}
public Dialog button(String text, Object object, TextButtonStyle buttonStyle) {return button(new TextButton(text, buttonStyle), object);}
public Dialog button(Button button) {return button(button, null);}
public Dialog button(Button button, Object object) {buttonTable.add(button);setObject(button, object);return this;}
public Dialog show(Stage stage, Action action) {clearActions();removeCaptureListener(ignoreTouchDown);previousKeyboardFocus = null;Actor actor = stage.getKeyboardFocus();if (actor != null && !actor.isDescendantOf(this))previousKeyboardFocus = actor;previousScrollFocus = null;actor = stage.getScrollFocus();if (actor != null && !actor.isDescendantOf(this))previousScrollFocus = actor;pack();stage.addActor(this);stage.setKeyboardFocus(this);stage.setScrollFocus(this);if (action != null)addAction(action);return this;}
public Dialog show(Stage stage) {show(stage, sequence(Actions.alpha(0), Actions.fadeIn(0.4f, Interpolation.fade)));setPosition(Math.round((stage.getWidth() - getWidth()) / 2), Math.round((stage.getHeight() - getHeight()) / 2));return this;}
public void hide(Action action) {Stage stage = getStage();if (stage != null) {removeListener(focusListener);if (previousKeyboardFocus != null && previousKeyboardFocus.getStage() == null)previousKeyboardFocus = null;Actor actor = stage.getKeyboardFocus();if (actor == null || actor.isDescendantOf(this))stage.setKeyboardFocus(previousKeyboardFocus);if (previousScrollFocus != null && previousScrollFocus.getStage() == null)previousScrollFocus = null;actor = stage.getScrollFocus();if (actor == null || actor.isDescendantOf(this))stage.setScrollFocus(previousScrollFocus);}if (action != null) {addCaptureListener(ignoreTouchDown);addAction(sequence(action, Actions.removeListener(ignoreTouchDown, true), Actions.removeActor()));} elseremove();}
public void hide() {hide(sequence(fadeOut(0.4f, Interpolation.fade), Actions.removeListener(ignoreTouchDown, true), Actions.removeActor()));}
public void setObject(Actor actor, Object object) {values.put(actor, object);}
public Dialog key(final int keycode, final Object object) {addListener(new InputListener() {
public boolean keyDown(InputEvent event, int keycode2) {if (keycode == keycode2) {result(object);if (!cancelHide)hide();cancelHide = false;}return false;}});return this;}
public boolean keyDown(InputEvent event, int keycode2) {if (keycode == keycode2) {result(object);if (!cancelHide)hide();cancelHide = false;}return false;}
protected void result(Object object) {}
public void cancel() {cancelHide = true;}public Matrix4 calculateParallaxMatrix(float parallaxX, float parallaxY) {update();tmp.set(position);tmp.x *= parallaxX;tmp.y *= parallaxY;parallaxView.setToLookAt(tmp, tmp2.set(tmp).add(direction), up);parallaxCombined.set(projection);Matrix4.mul(parallaxCombined.val, parallaxView.val);return parallaxCombined;}
public void create() {Texture texture = new Texture(Gdx.files.internal("data/layers.png"));layers = new TextureRegion[3];layers[0] = new TextureRegion(texture, 0, 0, 542, 363);layers[1] = new TextureRegion(texture, 0, 363, 1024, 149);layers[2] = new TextureRegion(texture, 547, 0, 224, 51);camera = new ParallaxCamera(480, 320);controller = new OrthoCamController(camera);Gdx.input.setInputProcessor(controller);batch = new SpriteBatch();font = new BitmapFont(Gdx.files.internal("data/arial-15.fnt"), false);}
public void dispose() {layers[0].getTexture().dispose();batch.dispose();font.dispose();}
public void render() {Gdx.gl.glClearColor(242 / 255.0f, 210 / 255.0f, 111 / 255.0f, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);// keep camera in foreground layer boundsboolean updateCamera = false;if (camera.position.x < -1024 + camera.viewportWidth / 2) {camera.position.x = -1024 + (int) (camera.viewportWidth / 2);updateCamera = true;}if (camera.position.x > 1024 - camera.viewportWidth / 2) {camera.position.x = 1024 - (int) (camera.viewportWidth / 2);updateCamera = true;}if (camera.position.y < 0) {camera.position.y = 0;updateCamera = true;}// arbitrary height of sceneif (camera.position.y > 400 - camera.viewportHeight / 2) {camera.position.y = 400 - (int) (camera.viewportHeight / 2);updateCamera = true;}// background layer, no parallax, centered around originbatch.setProjectionMatrix(camera.calculateParallaxMatrix(0, 0));batch.disableBlending();batch.begin();batch.draw(layers[0], -(int) (layers[0].getRegionWidth() / 2), -(int) (layers[0].getRegionHeight() / 2));batch.end();batch.enableBlending();// layer is 1024x320batch.setProjectionMatrix(camera.calculateParallaxMatrix(0.5f, 1));batch.begin();batch.draw(layers[1], -512, -160);batch.end();// layer is 2048x320batch.setProjectionMatrix(camera.calculateParallaxMatrix(1f, 1));batch.begin();for (int i = 0; i < 9; i++) {batch.draw(layers[2], i * layers[2].getRegionWidth() - 1024, -160);}batch.end();// draw fpsbatch.getProjectionMatrix().setToOrtho2D(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());batch.begin();font.draw(batch, "fps: " + Gdx.graphics.getFramesPerSecond(), 0, 30);batch.end();}public void render() {Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);spriteBatch.begin();spriteBatch.draw(texture, 16, 10, 16, 16, 32, 32, 1, 1, 0, 0, 0, texture.getWidth(), texture.getHeight(), false, false);spriteBatch.draw(texture, 64, 10, 32, 32, 0, 0, texture.getWidth(), texture.getHeight(), false, false);spriteBatch.draw(texture, 112, 10, 0, 0, texture.getWidth(), texture.getHeight());spriteBatch.draw(texture, 16, 58, 16, 16, 32, 32, 1, 1, angle, 0, 0, texture.getWidth(), texture.getHeight(), false, false);spriteBatch.draw(texture, 64, 58, 16, 16, 32, 32, scale, scale, 0, 0, 0, texture.getWidth(), texture.getHeight(), false, false);spriteBatch.draw(texture, 112, 58, 16, 16, 32, 32, scale, scale, angle, 0, 0, texture.getWidth(), texture.getHeight(), false, false);spriteBatch.draw(texture, 160, 58, 0, 0, 32, 32, scale, scale, angle, 0, 0, texture.getWidth(), texture.getHeight(), false, false);spriteBatch.end();angle += 20 * Gdx.graphics.getDeltaTime();scale += vScale * Gdx.graphics.getDeltaTime();if (scale > 2) {vScale = -vScale;scale = 2;}if (scale < 0) {vScale = -vScale;scale = 0;}}
public void create() {spriteBatch = new SpriteBatch();texture = new Texture(Gdx.files.internal("data/test.png"));}public void glViewport(int x, int y, int width, int height) {IOSGLES20.x = x;IOSGLES20.y = y;IOSGLES20.width = width;IOSGLES20.height = height;glViewportJni(x, y, width, height);}Dialog createDialog() {textView = createView(context);textView.setOnKeyListener(this);FrameLayout.LayoutParams textBoxLayoutParams = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM);textView.setLayoutParams(textBoxLayoutParams);textView.setFocusable(true);textView.setFocusableInTouchMode(true);textView.setImeOptions(textView.getImeOptions() | EditorInfo.IME_FLAG_NO_EXTRACT_UI);final FrameLayout layout = new FrameLayout(context);ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0);layout.setLayoutParams(layoutParams);layout.addView(textView);layout.setOnTouchListener(this);dialog = new Dialog(context, android.R.style.Theme_Translucent_NoTitleBar_Fullscreen);dialog.setContentView(layout);return dialog;}
public static TextView createView(Context context) {final TextView view = new TextView(context) {
Editable editable = new PassThroughEditable();
@Overrideprotected boolean getDefaultEditable() {return true;}
@Overridepublic Editable getEditableText() {return editable;}
@Overrideprotected MovementMethod getDefaultMovementMethod() {return ArrowKeyMovementMethod.getInstance();}
@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) {Log.d("Test", "down keycode: " + event.getKeyCode());return super.onKeyDown(keyCode, event);}
@Overridepublic boolean onKeyUp(int keyCode, KeyEvent event) {Log.d("Test", "up keycode: " + event.getKeyCode());return super.onKeyUp(keyCode, event);}};// view.setCursorVisible(false);return view;}
protected boolean getDefaultEditable() {return true;}
public Editable getEditableText() {return editable;}
protected MovementMethod getDefaultMovementMethod() {return ArrowKeyMovementMethod.getInstance();}
public boolean onKeyDown(int keyCode, KeyEvent event) {Log.d("Test", "down keycode: " + event.getKeyCode());return super.onKeyDown(keyCode, event);}
public boolean onKeyUp(int keyCode, KeyEvent event) {Log.d("Test", "up keycode: " + event.getKeyCode());return super.onKeyUp(keyCode, event);}
public void setVisible(boolean visible) {if (visible && dialog != null) {dialog.dismiss();dialog = null;}if (visible && dialog == null && !input.isPeripheralAvailable(Peripheral.HardwareKeyboard)) {handler.post(new Runnable() {
@Overridepublic void run() {dialog = createDialog();dialog.show();handler.post(new Runnable() {
@Overridepublic void run() {dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);InputMethodManager input = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);if (input != null)input.showSoftInput(textView, InputMethodManager.SHOW_FORCED);}});final View content = dialog.getWindow().findViewById(Window.ID_ANDROID_CONTENT);content.getViewTreeObserver().addOnPreDrawListener(new OnPreDrawListener() {
int[] screenloc = new int[2];
private int keyboardHeight;
private boolean keyboardShowing;
@Overridepublic boolean onPreDraw() {content.getLocationOnScreen(screenloc);keyboardHeight = Math.abs(screenloc[1]);if (keyboardHeight > 0)keyboardShowing = true;if (keyboardHeight == 0 && keyboardShowing) {dialog.dismiss();dialog = null;}return true;}});}});} else {if (!visible && dialog != null) {dialog.dismiss();}}}
public void run() {dialog = createDialog();dialog.show();handler.post(new Runnable() {
@Overridepublic void run() {dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);InputMethodManager input = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);if (input != null)input.showSoftInput(textView, InputMethodManager.SHOW_FORCED);}});final View content = dialog.getWindow().findViewById(Window.ID_ANDROID_CONTENT);content.getViewTreeObserver().addOnPreDrawListener(new OnPreDrawListener() {
int[] screenloc = new int[2];
private int keyboardHeight;
private boolean keyboardShowing;
@Overridepublic boolean onPreDraw() {content.getLocationOnScreen(screenloc);keyboardHeight = Math.abs(screenloc[1]);if (keyboardHeight > 0)keyboardShowing = true;if (keyboardHeight == 0 && keyboardShowing) {dialog.dismiss();dialog = null;}return true;}});}
public void run() {dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);InputMethodManager input = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);if (input != null)input.showSoftInput(textView, InputMethodManager.SHOW_FORCED);}
public boolean onPreDraw() {content.getLocationOnScreen(screenloc);keyboardHeight = Math.abs(screenloc[1]);if (keyboardHeight > 0)keyboardShowing = true;if (keyboardHeight == 0 && keyboardShowing) {dialog.dismiss();dialog = null;}return true;}
public char charAt(int index) {Log.d("Editable", "charAt");return 0;}
public int length() {Log.d("Editable", "length");return 0;}
public CharSequence subSequence(int start, int end) {Log.d("Editable", "subSequence");return null;}
public void getChars(int start, int end, char[] dest, int destoff) {Log.d("Editable", "getChars");}
public void removeSpan(Object what) {Log.d("Editable", "removeSpan");}
public void setSpan(Object what, int start, int end, int flags) {Log.d("Editable", "setSpan");}
public int getSpanEnd(Object tag) {Log.d("Editable", "getSpanEnd");return 0;}
public int getSpanFlags(Object tag) {Log.d("Editable", "getSpanFlags");return 0;}
public int getSpanStart(Object tag) {Log.d("Editable", "getSpanStart");return 0;}
public T[] getSpans(int arg0, int arg1, Class<T> arg2) {Log.d("Editable", "getSpans");return null;}
public int nextSpanTransition(int start, int limit, Class type) {Log.d("Editable", "nextSpanTransition");return 0;}
public Editable append(CharSequence text) {Log.d("Editable", "append: " + text);return this;}
public Editable append(char text) {Log.d("Editable", "append: " + text);return this;}
public Editable append(CharSequence text, int start, int end) {Log.d("Editable", "append: " + text);return this;}
public void clear() {Log.d("Editable", "clear");}
public void clearSpans() {Log.d("Editable", "clearSpanes");}
public Editable delete(int st, int en) {Log.d("Editable", "delete, " + st + ", " + en);return this;}
public InputFilter[] getFilters() {Log.d("Editable", "getFilters");return new InputFilter[0];}
public Editable insert(int where, CharSequence text) {Log.d("Editable", "insert: " + text);return this;}
public Editable insert(int where, CharSequence text, int start, int end) {Log.d("Editable", "insert: " + text);return this;}
public Editable replace(int st, int en, CharSequence text) {Log.d("Editable", "replace: " + text);return this;}
public Editable replace(int st, int en, CharSequence source, int start, int end) {Log.d("Editable", "replace: " + source);return this;}
public void setFilters(InputFilter[] filters) {Log.d("Editable", "setFilters");}
public boolean onTouch(View view, MotionEvent e) {return false;}
public boolean onKey(View view, int keycode, KeyEvent e) {return false;}protected void createWorld(World world) {world.setGravity(new Vector2(0, 0));float k_restitution = 0.4f;Body ground;{BodyDef bd = new BodyDef();bd.position.set(0, 20);ground = world.createBody(bd);EdgeShape shape = new EdgeShape();FixtureDef sd = new FixtureDef();sd.shape = shape;sd.density = 0;sd.restitution = k_restitution;shape.set(new Vector2(-20, -20), new Vector2(-20, 20));ground.createFixture(sd);shape.set(new Vector2(20, -20), new Vector2(20, 20));ground.createFixture(sd);shape.set(new Vector2(-20, 20), new Vector2(20, 20));ground.createFixture(sd);shape.set(new Vector2(-20, -20), new Vector2(20, -20));ground.createFixture(sd);shape.dispose();}{Transform xf1 = new Transform(new Vector2(), 0.3524f * (float) Math.PI);xf1.setPosition(xf1.mul(new Vector2(1, 0)));Vector2[] vertices = new Vector2[3];vertices[0] = xf1.mul(new Vector2(-1, 0));vertices[1] = xf1.mul(new Vector2(1, 0));vertices[2] = xf1.mul(new Vector2(0, 0.5f));PolygonShape poly1 = new PolygonShape();poly1.set(vertices);FixtureDef sd1 = new FixtureDef();sd1.shape = poly1;sd1.density = 4.0f;Transform xf2 = new Transform(new Vector2(), -0.3524f * (float) Math.PI);xf2.setPosition(xf2.mul(new Vector2(-1, 0)));vertices[0] = xf2.mul(new Vector2(-1, 0));vertices[1] = xf2.mul(new Vector2(1, 0));vertices[2] = xf2.mul(new Vector2(0, 0.5f));PolygonShape poly2 = new PolygonShape();poly2.set(vertices);FixtureDef sd2 = new FixtureDef();sd2.shape = poly2;sd2.density = 2.0f;BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.angularDamping = 5.0f;bd.linearDamping = 0.1f;bd.position.set(0, 2);bd.angle = (float) Math.PI;bd.allowSleep = false;m_body = world.createBody(bd);m_body.createFixture(sd1);m_body.createFixture(sd2);poly1.dispose();poly2.dispose();}{PolygonShape shape = new PolygonShape();shape.setAsBox(0.5f, 0.5f);FixtureDef fd = new FixtureDef();fd.shape = shape;fd.density = 1.0f;fd.friction = 0.3f;for (int i = 0; i < 10; i++) {BodyDef bd = new BodyDef();bd.type = BodyType.DynamicBody;bd.position.set(0, 5 + 1.54f * i);Body body = world.createBody(bd);body.createFixture(fd);float gravity = 10.0f;float I = body.getInertia();float mass = body.getMass();float radius = (float) Math.sqrt(2 * I / mass);FrictionJointDef jd = new FrictionJointDef();jd.localAnchorA.set(0, 0);jd.localAnchorB.set(0, 0);jd.bodyA = ground;jd.bodyB = body;jd.collideConnected = true;jd.maxForce = mass * gravity;jd.maxTorque = mass * radius * gravity;world.createJoint(jd);}shape.dispose();}}
public boolean keyDown(int keyCode) {if (keyCode == Keys.W) {Vector2 f = m_body.getWorldVector(tmp.set(0, -200));Vector2 p = m_body.getWorldPoint(tmp.set(0, 2));m_body.applyForce(f, p, true);}if (keyCode == Keys.A)m_body.applyTorque(50, true);if (keyCode == Keys.D)m_body.applyTorque(-50, true);return false;}public ShortArray computeTriangles(FloatArray vertices) {return computeTriangles(vertices.items, 0, vertices.size);}
public ShortArray computeTriangles(float[] vertices) {return computeTriangles(vertices, 0, vertices.length);}
public ShortArray computeTriangles(float[] vertices, int offset, int count) {this.vertices = vertices;int vertexCount = this.vertexCount = count / 2;int vertexOffset = offset / 2;ShortArray indicesArray = this.indicesArray;indicesArray.clear();indicesArray.ensureCapacity(vertexCount);indicesArray.size = vertexCount;short[] indices = this.indices = indicesArray.items;if (areVerticesClockwise(vertices, offset, count)) {for (short i = 0; i < vertexCount; i++) indices[i] = (short) (vertexOffset + i);} else {for (int i = 0, n = vertexCount - 1; i < vertexCount; i++) // Reversed.indices[i] = (short) (vertexOffset + n - i);}IntArray vertexTypes = this.vertexTypes;vertexTypes.clear();vertexTypes.ensureCapacity(vertexCount);for (int i = 0, n = vertexCount; i < n; ++i) vertexTypes.add(classifyVertex(i));// A polygon with n vertices has a triangulation of n-2 triangles.ShortArray triangles = this.triangles;triangles.clear();triangles.ensureCapacity(Math.max(0, vertexCount - 2) * 3);triangulate();return triangles;}
private void triangulate() {int[] vertexTypes = this.vertexTypes.items;while (vertexCount > 3) {int earTipIndex = findEarTip();cutEarTip(earTipIndex);// The type of the two vertices adjacent to the clipped vertex may have changed.int previousIndex = previousIndex(earTipIndex);int nextIndex = earTipIndex == vertexCount ? 0 : earTipIndex;vertexTypes[previousIndex] = classifyVertex(previousIndex);vertexTypes[nextIndex] = classifyVertex(nextIndex);}if (vertexCount == 3) {ShortArray triangles = this.triangles;short[] indices = this.indices;triangles.add(indices[0]);triangles.add(indices[1]);triangles.add(indices[2]);}}
private int classifyVertex(int index) {short[] indices = this.indices;int previous = indices[previousIndex(index)] * 2;int current = indices[index] * 2;int next = indices[nextIndex(index)] * 2;float[] vertices = this.vertices;return computeSpannedAreaSign(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);}
private int findEarTip() {int vertexCount = this.vertexCount;for (int i = 0; i < vertexCount; i++) if (isEarTip(i))return i;// Return a convex or tangential vertex if one exists.int[] vertexTypes = this.vertexTypes.items;for (int i = 0; i < vertexCount; i++) if (vertexTypes[i] != CONCAVE)return i;// If all vertices are concave, just return the first one.return 0;}
private boolean isEarTip(int earTipIndex) {int[] vertexTypes = this.vertexTypes.items;if (vertexTypes[earTipIndex] == CONCAVE)return false;int previousIndex = previousIndex(earTipIndex);int nextIndex = nextIndex(earTipIndex);short[] indices = this.indices;int p1 = indices[previousIndex] * 2;int p2 = indices[earTipIndex] * 2;int p3 = indices[nextIndex] * 2;float[] vertices = this.vertices;float p1x = vertices[p1], p1y = vertices[p1 + 1];float p2x = vertices[p2], p2y = vertices[p2 + 1];float p3x = vertices[p3], p3y = vertices[p3 + 1];// Only consider vertices that are not part of this triangle, or else we'll always find one inside.for (int i = nextIndex(nextIndex); i != previousIndex; i = nextIndex(i)) {// if they coincide with one of the triangle's vertices.if (vertexTypes[i] != CONVEX) {int v = indices[i] * 2;float vx = vertices[v];float vy = vertices[v + 1];// note: check the edge defined by p1->p3 first since this fails _far_ more then the other 2 checks.if (computeSpannedAreaSign(p3x, p3y, p1x, p1y, vx, vy) >= 0) {if (computeSpannedAreaSign(p1x, p1y, p2x, p2y, vx, vy) >= 0) {if (computeSpannedAreaSign(p2x, p2y, p3x, p3y, vx, vy) >= 0)return false;}}}}return true;}
private void cutEarTip(int earTipIndex) {short[] indices = this.indices;ShortArray triangles = this.triangles;triangles.add(indices[previousIndex(earTipIndex)]);triangles.add(indices[earTipIndex]);triangles.add(indices[nextIndex(earTipIndex)]);indicesArray.removeIndex(earTipIndex);vertexTypes.removeIndex(earTipIndex);vertexCount--;}
private int previousIndex(int index) {return (index == 0 ? vertexCount : index) - 1;}
private int nextIndex(int index) {return (index + 1) % vertexCount;}
private static boolean areVerticesClockwise(float[] vertices, int offset, int count) {if (count <= 2)return false;float area = 0, p1x, p1y, p2x, p2y;for (int i = offset, n = offset + count - 3; i < n; i += 2) {p1x = vertices[i];p1y = vertices[i + 1];p2x = vertices[i + 2];p2y = vertices[i + 3];area += p1x * p2y - p2x * p1y;}p1x = vertices[offset + count - 2];p1y = vertices[offset + count - 1];p2x = vertices[offset];p2y = vertices[offset + 1];return area + p1x * p2y - p2x * p1y < 0;}
private static int computeSpannedAreaSign(float p1x, float p1y, float p2x, float p2y, float p3x, float p3y) {float area = p1x * (p3y - p2y);area += p2x * (p1y - p3y);area += p3x * (p2y - p1y);return (int) Math.signum(area);}protected float update(float delta) {if (loopCount != 0 && animation != null) {int loops;final float diff = speed * delta;if (!MathUtils.isZero(duration)) {time += diff;loops = (int) Math.abs(time / duration);if (time < 0f) {loops++;while (time < 0f) time += duration;}time = Math.abs(time % duration);} elseloops = 1;for (int i = 0; i < loops; i++) {if (loopCount > 0)loopCount--;if (loopCount != 0 && listener != null)listener.onLoop(this);if (loopCount == 0) {final float result = ((loops - 1) - i) * duration + (diff < 0f ? duration - time : time);time = (diff < 0f) ? 0f : duration;if (listener != null)listener.onEnd(this);return result;}}return 0f;} elsereturn delta;}
protected AnimationDesc newObject() {return new AnimationDesc();}
private AnimationDesc obtain(final Animation anim, float offset, float duration, int loopCount, float speed, final AnimationListener listener) {if (anim == null)return null;final AnimationDesc result = animationPool.obtain();result.animation = anim;result.listener = listener;result.loopCount = loopCount;result.speed = speed;result.offset = offset;result.duration = duration < 0 ? (anim.duration - offset) : duration;result.time = speed < 0 ? result.duration : 0.f;return result;}
private AnimationDesc obtain(final String id, float offset, float duration, int loopCount, float speed, final AnimationListener listener) {if (id == null)return null;final Animation anim = target.getAnimation(id);if (anim == null)throw new GdxRuntimeException("Unknown animation: " + id);return obtain(anim, offset, duration, loopCount, speed, listener);}
private AnimationDesc obtain(final AnimationDesc anim) {return obtain(anim.animation, anim.offset, anim.duration, anim.loopCount, anim.speed, anim.listener);}
public void update(float delta) {if (paused)return;if (previous != null && ((transitionCurrentTime += delta) >= transitionTargetTime)) {removeAnimation(previous.animation);justChangedAnimation = true;animationPool.free(previous);previous = null;}if (justChangedAnimation) {target.calculateTransforms();justChangedAnimation = false;}if (current == null || current.loopCount == 0 || current.animation == null)return;final float remain = current.update(delta);if (remain != 0f && queued != null) {inAction = false;animate(queued, queuedTransitionTime);queued = null;update(remain);return;}if (previous != null)applyAnimations(previous.animation, previous.offset + previous.time, current.animation, current.offset + current.time, transitionCurrentTime / transitionTargetTime);elseapplyAnimation(current.animation, current.offset + current.time);}
public AnimationDesc setAnimation(final String id) {return setAnimation(id, 1, 1.0f, null);}
public AnimationDesc setAnimation(final String id, int loopCount) {return setAnimation(id, loopCount, 1.0f, null);}
public AnimationDesc setAnimation(final String id, final AnimationListener listener) {return setAnimation(id, 1, 1.0f, listener);}
public AnimationDesc setAnimation(final String id, int loopCount, final AnimationListener listener) {return setAnimation(id, loopCount, 1.0f, listener);}
public AnimationDesc setAnimation(final String id, int loopCount, float speed, final AnimationListener listener) {return setAnimation(id, 0f, -1f, loopCount, speed, listener);}
public AnimationDesc setAnimation(final String id, float offset, float duration, int loopCount, float speed, final AnimationListener listener) {return setAnimation(obtain(id, offset, duration, loopCount, speed, listener));}
protected AnimationDesc setAnimation(final Animation anim, float offset, float duration, int loopCount, float speed, final AnimationListener listener) {return setAnimation(obtain(anim, offset, duration, loopCount, speed, listener));}
protected AnimationDesc setAnimation(final AnimationDesc anim) {if (current == null)current = anim;else {if (!allowSameAnimation && anim != null && current.animation == anim.animation)anim.time = current.time;elseremoveAnimation(current.animation);animationPool.free(current);current = anim;}justChangedAnimation = true;return anim;}
public AnimationDesc animate(final String id, float transitionTime) {return animate(id, 1, 1.0f, null, transitionTime);}
public AnimationDesc animate(final String id, final AnimationListener listener, float transitionTime) {return animate(id, 1, 1.0f, listener, transitionTime);}
public AnimationDesc animate(final String id, int loopCount, final AnimationListener listener, float transitionTime) {return animate(id, loopCount, 1.0f, listener, transitionTime);}
public AnimationDesc animate(final String id, int loopCount, float speed, final AnimationListener listener, float transitionTime) {return animate(id, 0f, -1f, loopCount, speed, listener, transitionTime);}
public AnimationDesc animate(final String id, float offset, float duration, int loopCount, float speed, final AnimationListener listener, float transitionTime) {return animate(obtain(id, offset, duration, loopCount, speed, listener), transitionTime);}
protected AnimationDesc animate(final Animation anim, float offset, float duration, int loopCount, float speed, final AnimationListener listener, float transitionTime) {return animate(obtain(anim, offset, duration, loopCount, speed, listener), transitionTime);}
protected AnimationDesc animate(final AnimationDesc anim, float transitionTime) {if (current == null)current = anim;else if (inAction)queue(anim, transitionTime);else if (!allowSameAnimation && anim != null && current.animation == anim.animation) {anim.time = current.time;animationPool.free(current);current = anim;} else {if (previous != null) {removeAnimation(previous.animation);animationPool.free(previous);}previous = current;current = anim;transitionCurrentTime = 0f;transitionTargetTime = transitionTime;}return anim;}
public AnimationDesc queue(final String id, int loopCount, float speed, final AnimationListener listener, float transitionTime) {return queue(id, 0f, -1f, loopCount, speed, listener, transitionTime);}
public AnimationDesc queue(final String id, float offset, float duration, int loopCount, float speed, final AnimationListener listener, float transitionTime) {return queue(obtain(id, offset, duration, loopCount, speed, listener), transitionTime);}
protected AnimationDesc queue(final Animation anim, float offset, float duration, int loopCount, float speed, final AnimationListener listener, float transitionTime) {return queue(obtain(anim, offset, duration, loopCount, speed, listener), transitionTime);}
protected AnimationDesc queue(final AnimationDesc anim, float transitionTime) {if (current == null || current.loopCount == 0)animate(anim, transitionTime);else {if (queued != null)animationPool.free(queued);queued = anim;queuedTransitionTime = transitionTime;if (current.loopCount < 0)current.loopCount = 1;}return anim;}
public AnimationDesc action(final String id, int loopCount, float speed, final AnimationListener listener, float transitionTime) {return action(id, 0, -1f, loopCount, speed, listener, transitionTime);}
public AnimationDesc action(final String id, float offset, float duration, int loopCount, float speed, final AnimationListener listener, float transitionTime) {return action(obtain(id, offset, duration, loopCount, speed, listener), transitionTime);}
protected AnimationDesc action(final Animation anim, float offset, float duration, int loopCount, float speed, final AnimationListener listener, float transitionTime) {return action(obtain(anim, offset, duration, loopCount, speed, listener), transitionTime);}
protected AnimationDesc action(final AnimationDesc anim, float transitionTime) {if (anim.loopCount < 0)throw new GdxRuntimeException("An action cannot be continuous");if (current == null || current.loopCount == 0)animate(anim, transitionTime);else {AnimationDesc toQueue = inAction ? null : obtain(current);inAction = false;animate(anim, transitionTime);inAction = true;if (toQueue != null)queue(toQueue, transitionTime);}return anim;}public void create() {super.create();instructions = "Tap to shoot\nArrow keys to drive\nR to reset\nLong press to toggle debug mode\nSwipe for next test";final Model chassisModel = objLoader.loadModel(Gdx.files.internal("data/car.obj"));disposables.add(chassisModel);chassisModel.materials.get(0).clear();chassisModel.materials.get(0).set(ColorAttribute.createDiffuse(Color.RED), ColorAttribute.createSpecular(Color.WHITE));final Model wheelModel = objLoader.loadModel(Gdx.files.internal("data/wheel.obj"));disposables.add(wheelModel);wheelModel.materials.get(0).clear();wheelModel.materials.get(0).set(ColorAttribute.createDiffuse(Color.BLACK), ColorAttribute.createSpecular(Color.WHITE), FloatAttribute.createShininess(128));Texture checkboard = new Texture(Gdx.files.internal("data/g3d/checkboard.png"));final Model largeGroundModel = modelBuilder.createBox(1000f, 2f, 1000f, new Material(TextureAttribute.createDiffuse(checkboard), ColorAttribute.createSpecular(Color.WHITE), FloatAttribute.createShininess(16f)), Usage.Position | Usage.Normal | Usage.TextureCoordinates);largeGroundModel.manageDisposable(checkboard);disposables.add(largeGroundModel);world.addConstructor("largeground", new BulletConstructor(largeGroundModel, 0f));BoundingBox bounds = new BoundingBox();Vector3 chassisHalfExtents = chassisModel.calculateBoundingBox(bounds).getDimensions(new Vector3()).scl(0.5f);Vector3 wheelHalfExtents = wheelModel.calculateBoundingBox(bounds).getDimensions(new Vector3()).scl(0.5f);world.addConstructor("chassis", new BulletConstructor(chassisModel, 5f, new btBoxShape(chassisHalfExtents)));world.addConstructor("wheel", new BulletConstructor(wheelModel, 0, null));world.add("largeground", 0, -1f, 0f);chassis = world.add("chassis", 0, 3f, 0);wheels[0] = world.add("wheel", 0, 0, 0);wheels[1] = world.add("wheel", 0, 0, 0);wheels[2] = world.add("wheel", 0, 0, 0);wheels[3] = world.add("wheel", 0, 0, 0);// Create the vehicleraycaster = new btDefaultVehicleRaycaster((btDynamicsWorld) world.collisionWorld);tuning = new btVehicleTuning();vehicle = new btRaycastVehicle(tuning, (btRigidBody) chassis.body, raycaster);chassis.body.setActivationState(Collision.DISABLE_DEACTIVATION);((btDynamicsWorld) world.collisionWorld).addVehicle(vehicle);vehicle.setCoordinateSystem(0, 1, 2);btWheelInfo wheelInfo;Vector3 point = new Vector3();Vector3 direction = new Vector3(0, -1, 0);Vector3 axis = new Vector3(-1, 0, 0);wheelInfo = vehicle.addWheel(point.set(chassisHalfExtents).scl(0.9f, -0.8f, 0.7f), direction, axis, wheelHalfExtents.z * 0.3f, wheelHalfExtents.z, tuning, true);wheelInfo = vehicle.addWheel(point.set(chassisHalfExtents).scl(-0.9f, -0.8f, 0.7f), direction, axis, wheelHalfExtents.z * 0.3f, wheelHalfExtents.z, tuning, true);wheelInfo = vehicle.addWheel(point.set(chassisHalfExtents).scl(0.9f, -0.8f, -0.5f), direction, axis, wheelHalfExtents.z * 0.3f, wheelHalfExtents.z, tuning, false);wheelInfo = vehicle.addWheel(point.set(chassisHalfExtents).scl(-0.9f, -0.8f, -0.5f), direction, axis, wheelHalfExtents.z * 0.3f, wheelHalfExtents.z, tuning, false);}
public void update() {final float delta = Gdx.graphics.getDeltaTime();float angle = currentAngle;if (rightPressed) {if (angle > 0f)angle = 0f;angle = MathUtils.clamp(angle - steerSpeed * delta, -maxAngle, 0f);} else if (leftPressed) {if (angle < 0f)angle = 0f;angle = MathUtils.clamp(angle + steerSpeed * delta, 0f, maxAngle);} elseangle = 0f;if (angle != currentAngle) {currentAngle = angle;vehicle.setSteeringValue(angle * MathUtils.degreesToRadians, 0);vehicle.setSteeringValue(angle * MathUtils.degreesToRadians, 1);}float force = currentForce;if (upPressed) {if (force < 0f)force = 0f;force = MathUtils.clamp(force + acceleration * delta, 0f, maxForce);} else if (downPressed) {if (force > 0f)force = 0f;force = MathUtils.clamp(force - acceleration * delta, -maxForce, 0f);} elseforce = 0f;if (force != currentForce) {currentForce = force;vehicle.applyEngineForce(force, 0);vehicle.applyEngineForce(force, 1);}super.update();for (int i = 0; i < wheels.length; i++) {vehicle.updateWheelTransform(i, true);vehicle.getWheelInfo(i).getWorldTransform().getOpenGLMatrix(wheels[i].transform.val);}chassis.transform.getTranslation(camera.position);tmpV.set(camera.position).sub(5, 0, 5).y = 0f;camera.position.add(tmpV.nor().scl(-6f)).y = 4.f;chassis.transform.getTranslation(tmpV);camera.lookAt(tmpV);camera.up.set(Vector3.Y);camera.update();}
public boolean tap(float x, float y, int count, int button) {shoot(x, y);return true;}
public void dispose() {super.dispose();vehicle.dispose();vehicle = null;raycaster.dispose();raycaster = null;tuning.dispose();tuning = null;}
public boolean keyDown(int keycode) {switch(keycode) {case Keys.DOWN:downPressed = true;break;case Keys.UP:upPressed = true;break;case Keys.LEFT:leftPressed = true;break;case Keys.RIGHT:rightPressed = true;break;}return super.keyDown(keycode);}
public boolean keyUp(int keycode) {switch(keycode) {case Keys.DOWN:downPressed = false;break;case Keys.UP:upPressed = false;break;case Keys.LEFT:leftPressed = false;break;case Keys.RIGHT:rightPressed = false;break;case Keys.R:chassis.body.setWorldTransform(chassis.transform.setToTranslation(0, 5, 0));chassis.body.setInterpolationWorldTransform(chassis.transform);((btRigidBody) (chassis.body)).setLinearVelocity(Vector3.Zero);((btRigidBody) (chassis.body)).setAngularVelocity(Vector3.Zero);chassis.body.activate();break;}return super.keyUp(keycode);}private void initialize(ApplicationListener listener, LwjglApplicationConfiguration config) {LwjglNativesLoader.load();canvas = new Canvas() {
private final Dimension minSize = new Dimension(1, 1);
public final void addNotify() {super.addNotify();if (SharedLibraryLoader.isMac) {EventQueue.invokeLater(new Runnable() {
public void run() {create();}});} elsecreate();}
public final void removeNotify() {stop();super.removeNotify();}
public Dimension getMinimumSize() {return minSize;}};canvas.setSize(1, 1);canvas.setIgnoreRepaint(true);graphics = new LwjglGraphics(canvas, config) {
public void setTitle(String title) {super.setTitle(title);LwjglCanvas.this.setTitle(title);}
public boolean setDisplayMode(int width, int height, boolean fullscreen) {if (!super.setDisplayMode(width, height, fullscreen))return false;if (!fullscreen)LwjglCanvas.this.setDisplayMode(width, height);return true;}
public boolean setDisplayMode(DisplayMode displayMode) {if (!super.setDisplayMode(displayMode))return false;LwjglCanvas.this.setDisplayMode(displayMode.width, displayMode.height);return true;}};graphics.setVSync(config.vSyncEnabled);if (!LwjglApplicationConfiguration.disableAudio)audio = new OpenALAudio();files = new LwjglFiles();input = new LwjglInput();net = new LwjglNet();this.listener = listener;Gdx.app = this;Gdx.graphics = graphics;Gdx.audio = audio;Gdx.files = files;Gdx.input = input;Gdx.net = net;}
public final void addNotify() {super.addNotify();if (SharedLibraryLoader.isMac) {EventQueue.invokeLater(new Runnable() {
public void run() {create();}});} elsecreate();}
public void run() {create();}
public final void removeNotify() {stop();super.removeNotify();}
public Dimension getMinimumSize() {return minSize;}
public void setTitle(String title) {super.setTitle(title);LwjglCanvas.this.setTitle(title);}
public boolean setDisplayMode(int width, int height, boolean fullscreen) {if (!super.setDisplayMode(width, height, fullscreen))return false;if (!fullscreen)LwjglCanvas.this.setDisplayMode(width, height);return true;}
public boolean setDisplayMode(DisplayMode displayMode) {if (!super.setDisplayMode(displayMode))return false;LwjglCanvas.this.setDisplayMode(displayMode.width, displayMode.height);return true;}
protected void setDisplayMode(int width, int height) {}
protected void setTitle(String title) {}
public ApplicationListener getApplicationListener() {return listener;}
public Canvas getCanvas() {return canvas;}
public Audio getAudio() {return audio;}
public Files getFiles() {return files;}
public Graphics getGraphics() {return graphics;}
public Input getInput() {return input;}
public Net getNet() {return net;}
public ApplicationType getType() {return ApplicationType.Desktop;}
public int getVersion() {return 0;}
void create() {try {graphics.setupDisplay();listener.create();listener.resize(Math.max(1, graphics.getWidth()), Math.max(1, graphics.getHeight()));start();} catch (Exception ex) {stopped();exception(ex);return;}EventQueue.invokeLater(new Runnable() {
int lastWidth = Math.max(1, graphics.getWidth());
int lastHeight = Math.max(1, graphics.getHeight());
public void run() {if (!running || Display.isCloseRequested()) {running = false;stopped();return;}try {Display.processMessages();if (cursor != null || !isWindows)canvas.setCursor(cursor);boolean shouldRender = false;int width = Math.max(1, graphics.getWidth());int height = Math.max(1, graphics.getHeight());if (lastWidth != width || lastHeight != height) {lastWidth = width;lastHeight = height;Gdx.gl.glViewport(0, 0, lastWidth, lastHeight);resize(width, height);listener.resize(width, height);shouldRender = true;}if (executeRunnables())shouldRender = true;// If one of the runnables set running to false, for example after an exit().if (!running)return;input.update();shouldRender |= graphics.shouldRender();input.processEvents();if (audio != null)audio.update();if (shouldRender) {graphics.updateTime();graphics.frameId++;listener.render();Display.update(false);}Display.sync(getFrameRate());} catch (Throwable ex) {exception(ex);}EventQueue.invokeLater(this);}});}
public void run() {if (!running || Display.isCloseRequested()) {running = false;stopped();return;}try {Display.processMessages();if (cursor != null || !isWindows)canvas.setCursor(cursor);boolean shouldRender = false;int width = Math.max(1, graphics.getWidth());int height = Math.max(1, graphics.getHeight());if (lastWidth != width || lastHeight != height) {lastWidth = width;lastHeight = height;Gdx.gl.glViewport(0, 0, lastWidth, lastHeight);resize(width, height);listener.resize(width, height);shouldRender = true;}if (executeRunnables())shouldRender = true;// If one of the runnables set running to false, for example after an exit().if (!running)return;input.update();shouldRender |= graphics.shouldRender();input.processEvents();if (audio != null)audio.update();if (shouldRender) {graphics.updateTime();graphics.frameId++;listener.render();Display.update(false);}Display.sync(getFrameRate());} catch (Throwable ex) {exception(ex);}EventQueue.invokeLater(this);}
public boolean executeRunnables() {synchronized (runnables) {for (int i = runnables.size - 1; i >= 0; i--) executedRunnables.addAll(runnables.get(i));runnables.clear();}if (executedRunnables.size == 0)return false;do executedRunnables.pop().run(); while (executedRunnables.size > 0);return true;}
protected int getFrameRate() {int frameRate = Display.isActive() ? graphics.config.foregroundFPS : graphics.config.backgroundFPS;if (frameRate == -1)frameRate = 10;if (frameRate == 0)frameRate = graphics.config.backgroundFPS;if (frameRate == 0)frameRate = 30;return frameRate;}
protected void exception(Throwable ex) {ex.printStackTrace();stop();}
protected void start() {}
protected void resize(int width, int height) {}
protected void stopped() {}
public void stop() {EventQueue.invokeLater(new Runnable() {
public void run() {if (!running)return;running = false;try {Display.destroy();if (audio != null)audio.dispose();} catch (Throwable ignored) {}Array<LifecycleListener> listeners = lifecycleListeners;synchronized (listeners) {for (LifecycleListener listener : listeners) {listener.pause();listener.dispose();}}listener.pause();listener.dispose();}});}
public void run() {if (!running)return;running = false;try {Display.destroy();if (audio != null)audio.dispose();} catch (Throwable ignored) {}Array<LifecycleListener> listeners = lifecycleListeners;synchronized (listeners) {for (LifecycleListener listener : listeners) {listener.pause();listener.dispose();}}listener.pause();listener.dispose();}
public long getJavaHeap() {return Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();}
public long getNativeHeap() {return getJavaHeap();}
public Preferences getPreferences(String name) {if (preferences.containsKey(name)) {return preferences.get(name);} else {Preferences prefs = new LwjglPreferences(name, ".prefs/");preferences.put(name, prefs);return prefs;}}
public Clipboard getClipboard() {return new LwjglClipboard();}
public void postRunnable(Runnable runnable) {synchronized (runnables) {runnables.add(runnable);Gdx.graphics.requestRendering();}}
public void debug(String tag, String message) {if (logLevel >= LOG_DEBUG) {System.out.println(tag + ": " + message);}}
public void debug(String tag, String message, Throwable exception) {if (logLevel >= LOG_DEBUG) {System.out.println(tag + ": " + message);exception.printStackTrace(System.out);}}
public void log(String tag, String message) {if (logLevel >= LOG_INFO) {System.out.println(tag + ": " + message);}}
public void log(String tag, String message, Throwable exception) {if (logLevel >= LOG_INFO) {System.out.println(tag + ": " + message);exception.printStackTrace(System.out);}}
public void error(String tag, String message) {if (logLevel >= LOG_ERROR) {System.err.println(tag + ": " + message);}}
public void error(String tag, String message, Throwable exception) {if (logLevel >= LOG_ERROR) {System.err.println(tag + ": " + message);exception.printStackTrace(System.err);}}
public void setLogLevel(int logLevel) {this.logLevel = logLevel;}
public int getLogLevel() {return logLevel;}
public void exit() {postRunnable(new Runnable() {
@Overridepublic void run() {LwjglCanvas.this.listener.pause();LwjglCanvas.this.listener.dispose();if (audio != null)audio.dispose();System.exit(-1);}});}
public void run() {LwjglCanvas.this.listener.pause();LwjglCanvas.this.listener.dispose();if (audio != null)audio.dispose();System.exit(-1);}
public void setCursor(Cursor cursor) {this.cursor = cursor;}
public void addLifecycleListener(LifecycleListener listener) {synchronized (lifecycleListeners) {lifecycleListeners.add(listener);}}
public void removeLifecycleListener(LifecycleListener listener) {synchronized (lifecycleListeners) {lifecycleListeners.removeValue(listener, true);}}protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(btIDebugDraw obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;LinearMathJNI.delete_btIDebugDraw(swigCPtr);}swigCPtr = 0;}super.delete();}
protected void swigDirectorDisconnect() {swigCMemOwn = false;delete();}
public void swigReleaseOwnership() {swigCMemOwn = false;LinearMathJNI.btIDebugDraw_change_ownership(this, swigCPtr, false);}
public void swigTakeOwnership() {swigCMemOwn = true;LinearMathJNI.btIDebugDraw_change_ownership(this, swigCPtr, true);}
protected void reset(long cPtr, boolean cMemoryOwn) {if (!destroyed)destroy();super.reset(swigCPtr = cPtr, cMemoryOwn);}
public static long getCPtr(DefaultColors obj) {return (obj == null) ? 0 : obj.swigCPtr;}
protected void finalize() {if (!destroyed)destroy();super.finalize();}
protected synchronized void delete() {if (swigCPtr != 0) {if (swigCMemOwn) {swigCMemOwn = false;LinearMathJNI.delete_btIDebugDraw_DefaultColors(swigCPtr);}swigCPtr = 0;}super.delete();}
public void setActiveObject(btVector3 value) {LinearMathJNI.btIDebugDraw_DefaultColors_activeObject_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getActiveObject() {long cPtr = LinearMathJNI.btIDebugDraw_DefaultColors_activeObject_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setDeactivatedObject(btVector3 value) {LinearMathJNI.btIDebugDraw_DefaultColors_deactivatedObject_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getDeactivatedObject() {long cPtr = LinearMathJNI.btIDebugDraw_DefaultColors_deactivatedObject_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setWantsDeactivationObject(btVector3 value) {LinearMathJNI.btIDebugDraw_DefaultColors_wantsDeactivationObject_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getWantsDeactivationObject() {long cPtr = LinearMathJNI.btIDebugDraw_DefaultColors_wantsDeactivationObject_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setDisabledDeactivationObject(btVector3 value) {LinearMathJNI.btIDebugDraw_DefaultColors_disabledDeactivationObject_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getDisabledDeactivationObject() {long cPtr = LinearMathJNI.btIDebugDraw_DefaultColors_disabledDeactivationObject_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setDisabledSimulationObject(btVector3 value) {LinearMathJNI.btIDebugDraw_DefaultColors_disabledSimulationObject_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getDisabledSimulationObject() {long cPtr = LinearMathJNI.btIDebugDraw_DefaultColors_disabledSimulationObject_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setAabb(btVector3 value) {LinearMathJNI.btIDebugDraw_DefaultColors_aabb_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getAabb() {long cPtr = LinearMathJNI.btIDebugDraw_DefaultColors_aabb_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public void setContactPoint(btVector3 value) {LinearMathJNI.btIDebugDraw_DefaultColors_contactPoint_set(swigCPtr, this, btVector3.getCPtr(value), value);}
public btVector3 getContactPoint() {long cPtr = LinearMathJNI.btIDebugDraw_DefaultColors_contactPoint_get(swigCPtr, this);return (cPtr == 0) ? null : new btVector3(cPtr, false);}
public btIDebugDraw.DefaultColors getDefaultColors() {return new btIDebugDraw.DefaultColors((getClass() == btIDebugDraw.class) ? LinearMathJNI.btIDebugDraw_getDefaultColors(swigCPtr, this) : LinearMathJNI.btIDebugDraw_getDefaultColorsSwigExplicitbtIDebugDraw(swigCPtr, this), true);}
public void setDefaultColors(btIDebugDraw.DefaultColors arg0) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_setDefaultColors(swigCPtr, this, btIDebugDraw.DefaultColors.getCPtr(arg0), arg0);elseLinearMathJNI.btIDebugDraw_setDefaultColorsSwigExplicitbtIDebugDraw(swigCPtr, this, btIDebugDraw.DefaultColors.getCPtr(arg0), arg0);}
public void drawLine(Vector3 from, Vector3 to, Vector3 color) {LinearMathJNI.btIDebugDraw_drawLine__SWIG_0(swigCPtr, this, from, to, color);}
public void drawLine(Vector3 from, Vector3 to, Vector3 fromColor, Vector3 toColor) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawLine__SWIG_1(swigCPtr, this, from, to, fromColor, toColor);elseLinearMathJNI.btIDebugDraw_drawLineSwigExplicitbtIDebugDraw__SWIG_1(swigCPtr, this, from, to, fromColor, toColor);}
public void drawSphere(float radius, Matrix4 transform, Vector3 color) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawSphere__SWIG_0(swigCPtr, this, radius, transform, color);elseLinearMathJNI.btIDebugDraw_drawSphereSwigExplicitbtIDebugDraw__SWIG_0(swigCPtr, this, radius, transform, color);}
public void drawSphere(Vector3 p, float radius, Vector3 color) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawSphere__SWIG_1(swigCPtr, this, p, radius, color);elseLinearMathJNI.btIDebugDraw_drawSphereSwigExplicitbtIDebugDraw__SWIG_1(swigCPtr, this, p, radius, color);}
public void drawTriangle(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 arg3, Vector3 arg4, Vector3 arg5, Vector3 color, float alpha) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawTriangle__SWIG_0(swigCPtr, this, v0, v1, v2, arg3, arg4, arg5, color, alpha);elseLinearMathJNI.btIDebugDraw_drawTriangleSwigExplicitbtIDebugDraw__SWIG_0(swigCPtr, this, v0, v1, v2, arg3, arg4, arg5, color, alpha);}
public void drawTriangle(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 color, float arg4) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawTriangle__SWIG_1(swigCPtr, this, v0, v1, v2, color, arg4);elseLinearMathJNI.btIDebugDraw_drawTriangleSwigExplicitbtIDebugDraw__SWIG_1(swigCPtr, this, v0, v1, v2, color, arg4);}
public void drawContactPoint(Vector3 PointOnB, Vector3 normalOnB, float distance, int lifeTime, Vector3 color) {LinearMathJNI.btIDebugDraw_drawContactPoint(swigCPtr, this, PointOnB, normalOnB, distance, lifeTime, color);}
public void reportErrorWarning(String warningString) {LinearMathJNI.btIDebugDraw_reportErrorWarning(swigCPtr, this, warningString);}
public void draw3dText(Vector3 location, String textString) {LinearMathJNI.btIDebugDraw_draw3dText(swigCPtr, this, location, textString);}
public void setDebugMode(int debugMode) {LinearMathJNI.btIDebugDraw_setDebugMode(swigCPtr, this, debugMode);}
public int getDebugMode() {return LinearMathJNI.btIDebugDraw_getDebugMode(swigCPtr, this);}
public void drawAabb(Vector3 from, Vector3 to, Vector3 color) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawAabb(swigCPtr, this, from, to, color);elseLinearMathJNI.btIDebugDraw_drawAabbSwigExplicitbtIDebugDraw(swigCPtr, this, from, to, color);}
public void drawTransform(Matrix4 transform, float orthoLen) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawTransform(swigCPtr, this, transform, orthoLen);elseLinearMathJNI.btIDebugDraw_drawTransformSwigExplicitbtIDebugDraw(swigCPtr, this, transform, orthoLen);}
public void drawArc(Vector3 center, Vector3 normal, Vector3 axis, float radiusA, float radiusB, float minAngle, float maxAngle, Vector3 color, boolean drawSect, float stepDegrees) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawArc__SWIG_0(swigCPtr, this, center, normal, axis, radiusA, radiusB, minAngle, maxAngle, color, drawSect, stepDegrees);elseLinearMathJNI.btIDebugDraw_drawArcSwigExplicitbtIDebugDraw__SWIG_0(swigCPtr, this, center, normal, axis, radiusA, radiusB, minAngle, maxAngle, color, drawSect, stepDegrees);}
public void drawArc(Vector3 center, Vector3 normal, Vector3 axis, float radiusA, float radiusB, float minAngle, float maxAngle, Vector3 color, boolean drawSect) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawArc__SWIG_1(swigCPtr, this, center, normal, axis, radiusA, radiusB, minAngle, maxAngle, color, drawSect);elseLinearMathJNI.btIDebugDraw_drawArcSwigExplicitbtIDebugDraw__SWIG_1(swigCPtr, this, center, normal, axis, radiusA, radiusB, minAngle, maxAngle, color, drawSect);}
public void drawSpherePatch(Vector3 center, Vector3 up, Vector3 axis, float radius, float minTh, float maxTh, float minPs, float maxPs, Vector3 color, float stepDegrees, boolean drawCenter) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawSpherePatch__SWIG_0(swigCPtr, this, center, up, axis, radius, minTh, maxTh, minPs, maxPs, color, stepDegrees, drawCenter);elseLinearMathJNI.btIDebugDraw_drawSpherePatchSwigExplicitbtIDebugDraw__SWIG_0(swigCPtr, this, center, up, axis, radius, minTh, maxTh, minPs, maxPs, color, stepDegrees, drawCenter);}
public void drawSpherePatch(Vector3 center, Vector3 up, Vector3 axis, float radius, float minTh, float maxTh, float minPs, float maxPs, Vector3 color, float stepDegrees) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawSpherePatch__SWIG_1(swigCPtr, this, center, up, axis, radius, minTh, maxTh, minPs, maxPs, color, stepDegrees);elseLinearMathJNI.btIDebugDraw_drawSpherePatchSwigExplicitbtIDebugDraw__SWIG_1(swigCPtr, this, center, up, axis, radius, minTh, maxTh, minPs, maxPs, color, stepDegrees);}
public void drawSpherePatch(Vector3 center, Vector3 up, Vector3 axis, float radius, float minTh, float maxTh, float minPs, float maxPs, Vector3 color) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawSpherePatch__SWIG_2(swigCPtr, this, center, up, axis, radius, minTh, maxTh, minPs, maxPs, color);elseLinearMathJNI.btIDebugDraw_drawSpherePatchSwigExplicitbtIDebugDraw__SWIG_2(swigCPtr, this, center, up, axis, radius, minTh, maxTh, minPs, maxPs, color);}
public void drawBox(Vector3 bbMin, Vector3 bbMax, Vector3 color) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawBox__SWIG_0(swigCPtr, this, bbMin, bbMax, color);elseLinearMathJNI.btIDebugDraw_drawBoxSwigExplicitbtIDebugDraw__SWIG_0(swigCPtr, this, bbMin, bbMax, color);}
public void drawBox(Vector3 bbMin, Vector3 bbMax, Matrix4 trans, Vector3 color) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawBox__SWIG_1(swigCPtr, this, bbMin, bbMax, trans, color);elseLinearMathJNI.btIDebugDraw_drawBoxSwigExplicitbtIDebugDraw__SWIG_1(swigCPtr, this, bbMin, bbMax, trans, color);}
public void drawCapsule(float radius, float halfHeight, int upAxis, Matrix4 transform, Vector3 color) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawCapsule(swigCPtr, this, radius, halfHeight, upAxis, transform, color);elseLinearMathJNI.btIDebugDraw_drawCapsuleSwigExplicitbtIDebugDraw(swigCPtr, this, radius, halfHeight, upAxis, transform, color);}
public void drawCylinder(float radius, float halfHeight, int upAxis, Matrix4 transform, Vector3 color) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawCylinder(swigCPtr, this, radius, halfHeight, upAxis, transform, color);elseLinearMathJNI.btIDebugDraw_drawCylinderSwigExplicitbtIDebugDraw(swigCPtr, this, radius, halfHeight, upAxis, transform, color);}
public void drawCone(float radius, float height, int upAxis, Matrix4 transform, Vector3 color) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawCone(swigCPtr, this, radius, height, upAxis, transform, color);elseLinearMathJNI.btIDebugDraw_drawConeSwigExplicitbtIDebugDraw(swigCPtr, this, radius, height, upAxis, transform, color);}
public void drawPlane(Vector3 planeNormal, float planeConst, Matrix4 transform, Vector3 color) {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_drawPlane(swigCPtr, this, planeNormal, planeConst, transform, color);elseLinearMathJNI.btIDebugDraw_drawPlaneSwigExplicitbtIDebugDraw(swigCPtr, this, planeNormal, planeConst, transform, color);}
public void flushLines() {if (getClass() == btIDebugDraw.class)LinearMathJNI.btIDebugDraw_flushLines(swigCPtr, this);elseLinearMathJNI.btIDebugDraw_flushLinesSwigExplicitbtIDebugDraw(swigCPtr, this);}public void create() {spriteBatch = new SpriteBatch();// font = new BitmapFont(Gdx.files.internal("data/verdana39.fnt"), false);font = new BitmapFont(Gdx.files.internal("data/arial-32-pad.fnt"), false);// font = new FreeTypeFontGenerator(Gdx.files.internal("data/arial.ttf")).generateFont(new FreeTypeFontParameter());font.getData().markupEnabled = true;font.getData().breakChars = new char[] { '-' };multiPageFont = new BitmapFont(Gdx.files.internal("data/multipagefont.fnt"));// Add user defined colorColors.put("PERU", Color.valueOf("CD853F"));renderer = new ShapeRenderer();renderer.setProjectionMatrix(spriteBatch.getProjectionMatrix());stage = new Stage(new ScreenViewport());Skin skin = new Skin(Gdx.files.internal("data/uiskin.json"));BitmapFont labelFont = skin.get("default-font", BitmapFont.class);labelFont.getData().markupEnabled = true;// They are silently ignored, as expected.label = new Label("<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][] [Unknown Color]>>", skin);label.setPosition(100, 200);stage.addActor(label);Window window = new Window("[RED]Multicolor[GREEN] Title", skin);window.setPosition(400, 300);window.pack();stage.addActor(window);layout = new GlyphLayout();}
public void render() {int viewHeight = Gdx.graphics.getHeight();Gdx.gl.glClearColor(0, 0, 0, 1);Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);// Test wrapping or truncation with the font directly.if (!true) {// BitmapFont font = label.getStyle().font;BitmapFont font = this.font;font.getRegion().getTexture().setFilter(TextureFilter.Nearest, TextureFilter.Nearest);font.getData().setScale(2f);renderer.begin(ShapeRenderer.ShapeType.Line);renderer.setColor(0, 1, 0, 1);float w = Gdx.input.getX();// w = 855;renderer.rect(10, 10, w, 500);renderer.end();spriteBatch.begin();String text = "your new";text = "How quickly [RED]daft jumping zebras vex.";// text = "Another font wrap is-sue, this time withmultiple whitespace characters.";text = "test with AGWlWi  AGWlWi issue";if (true) {// Test wrap.layout.setText(font, text, 0, text.length(), font.getColor(), w, Align.center, true, null);} else {// Test truncation.layout.setText(font, text, 0, text.length(), font.getColor(), w, Align.center, false, "...");}float meowy = (500 / 2 + layout.height / 2 + 5);font.draw(spriteBatch, layout, 10, 10 + meowy);spriteBatch.end();renderer.begin(ShapeRenderer.ShapeType.Line);renderer.setColor(0, 1, 0, 1);for (int i = 0, n = layout.runs.size; i < n; i++) {GlyphRun r = layout.runs.get(i);renderer.rect(10 + r.x, 10 + meowy + r.y, r.width, -font.getLineHeight());}renderer.end();font.getData().setScale(1f);return;}// Test wrapping with label.if (false) {label.debug();label.getStyle().font = font;label.setStyle(label.getStyle());label.setText("How quickly [RED]daft[] jumping zebras vex.");label.setWrap(true);//label.setEllipsis(true);label.setAlignment(Align.center, Align.right);label.setWidth(Gdx.input.getX() - label.getX());label.setHeight(label.getPrefHeight());} else {// Test various font features.spriteBatch.begin();String text = "Sphinx of black quartz, judge my vow.";font.setColor(Color.RED);float x = 100, y = 20;float alignmentWidth;if (false) {alignmentWidth = 0;font.draw(spriteBatch, text, x, viewHeight - y, alignmentWidth, Align.right, false);}if (true) {alignmentWidth = 280;font.draw(spriteBatch, text, x, viewHeight - y, alignmentWidth, Align.right, true);}font.draw(spriteBatch, "[", 50, 60, 100, Align.left, true);font.getData().markupEnabled = true;font.draw(spriteBatch, "[", 100, 60, 100, Align.left, true);font.getData().markupEnabled = false;// 'R' and 'p' are in different pagesString txt2 = "this font uses " + multiPageFont.getRegions().size + " texture pages: RpRpRpRpRpNM";spriteBatch.renderCalls = 0;// regular draw functionmultiPageFont.setColor(Color.BLUE);multiPageFont.draw(spriteBatch, txt2, 10, 100);// expert usage.. drawing with bitmap font cacheBitmapFontCache cache = multiPageFont.getCache();cache.clear();cache.setColor(Color.BLACK);cache.setText(txt2, 10, 50);cache.setColors(Color.PINK, 3, 6);cache.setColors(Color.ORANGE, 9, 12);cache.setColors(Color.GREEN, 16, txt2.length());cache.draw(spriteBatch, 5, txt2.length() - 5);cache.clear();cache.setColor(Color.BLACK);float textX = 10;textX += cache.setText("[black] ", textX, 150).width;multiPageFont.getData().markupEnabled = true;textX += cache.addText("[[[PINK]pink[]] ", textX, 150).width;textX += cache.addText("[PERU][[peru] ", textX, 150).width;cache.setColor(Color.GREEN);textX += cache.addText("green ", textX, 150).width;textX += cache.addText("[#A52A2A]br[#A52A2ADF]ow[#A52A2ABF]n f[#A52A2A9F]ad[#A52A2A7F]in[#A52A2A5F]g o[#A52A2A3F]ut ", textX, 150).width;multiPageFont.getData().markupEnabled = false;cache.draw(spriteBatch);// tintingcache.tint(new Color(1f, 1f, 1f, 0.3f));cache.translate(0f, 40f);cache.draw(spriteBatch);spriteBatch.end();renderer.begin(ShapeType.Line);renderer.setColor(Color.BLACK);renderer.rect(x, viewHeight - y - 200, alignmentWidth, 200);renderer.end();}stage.act(Gdx.graphics.getDeltaTime());stage.draw();}
public void resize(int width, int height) {spriteBatch.getProjectionMatrix().setToOrtho2D(0, 0, width, height);renderer.setProjectionMatrix(spriteBatch.getProjectionMatrix());stage.getViewport().update(width, height, true);}
public void dispose() {spriteBatch.dispose();renderer.dispose();font.dispose();// Restore predefined colorsColors.reset();}public FloatArray computePolygon(FloatArray points, boolean sorted) {return computePolygon(points.items, 0, points.size, sorted);}
public FloatArray computePolygon(float[] polygon, boolean sorted) {return computePolygon(polygon, 0, polygon.length, sorted);}
public FloatArray computePolygon(float[] points, int offset, int count, boolean sorted) {int end = offset + count;if (!sorted) {if (sortedPoints == null || sortedPoints.length < count)sortedPoints = new float[count];System.arraycopy(points, offset, sortedPoints, 0, count);points = sortedPoints;offset = 0;sort(points, count);}FloatArray hull = this.hull;hull.clear();// Lower hull.for (int i = offset; i < end; i += 2) {float x = points[i];float y = points[i + 1];while (hull.size >= 4 && ccw(x, y) <= 0) hull.size -= 2;hull.add(x);hull.add(y);}// Upper hull.for (int i = end - 4, t = hull.size + 2; i >= offset; i -= 2) {float x = points[i];float y = points[i + 1];while (hull.size >= t && ccw(x, y) <= 0) hull.size -= 2;hull.add(x);hull.add(y);}return hull;}
public IntArray computeIndices(FloatArray points, boolean sorted, boolean yDown) {return computeIndices(points.items, 0, points.size, sorted, yDown);}
public IntArray computeIndices(float[] polygon, boolean sorted, boolean yDown) {return computeIndices(polygon, 0, polygon.length, sorted, yDown);}
public IntArray computeIndices(float[] points, int offset, int count, boolean sorted, boolean yDown) {int end = offset + count;if (!sorted) {if (sortedPoints == null || sortedPoints.length < count)sortedPoints = new float[count];System.arraycopy(points, offset, sortedPoints, 0, count);points = sortedPoints;offset = 0;sortWithIndices(points, count, yDown);}IntArray indices = this.indices;indices.clear();FloatArray hull = this.hull;hull.clear();// Lower hull.for (int i = offset, index = i / 2; i < end; i += 2, index++) {float x = points[i];float y = points[i + 1];while (hull.size >= 4 && ccw(x, y) <= 0) {hull.size -= 2;indices.size--;}hull.add(x);hull.add(y);indices.add(index);}// Upper hull.for (int i = end - 4, index = i / 2, t = hull.size + 2; i >= offset; i -= 2, index--) {float x = points[i];float y = points[i + 1];while (hull.size >= t && ccw(x, y) <= 0) {hull.size -= 2;indices.size--;}hull.add(x);hull.add(y);indices.add(index);}// Convert sorted to unsorted indices.if (!sorted) {short[] originalIndicesArray = originalIndices.items;int[] indicesArray = indices.items;for (int i = 0, n = indices.size; i < n; i++) indicesArray[i] = originalIndicesArray[indicesArray[i]];}return indices;}
private float ccw(float p3x, float p3y) {FloatArray hull = this.hull;int size = hull.size;float p1x = hull.get(size - 4);float p1y = hull.get(size - 3);float p2x = hull.get(size - 2);float p2y = hull.peek();return (p2x - p1x) * (p3y - p1y) - (p2y - p1y) * (p3x - p1x);}
private void sort(float[] values, int count) {int lower = 0;int upper = count - 1;IntArray stack = quicksortStack;stack.add(lower);stack.add(upper - 1);while (stack.size > 0) {upper = stack.pop();lower = stack.pop();if (upper <= lower)continue;int i = quicksortPartition(values, lower, upper);if (i - lower > upper - i) {stack.add(lower);stack.add(i - 2);}stack.add(i + 2);stack.add(upper);if (upper - i >= i - lower) {stack.add(lower);stack.add(i - 2);}}}
private int quicksortPartition(final float[] values, int lower, int upper) {float x = values[lower];float y = values[lower + 1];int up = upper;int down = lower;float temp;short tempIndex;while (down < up) {while (down < up && values[down] <= x) down = down + 2;while (values[up] > x || (values[up] == x && values[up + 1] < y)) up = up - 2;if (down < up) {temp = values[down];values[down] = values[up];values[up] = temp;temp = values[down + 1];values[down + 1] = values[up + 1];values[up + 1] = temp;}}values[lower] = values[up];values[up] = x;values[lower + 1] = values[up + 1];values[up + 1] = y;return up;}
private void sortWithIndices(float[] values, int count, boolean yDown) {int pointCount = count / 2;originalIndices.clear();originalIndices.ensureCapacity(pointCount);short[] originalIndicesArray = originalIndices.items;for (short i = 0; i < pointCount; i++) originalIndicesArray[i] = i;int lower = 0;int upper = count - 1;IntArray stack = quicksortStack;stack.add(lower);stack.add(upper - 1);while (stack.size > 0) {upper = stack.pop();lower = stack.pop();if (upper <= lower)continue;int i = quicksortPartitionWithIndices(values, lower, upper, yDown, originalIndicesArray);if (i - lower > upper - i) {stack.add(lower);stack.add(i - 2);}stack.add(i + 2);stack.add(upper);if (upper - i >= i - lower) {stack.add(lower);stack.add(i - 2);}}}
private int quicksortPartitionWithIndices(final float[] values, int lower, int upper, boolean yDown, short[] originalIndices) {float x = values[lower];float y = values[lower + 1];int up = upper;int down = lower;float temp;short tempIndex;while (down < up) {while (down < up && values[down] <= x) down = down + 2;if (yDown) {while (values[up] > x || (values[up] == x && values[up + 1] < y)) up = up - 2;} else {while (values[up] > x || (values[up] == x && values[up + 1] > y)) up = up - 2;}if (down < up) {temp = values[down];values[down] = values[up];values[up] = temp;temp = values[down + 1];values[down + 1] = values[up + 1];values[up + 1] = temp;tempIndex = originalIndices[down / 2];originalIndices[down / 2] = originalIndices[up / 2];originalIndices[up / 2] = tempIndex;}}values[lower] = values[up];values[up] = x;values[lower + 1] = values[up + 1];values[up + 1] = y;tempIndex = originalIndices[lower / 2];originalIndices[lower / 2] = originalIndices[up / 2];originalIndices[up / 2] = tempIndex;return up;}public void run() {justTouched = false;if (keyJustPressed) {keyJustPressed = false;for (int i = 0; i < justPressedKeys.length; i++) {justPressedKeys[i] = false;}}if (processor != null) {if (touchEvent != null) {touchX[touchEvent.pointer] = touchEvent.x;touchY[touchEvent.pointer] = touchEvent.y;switch(touchEvent.type) {case TouchEvent.TOUCH_DOWN:processor.touchDown(touchEvent.x, touchEvent.y, touchEvent.pointer, Input.Buttons.LEFT);isTouched[touchEvent.pointer] = true;justTouched = true;break;case TouchEvent.TOUCH_UP:processor.touchUp(touchEvent.x, touchEvent.y, touchEvent.pointer, Input.Buttons.LEFT);isTouched[touchEvent.pointer] = false;break;case TouchEvent.TOUCH_DRAGGED:processor.touchDragged(touchEvent.x, touchEvent.y, touchEvent.pointer);break;}}if (keyEvent != null) {switch(keyEvent.type) {case KeyEvent.KEY_DOWN:processor.keyDown(keyEvent.keyCode);if (!keys[keyEvent.keyCode]) {keyCount++;keys[keyEvent.keyCode] = true;}keyJustPressed = true;justPressedKeys[keyEvent.keyCode] = true;break;case KeyEvent.KEY_UP:processor.keyUp(keyEvent.keyCode);if (keys[keyEvent.keyCode]) {keyCount--;keys[keyEvent.keyCode] = false;}break;case KeyEvent.KEY_TYPED:processor.keyTyped(keyEvent.keyChar);break;}}} else {if (touchEvent != null) {touchX[touchEvent.pointer] = touchEvent.x;touchY[touchEvent.pointer] = touchEvent.y;if (touchEvent.type == TouchEvent.TOUCH_DOWN) {isTouched[touchEvent.pointer] = true;justTouched = true;}if (touchEvent.type == TouchEvent.TOUCH_UP) {isTouched[touchEvent.pointer] = false;}}if (keyEvent != null) {if (keyEvent.type == KeyEvent.KEY_DOWN) {if (!keys[keyEvent.keyCode]) {keyCount++;keys[keyEvent.keyCode] = true;}keyJustPressed = true;justPressedKeys[keyEvent.keyCode] = true;}if (keyEvent.type == KeyEvent.KEY_UP) {if (keys[keyEvent.keyCode]) {keyCount--;keys[keyEvent.keyCode] = false;}}}}}
public void run() {while (true) {try {connected = false;if (listener != null)listener.onDisconnected();System.out.println("listening, port " + port);Socket socket = null;socket = serverSocket.accept();socket.setTcpNoDelay(true);socket.setSoTimeout(3000);connected = true;if (listener != null)listener.onConnected();DataInputStream in = new DataInputStream(socket.getInputStream());multiTouch = in.readBoolean();while (true) {int event = in.readInt();KeyEvent keyEvent = null;TouchEvent touchEvent = null;switch(event) {case RemoteSender.ACCEL:accel[0] = in.readFloat();accel[1] = in.readFloat();accel[2] = in.readFloat();break;case RemoteSender.COMPASS:compass[0] = in.readFloat();compass[1] = in.readFloat();compass[2] = in.readFloat();break;case RemoteSender.SIZE:remoteWidth = in.readFloat();remoteHeight = in.readFloat();break;case RemoteSender.KEY_DOWN:keyEvent = new KeyEvent();keyEvent.keyCode = in.readInt();keyEvent.type = KeyEvent.KEY_DOWN;break;case RemoteSender.KEY_UP:keyEvent = new KeyEvent();keyEvent.keyCode = in.readInt();keyEvent.type = KeyEvent.KEY_UP;break;case RemoteSender.KEY_TYPED:keyEvent = new KeyEvent();keyEvent.keyChar = in.readChar();keyEvent.type = KeyEvent.KEY_TYPED;break;case RemoteSender.TOUCH_DOWN:touchEvent = new TouchEvent();touchEvent.x = (int) ((in.readInt() / remoteWidth) * Gdx.graphics.getWidth());touchEvent.y = (int) ((in.readInt() / remoteHeight) * Gdx.graphics.getHeight());touchEvent.pointer = in.readInt();touchEvent.type = TouchEvent.TOUCH_DOWN;break;case RemoteSender.TOUCH_UP:touchEvent = new TouchEvent();touchEvent.x = (int) ((in.readInt() / remoteWidth) * Gdx.graphics.getWidth());touchEvent.y = (int) ((in.readInt() / remoteHeight) * Gdx.graphics.getHeight());touchEvent.pointer = in.readInt();touchEvent.type = TouchEvent.TOUCH_UP;break;case RemoteSender.TOUCH_DRAGGED:touchEvent = new TouchEvent();touchEvent.x = (int) ((in.readInt() / remoteWidth) * Gdx.graphics.getWidth());touchEvent.y = (int) ((in.readInt() / remoteHeight) * Gdx.graphics.getHeight());touchEvent.pointer = in.readInt();touchEvent.type = TouchEvent.TOUCH_DRAGGED;break;}Gdx.app.postRunnable(new EventTrigger(touchEvent, keyEvent));}} catch (IOException e) {e.printStackTrace();}}}
public boolean isConnected() {return connected;}
public float getAccelerometerX() {return accel[0];}
public float getAccelerometerY() {return accel[1];}
public float getAccelerometerZ() {return accel[2];}
public int getX() {return touchX[0];}
public int getX(int pointer) {return touchX[pointer];}
public int getY() {return touchY[0];}
public int getY(int pointer) {return touchY[pointer];}
public boolean isTouched() {return isTouched[0];}
public boolean justTouched() {return justTouched;}
public boolean isTouched(int pointer) {return isTouched[pointer];}
public boolean isButtonPressed(int button) {if (button != Buttons.LEFT)return false;for (int i = 0; i < isTouched.length; i++) if (isTouched[i])return true;return false;}
public boolean isKeyPressed(int key) {if (key == Input.Keys.ANY_KEY) {return keyCount > 0;}if (key < 0 || key > 255) {return false;}return keys[key];}
public boolean isKeyJustPressed(int key) {if (key == Input.Keys.ANY_KEY) {return keyJustPressed;}if (key < 0 || key > 255) {return false;}return justPressedKeys[key];}
public void getTextInput(TextInputListener listener, String title, String text, String hint) {Gdx.app.getInput().getTextInput(listener, title, text, hint);}
public void setOnscreenKeyboardVisible(boolean visible) {}
public void vibrate(int milliseconds) {}
public void vibrate(long[] pattern, int repeat) {}
public void cancelVibrate() {}
public float getAzimuth() {return compass[0];}
public float getPitch() {return compass[1];}
public float getRoll() {return compass[2];}
public void setCatchBackKey(boolean catchBack) {}
public boolean isCatchBackKey() {return false;}
public void setCatchMenuKey(boolean catchMenu) {}
public boolean isCatchMenuKey() {return false;}
public void setInputProcessor(InputProcessor processor) {this.processor = processor;}
public InputProcessor getInputProcessor() {return this.processor;}
public String[] getIPs() {return ips;}
public boolean isPeripheralAvailable(Peripheral peripheral) {if (peripheral == Peripheral.Accelerometer)return true;if (peripheral == Peripheral.Compass)return true;if (peripheral == Peripheral.MultitouchScreen)return multiTouch;return false;}
public int getRotation() {return 0;}
public Orientation getNativeOrientation() {return Orientation.Landscape;}
public void setCursorCatched(boolean catched) {}
public boolean isCursorCatched() {return false;}
public int getDeltaX() {// TODO Auto-generated method stubreturn 0;}
public int getDeltaX(int pointer) {return 0;}
public int getDeltaY() {return 0;}
public int getDeltaY(int pointer) {return 0;}
public void setCursorPosition(int x, int y) {}
public long getCurrentEventTime() {// TODO Auto-generated method stubreturn 0;}
public void getRotationMatrix(float[] matrix) {}protected void initialize() {super.initialize();writeEnters = true;linesBreak = new IntArray();cursorLine = 0;firstLineShowing = 0;moveOffset = -1;linesShowing = 0;}
protected int letterUnderCursor(float x) {if (linesBreak.size > 0) {if (cursorLine * 2 >= linesBreak.size) {return text.length();} else {int start = linesBreak.items[cursorLine * 2];int end = linesBreak.items[cursorLine * 2 + 1];int i = start;boolean found = false;while (i <= end && !found) {if (glyphPositions.items[i] - glyphPositions.items[start] > x) {found = true;} else {i++;}}return Math.max(0, i - 1);}} else {return 0;}}
public void setPrefRows(float prefRows) {this.prefRows = prefRows;}
public float getPrefHeight() {if (prefRows <= 0) {return super.getPrefHeight();} else {float prefHeight = textHeight * prefRows;if (style.background != null) {prefHeight = Math.max(prefHeight + style.background.getBottomHeight() + style.background.getTopHeight(), style.background.getMinHeight());}return prefHeight;}}
public int getLines() {return linesBreak.size / 2 + (newLineAtEnd() ? 1 : 0);}
public boolean newLineAtEnd() {return text.length() != 0 && (text.charAt(text.length() - 1) == ENTER_ANDROID || text.charAt(text.length() - 1) == ENTER_DESKTOP);}
public void moveCursorLine(int line) {if (line < 0) {cursorLine = 0;cursor = 0;moveOffset = -1;} else if (line >= getLines()) {int newLine = getLines() - 1;cursor = text.length();if (line > getLines() || newLine == cursorLine) {moveOffset = -1;}cursorLine = newLine;} else if (line != cursorLine) {if (moveOffset < 0) {moveOffset = linesBreak.size <= cursorLine * 2 ? 0 : glyphPositions.get(cursor) - glyphPositions.get(linesBreak.get(cursorLine * 2));}cursorLine = line;cursor = cursorLine * 2 >= linesBreak.size ? text.length() : linesBreak.get(cursorLine * 2);while (cursor < text.length() && cursor <= linesBreak.get(cursorLine * 2 + 1) - 1 && glyphPositions.get(cursor) - glyphPositions.get(linesBreak.get(cursorLine * 2)) < moveOffset) {cursor++;}showCursor();}}
void updateCurrentLine() {int index = calculateCurrentLineIndex(cursor);int line = index / 2;// wider than the boxif (index % 2 == 0 || index + 1 >= linesBreak.size || cursor != linesBreak.items[index] || linesBreak.items[index + 1] != linesBreak.items[index]) {if (line < linesBreak.size / 2 || text.length() == 0 || text.charAt(text.length() - 1) == ENTER_ANDROID || text.charAt(text.length() - 1) == ENTER_DESKTOP) {cursorLine = line;}}}
void showCursor() {updateCurrentLine();if (cursorLine != firstLineShowing) {int step = cursorLine >= firstLineShowing ? 1 : -1;while (firstLineShowing > cursorLine || firstLineShowing + linesShowing - 1 < cursorLine) {firstLineShowing += step;}}}
private int calculateCurrentLineIndex(int cursor) {int index = 0;while (index < linesBreak.size && cursor > linesBreak.items[index]) {index++;}return index;}
protected void sizeChanged() {// Cause calculateOffsets to recalculate the line breaks.lastText = null;// The number of lines showed must be updated whenever the height is updatedBitmapFont font = style.font;Drawable background = style.background;float availableHeight = getHeight() - (background == null ? 0 : background.getBottomHeight() + background.getTopHeight());linesShowing = (int) Math.floor(availableHeight / font.getLineHeight());}
protected float getTextY(BitmapFont font, Drawable background) {float textY = getHeight();if (background != null) {textY = (int) (textY - background.getTopHeight());}return textY;}
protected void drawSelection(Drawable selection, Batch batch, BitmapFont font, float x, float y) {int i = firstLineShowing * 2;float offsetY = 0;int minIndex = Math.min(cursor, selectionStart);int maxIndex = Math.max(cursor, selectionStart);while (i + 1 < linesBreak.size && i < (firstLineShowing + linesShowing) * 2) {int lineStart = linesBreak.get(i);int lineEnd = linesBreak.get(i + 1);if (!((minIndex < lineStart && minIndex < lineEnd && maxIndex < lineStart && maxIndex < lineEnd) || (minIndex > lineStart && minIndex > lineEnd && maxIndex > lineStart && maxIndex > lineEnd))) {int start = Math.max(linesBreak.get(i), minIndex);int end = Math.min(linesBreak.get(i + 1), maxIndex);float selectionX = glyphPositions.get(start) - glyphPositions.get(linesBreak.get(i));float selectionWidth = glyphPositions.get(end) - glyphPositions.get(start);selection.draw(batch, x + selectionX + fontOffset, y - textHeight - font.getDescent() - offsetY, selectionWidth, font.getLineHeight());}offsetY += font.getLineHeight();i += 2;}}
protected void drawText(Batch batch, BitmapFont font, float x, float y) {float offsetY = 0;for (int i = firstLineShowing * 2; i < (firstLineShowing + linesShowing) * 2 && i < linesBreak.size; i += 2) {font.draw(batch, displayText, x, y + offsetY, linesBreak.items[i], linesBreak.items[i + 1], 0, Align.left, false);offsetY -= font.getLineHeight();}}
protected void drawCursor(Drawable cursorPatch, Batch batch, BitmapFont font, float x, float y) {float textOffset = cursor >= glyphPositions.size || cursorLine * 2 >= linesBreak.size ? 0 : glyphPositions.get(cursor) - glyphPositions.get(linesBreak.items[cursorLine * 2]);cursorPatch.draw(batch, x + textOffset + fontOffset + font.getData().cursorX, y - font.getDescent() / 2 - (cursorLine - firstLineShowing + 1) * font.getLineHeight(), cursorPatch.getMinWidth(), font.getLineHeight());}
protected void calculateOffsets() {super.calculateOffsets();if (!this.text.equals(lastText)) {this.lastText = text;BitmapFont font = style.font;float maxWidthLine = this.getWidth() - (style.background != null ? style.background.getLeftWidth() + style.background.getRightWidth() : 0);linesBreak.clear();int lineStart = 0;int lastSpace = 0;char lastCharacter;Pool<GlyphLayout> layoutPool = Pools.get(GlyphLayout.class);GlyphLayout layout = layoutPool.obtain();for (int i = 0; i < text.length(); i++) {lastCharacter = text.charAt(i);if (lastCharacter == ENTER_DESKTOP || lastCharacter == ENTER_ANDROID) {linesBreak.add(lineStart);linesBreak.add(i);lineStart = i + 1;} else {lastSpace = (continueCursor(i, 0) ? lastSpace : i);layout.setText(font, text.subSequence(lineStart, i + 1));if (layout.width > maxWidthLine) {if (lineStart >= lastSpace) {lastSpace = i - 1;}linesBreak.add(lineStart);linesBreak.add(lastSpace + 1);lineStart = lastSpace + 1;lastSpace = lineStart;}}}layoutPool.free(layout);// Add last lineif (lineStart < text.length()) {linesBreak.add(lineStart);linesBreak.add(text.length());}showCursor();}}
protected InputListener createInputListener() {return new TextAreaListener();}
public void setSelection(int selectionStart, int selectionEnd) {super.setSelection(selectionStart, selectionEnd);updateCurrentLine();}
protected void moveCursor(boolean forward, boolean jump) {int count = forward ? 1 : -1;int index = (cursorLine * 2) + count;if (index >= 0 && index + 1 < linesBreak.size && linesBreak.items[index] == cursor && linesBreak.items[index + 1] == cursor) {cursorLine += count;if (jump) {super.moveCursor(forward, jump);}showCursor();} else {super.moveCursor(forward, jump);}updateCurrentLine();}
protected boolean continueCursor(int index, int offset) {int pos = calculateCurrentLineIndex(index + offset);return super.continueCursor(index, offset) && (pos < 0 || pos >= linesBreak.size - 2 || (linesBreak.items[pos + 1] != index) || (linesBreak.items[pos + 1] == linesBreak.items[pos + 2]));}
public int getCursorLine() {return cursorLine;}
public int getFirstLineShowing() {return firstLineShowing;}
public int getLinesShowing() {return linesShowing;}
protected void setCursorPosition(float x, float y) {moveOffset = -1;Drawable background = style.background;BitmapFont font = style.font;float height = getHeight();if (background != null) {height -= background.getTopHeight();x -= background.getLeftWidth();}x = Math.max(0, x);if (background != null) {y -= background.getTopHeight();}cursorLine = (int) Math.floor((height - y) / font.getLineHeight()) + firstLineShowing;cursorLine = Math.max(0, Math.min(cursorLine, getLines() - 1));super.setCursorPosition(x, y);updateCurrentLine();}
public boolean keyDown(InputEvent event, int keycode) {super.keyDown(event, keycode);Stage stage = getStage();if (stage != null && stage.getKeyboardFocus() == TextArea.this) {boolean repeat = false;boolean shift = Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT);if (keycode == Input.Keys.DOWN) {if (shift) {if (!hasSelection) {selectionStart = cursor;hasSelection = true;}} else {clearSelection();}moveCursorLine(cursorLine + 1);repeat = true;} else if (keycode == Input.Keys.UP) {if (shift) {if (!hasSelection) {selectionStart = cursor;hasSelection = true;}} else {clearSelection();}moveCursorLine(cursorLine - 1);repeat = true;} else {moveOffset = -1;}if (repeat) {scheduleKeyRepeatTask(keycode);}showCursor();return true;}return false;}
public boolean keyTyped(InputEvent event, char character) {boolean result = super.keyTyped(event, character);showCursor();return result;}
protected void goHome(boolean jump) {if (jump) {cursor = 0;} else if (cursorLine * 2 < linesBreak.size) {cursor = linesBreak.get(cursorLine * 2);}}
protected void goEnd(boolean jump) {if (jump || cursorLine >= getLines()) {cursor = text.length();} else if (cursorLine * 2 + 1 < linesBreak.size) {cursor = linesBreak.get(cursorLine * 2 + 1);}}private void compileShaders(String vertexShader, String fragmentShader) {vertexShaderHandle = loadShader(GL20.GL_VERTEX_SHADER, vertexShader);fragmentShaderHandle = loadShader(GL20.GL_FRAGMENT_SHADER, fragmentShader);if (vertexShaderHandle == -1 || fragmentShaderHandle == -1) {isCompiled = false;return;}program = linkProgram(createProgram());if (program == -1) {isCompiled = false;return;}isCompiled = true;}
private int loadShader(int type, String source) {GL20 gl = Gdx.gl20;IntBuffer intbuf = BufferUtils.newIntBuffer(1);int shader = gl.glCreateShader(type);if (shader == 0)return -1;gl.glShaderSource(shader, source);gl.glCompileShader(shader);gl.glGetShaderiv(shader, GL20.GL_COMPILE_STATUS, intbuf);int compiled = intbuf.get(0);if (compiled == 0) {// if (infoLogLength > 1) {String infoLog = gl.glGetShaderInfoLog(shader);log += infoLog;// }return -1;}return shader;}
protected int createProgram() {GL20 gl = Gdx.gl20;int program = gl.glCreateProgram();return program != 0 ? program : -1;}
private int linkProgram(int program) {GL20 gl = Gdx.gl20;if (program == -1)return -1;gl.glAttachShader(program, vertexShaderHandle);gl.glAttachShader(program, fragmentShaderHandle);gl.glLinkProgram(program);ByteBuffer tmp = ByteBuffer.allocateDirect(4);tmp.order(ByteOrder.nativeOrder());IntBuffer intbuf = tmp.asIntBuffer();gl.glGetProgramiv(program, GL20.GL_LINK_STATUS, intbuf);int linked = intbuf.get(0);if (linked == 0) {// if (infoLogLength > 1) {log = Gdx.gl20.glGetProgramInfoLog(program);// }return -1;}return program;}
public String getLog() {if (isCompiled) {// if (infoLogLength > 1) {log = Gdx.gl20.glGetProgramInfoLog(program);// }return log;} else {return log;}}
public boolean isCompiled() {return isCompiled;}
private int fetchAttributeLocation(String name) {GL20 gl = Gdx.gl20;// -1 == cached but not foundint location;if ((location = attributes.get(name, -2)) == -2) {location = gl.glGetAttribLocation(program, name);attributes.put(name, location);}return location;}
private int fetchUniformLocation(String name) {return fetchUniformLocation(name, pedantic);}
public int fetchUniformLocation(String name, boolean pedantic) {GL20 gl = Gdx.gl20;// -1 == cached but not foundint location;if ((location = uniforms.get(name, -2)) == -2) {location = gl.glGetUniformLocation(program, name);if (location == -1 && pedantic)throw new IllegalArgumentException("no uniform with name '" + name + "' in shader");uniforms.put(name, location);}return location;}
public void setUniformi(String name, int value) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform1i(location, value);}
public void setUniformi(int location, int value) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform1i(location, value);}
public void setUniformi(String name, int value1, int value2) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform2i(location, value1, value2);}
public void setUniformi(int location, int value1, int value2) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform2i(location, value1, value2);}
public void setUniformi(String name, int value1, int value2, int value3) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform3i(location, value1, value2, value3);}
public void setUniformi(int location, int value1, int value2, int value3) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform3i(location, value1, value2, value3);}
public void setUniformi(String name, int value1, int value2, int value3, int value4) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform4i(location, value1, value2, value3, value4);}
public void setUniformi(int location, int value1, int value2, int value3, int value4) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform4i(location, value1, value2, value3, value4);}
public void setUniformf(String name, float value) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform1f(location, value);}
public void setUniformf(int location, float value) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform1f(location, value);}
public void setUniformf(String name, float value1, float value2) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform2f(location, value1, value2);}
public void setUniformf(int location, float value1, float value2) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform2f(location, value1, value2);}
public void setUniformf(String name, float value1, float value2, float value3) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform3f(location, value1, value2, value3);}
public void setUniformf(int location, float value1, float value2, float value3) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform3f(location, value1, value2, value3);}
public void setUniformf(String name, float value1, float value2, float value3, float value4) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform4f(location, value1, value2, value3, value4);}
public void setUniformf(int location, float value1, float value2, float value3, float value4) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform4f(location, value1, value2, value3, value4);}
public void setUniform1fv(String name, float[] values, int offset, int length) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform1fv(location, length, values, offset);}
public void setUniform1fv(int location, float[] values, int offset, int length) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform1fv(location, length, values, offset);}
public void setUniform2fv(String name, float[] values, int offset, int length) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform2fv(location, length / 2, values, offset);}
public void setUniform2fv(int location, float[] values, int offset, int length) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform2fv(location, length / 2, values, offset);}
public void setUniform3fv(String name, float[] values, int offset, int length) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform3fv(location, length / 3, values, offset);}
public void setUniform3fv(int location, float[] values, int offset, int length) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform3fv(location, length / 3, values, offset);}
public void setUniform4fv(String name, float[] values, int offset, int length) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchUniformLocation(name);gl.glUniform4fv(location, length / 4, values, offset);}
public void setUniform4fv(int location, float[] values, int offset, int length) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniform4fv(location, length / 4, values, offset);}
public void setUniformMatrix(String name, Matrix4 matrix) {setUniformMatrix(name, matrix, false);}
public void setUniformMatrix(String name, Matrix4 matrix, boolean transpose) {setUniformMatrix(fetchUniformLocation(name), matrix, transpose);}
public void setUniformMatrix(int location, Matrix4 matrix) {setUniformMatrix(location, matrix, false);}
public void setUniformMatrix(int location, Matrix4 matrix, boolean transpose) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniformMatrix4fv(location, 1, transpose, matrix.val, 0);}
public void setUniformMatrix(String name, Matrix3 matrix) {setUniformMatrix(name, matrix, false);}
public void setUniformMatrix(String name, Matrix3 matrix, boolean transpose) {setUniformMatrix(fetchUniformLocation(name), matrix, transpose);}
public void setUniformMatrix(int location, Matrix3 matrix) {setUniformMatrix(location, matrix, false);}
public void setUniformMatrix(int location, Matrix3 matrix, boolean transpose) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniformMatrix3fv(location, 1, transpose, matrix.val, 0);}
public void setUniformMatrix3fv(String name, FloatBuffer buffer, int count, boolean transpose) {GL20 gl = Gdx.gl20;checkManaged();buffer.position(0);int location = fetchUniformLocation(name);gl.glUniformMatrix3fv(location, count, transpose, buffer);}
public void setUniformMatrix4fv(String name, FloatBuffer buffer, int count, boolean transpose) {GL20 gl = Gdx.gl20;checkManaged();buffer.position(0);int location = fetchUniformLocation(name);gl.glUniformMatrix4fv(location, count, transpose, buffer);}
public void setUniformMatrix4fv(int location, float[] values, int offset, int length) {GL20 gl = Gdx.gl20;checkManaged();gl.glUniformMatrix4fv(location, length / 16, false, values, offset);}
public void setUniformMatrix4fv(String name, float[] values, int offset, int length) {setUniformMatrix4fv(fetchUniformLocation(name), values, offset, length);}
public void setUniformf(String name, Vector2 values) {setUniformf(name, values.x, values.y);}
public void setUniformf(int location, Vector2 values) {setUniformf(location, values.x, values.y);}
public void setUniformf(String name, Vector3 values) {setUniformf(name, values.x, values.y, values.z);}
public void setUniformf(int location, Vector3 values) {setUniformf(location, values.x, values.y, values.z);}
public void setUniformf(String name, Color values) {setUniformf(name, values.r, values.g, values.b, values.a);}
public void setUniformf(int location, Color values) {setUniformf(location, values.r, values.g, values.b, values.a);}
public void setVertexAttribute(String name, int size, int type, boolean normalize, int stride, Buffer buffer) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchAttributeLocation(name);if (location == -1)return;gl.glVertexAttribPointer(location, size, type, normalize, stride, buffer);}
public void setVertexAttribute(int location, int size, int type, boolean normalize, int stride, Buffer buffer) {GL20 gl = Gdx.gl20;checkManaged();gl.glVertexAttribPointer(location, size, type, normalize, stride, buffer);}
public void setVertexAttribute(String name, int size, int type, boolean normalize, int stride, int offset) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchAttributeLocation(name);if (location == -1)return;gl.glVertexAttribPointer(location, size, type, normalize, stride, offset);}
public void setVertexAttribute(int location, int size, int type, boolean normalize, int stride, int offset) {GL20 gl = Gdx.gl20;checkManaged();gl.glVertexAttribPointer(location, size, type, normalize, stride, offset);}
public void begin() {GL20 gl = Gdx.gl20;checkManaged();gl.glUseProgram(program);}
public void end() {GL20 gl = Gdx.gl20;gl.glUseProgram(0);}
public void dispose() {GL20 gl = Gdx.gl20;gl.glUseProgram(0);gl.glDeleteShader(vertexShaderHandle);gl.glDeleteShader(fragmentShaderHandle);gl.glDeleteProgram(program);if (shaders.get(Gdx.app) != null)shaders.get(Gdx.app).removeValue(this, true);}
public void disableVertexAttribute(String name) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchAttributeLocation(name);if (location == -1)return;gl.glDisableVertexAttribArray(location);}
public void disableVertexAttribute(int location) {GL20 gl = Gdx.gl20;checkManaged();gl.glDisableVertexAttribArray(location);}
public void enableVertexAttribute(String name) {GL20 gl = Gdx.gl20;checkManaged();int location = fetchAttributeLocation(name);if (location == -1)return;gl.glEnableVertexAttribArray(location);}
public void enableVertexAttribute(int location) {GL20 gl = Gdx.gl20;checkManaged();gl.glEnableVertexAttribArray(location);}
private void checkManaged() {if (invalidated) {compileShaders(vertexShaderSource, fragmentShaderSource);invalidated = false;}}
private void addManagedShader(Application app, ShaderProgram shaderProgram) {Array<ShaderProgram> managedResources = shaders.get(app);if (managedResources == null)managedResources = new Array<ShaderProgram>();managedResources.add(shaderProgram);shaders.put(app, managedResources);}
public static void invalidateAllShaderPrograms(Application app) {if (Gdx.gl20 == null)return;Array<ShaderProgram> shaderArray = shaders.get(app);if (shaderArray == null)return;for (int i = 0; i < shaderArray.size; i++) {shaderArray.get(i).invalidated = true;shaderArray.get(i).checkManaged();}}
public static void clearAllShaderPrograms(Application app) {shaders.remove(app);}
public static String getManagedStatus() {StringBuilder builder = new StringBuilder();int i = 0;builder.append("Managed shaders/app: { ");for (Application app : shaders.keys()) {builder.append(shaders.get(app).size);builder.append(" ");}builder.append("}");return builder.toString();}
public void setAttributef(String name, float value1, float value2, float value3, float value4) {GL20 gl = Gdx.gl20;int location = fetchAttributeLocation(name);gl.glVertexAttrib4f(location, value1, value2, value3, value4);}
private void fetchUniforms() {params.clear();Gdx.gl20.glGetProgramiv(program, GL20.GL_ACTIVE_UNIFORMS, params);int numUniforms = params.get(0);uniformNames = new String[numUniforms];for (int i = 0; i < numUniforms; i++) {params.clear();params.put(0, 1);type.clear();String name = Gdx.gl20.glGetActiveUniform(program, i, params, type);int location = Gdx.gl20.glGetUniformLocation(program, name);uniforms.put(name, location);uniformTypes.put(name, type.get(0));uniformSizes.put(name, params.get(0));uniformNames[i] = name;}}
private void fetchAttributes() {params.clear();Gdx.gl20.glGetProgramiv(program, GL20.GL_ACTIVE_ATTRIBUTES, params);int numAttributes = params.get(0);attributeNames = new String[numAttributes];for (int i = 0; i < numAttributes; i++) {params.clear();params.put(0, 1);type.clear();String name = Gdx.gl20.glGetActiveAttrib(program, i, params, type);int location = Gdx.gl20.glGetAttribLocation(program, name);attributes.put(name, location);attributeTypes.put(name, type.get(0));attributeSizes.put(name, params.get(0));attributeNames[i] = name;}}
public boolean hasAttribute(String name) {return attributes.containsKey(name);}
public int getAttributeType(String name) {return attributeTypes.get(name, 0);}
public int getAttributeLocation(String name) {return attributes.get(name, -1);}
public int getAttributeSize(String name) {return attributeSizes.get(name, 0);}
public boolean hasUniform(String name) {return uniforms.containsKey(name);}
public int getUniformType(String name) {return uniformTypes.get(name, 0);}
public int getUniformLocation(String name) {return uniforms.get(name, -1);}
public int getUniformSize(String name) {return uniformSizes.get(name, 0);}
public String[] getAttributes() {return attributeNames;}
public String[] getUniforms() {return uniformNames;}
public String getVertexShaderSource() {return vertexShaderSource;}
public String getFragmentShaderSource() {return fragmentShaderSource;}public Matrix3 idt() {float[] val = this.val;val[M00] = 1;val[M10] = 0;val[M20] = 0;val[M01] = 0;val[M11] = 1;val[M21] = 0;val[M02] = 0;val[M12] = 0;val[M22] = 1;return this;}
public Matrix3 mul(Matrix3 m) {float[] val = this.val;float v00 = val[M00] * m.val[M00] + val[M01] * m.val[M10] + val[M02] * m.val[M20];float v01 = val[M00] * m.val[M01] + val[M01] * m.val[M11] + val[M02] * m.val[M21];float v02 = val[M00] * m.val[M02] + val[M01] * m.val[M12] + val[M02] * m.val[M22];float v10 = val[M10] * m.val[M00] + val[M11] * m.val[M10] + val[M12] * m.val[M20];float v11 = val[M10] * m.val[M01] + val[M11] * m.val[M11] + val[M12] * m.val[M21];float v12 = val[M10] * m.val[M02] + val[M11] * m.val[M12] + val[M12] * m.val[M22];float v20 = val[M20] * m.val[M00] + val[M21] * m.val[M10] + val[M22] * m.val[M20];float v21 = val[M20] * m.val[M01] + val[M21] * m.val[M11] + val[M22] * m.val[M21];float v22 = val[M20] * m.val[M02] + val[M21] * m.val[M12] + val[M22] * m.val[M22];val[M00] = v00;val[M10] = v10;val[M20] = v20;val[M01] = v01;val[M11] = v11;val[M21] = v21;val[M02] = v02;val[M12] = v12;val[M22] = v22;return this;}
public Matrix3 mulLeft(Matrix3 m) {float[] val = this.val;float v00 = m.val[M00] * val[M00] + m.val[M01] * val[M10] + m.val[M02] * val[M20];float v01 = m.val[M00] * val[M01] + m.val[M01] * val[M11] + m.val[M02] * val[M21];float v02 = m.val[M00] * val[M02] + m.val[M01] * val[M12] + m.val[M02] * val[M22];float v10 = m.val[M10] * val[M00] + m.val[M11] * val[M10] + m.val[M12] * val[M20];float v11 = m.val[M10] * val[M01] + m.val[M11] * val[M11] + m.val[M12] * val[M21];float v12 = m.val[M10] * val[M02] + m.val[M11] * val[M12] + m.val[M12] * val[M22];float v20 = m.val[M20] * val[M00] + m.val[M21] * val[M10] + m.val[M22] * val[M20];float v21 = m.val[M20] * val[M01] + m.val[M21] * val[M11] + m.val[M22] * val[M21];float v22 = m.val[M20] * val[M02] + m.val[M21] * val[M12] + m.val[M22] * val[M22];val[M00] = v00;val[M10] = v10;val[M20] = v20;val[M01] = v01;val[M11] = v11;val[M21] = v21;val[M02] = v02;val[M12] = v12;val[M22] = v22;return this;}
public Matrix3 setToRotation(float degrees) {return setToRotationRad(MathUtils.degreesToRadians * degrees);}
public Matrix3 setToRotationRad(float radians) {float cos = (float) Math.cos(radians);float sin = (float) Math.sin(radians);float[] val = this.val;val[M00] = cos;val[M10] = sin;val[M20] = 0;val[M01] = -sin;val[M11] = cos;val[M21] = 0;val[M02] = 0;val[M12] = 0;val[M22] = 1;return this;}
public Matrix3 setToRotation(Vector3 axis, float degrees) {return setToRotation(axis, MathUtils.cosDeg(degrees), MathUtils.sinDeg(degrees));}
public Matrix3 setToRotation(Vector3 axis, float cos, float sin) {float[] val = this.val;float oc = 1.0f - cos;val[M00] = oc * axis.x * axis.x + cos;val[M10] = oc * axis.x * axis.y - axis.z * sin;val[M20] = oc * axis.z * axis.x + axis.y * sin;val[M01] = oc * axis.x * axis.y + axis.z * sin;val[M11] = oc * axis.y * axis.y + cos;val[M21] = oc * axis.y * axis.z - axis.x * sin;val[M02] = oc * axis.z * axis.x - axis.y * sin;val[M12] = oc * axis.y * axis.z + axis.x * sin;val[M22] = oc * axis.z * axis.z + cos;return this;}
public Matrix3 setToTranslation(float x, float y) {float[] val = this.val;val[M00] = 1;val[M10] = 0;val[M20] = 0;val[M01] = 0;val[M11] = 1;val[M21] = 0;val[M02] = x;val[M12] = y;val[M22] = 1;return this;}
public Matrix3 setToTranslation(Vector2 translation) {float[] val = this.val;val[M00] = 1;val[M10] = 0;val[M20] = 0;val[M01] = 0;val[M11] = 1;val[M21] = 0;val[M02] = translation.x;val[M12] = translation.y;val[M22] = 1;return this;}
public Matrix3 setToScaling(float scaleX, float scaleY) {float[] val = this.val;val[M00] = scaleX;val[M10] = 0;val[M20] = 0;val[M01] = 0;val[M11] = scaleY;val[M21] = 0;val[M02] = 0;val[M12] = 0;val[M22] = 1;return this;}
public Matrix3 setToScaling(Vector2 scale) {float[] val = this.val;val[M00] = scale.x;val[M10] = 0;val[M20] = 0;val[M01] = 0;val[M11] = scale.y;val[M21] = 0;val[M02] = 0;val[M12] = 0;val[M22] = 1;return this;}
public String toString() {float[] val = this.val;return //"[" + val[M00] + "|" + val[M01] + "|" + val[M02] + "]\n" + "[" + val[M10] + "|" + val[M11] + "|" + val[M12] + //"]\n" + "[" + val[M20] + "|" + val[M21] + "|" + val[M22] + "]";}
public float det() {float[] val = this.val;return val[M00] * val[M11] * val[M22] + val[M01] * val[M12] * val[M20] + val[M02] * val[M10] * val[M21] - val[M00] * val[M12] * val[M21] - val[M01] * val[M10] * val[M22] - val[M02] * val[M11] * val[M20];}
public Matrix3 inv() {float det = det();if (det == 0)throw new GdxRuntimeException("Can't invert a singular matrix");float inv_det = 1.0f / det;float[] tmp = this.tmp, val = this.val;tmp[M00] = val[M11] * val[M22] - val[M21] * val[M12];tmp[M10] = val[M20] * val[M12] - val[M10] * val[M22];tmp[M20] = val[M10] * val[M21] - val[M20] * val[M11];tmp[M01] = val[M21] * val[M02] - val[M01] * val[M22];tmp[M11] = val[M00] * val[M22] - val[M20] * val[M02];tmp[M21] = val[M20] * val[M01] - val[M00] * val[M21];tmp[M02] = val[M01] * val[M12] - val[M11] * val[M02];tmp[M12] = val[M10] * val[M02] - val[M00] * val[M12];tmp[M22] = val[M00] * val[M11] - val[M10] * val[M01];val[M00] = inv_det * tmp[M00];val[M10] = inv_det * tmp[M10];val[M20] = inv_det * tmp[M20];val[M01] = inv_det * tmp[M01];val[M11] = inv_det * tmp[M11];val[M21] = inv_det * tmp[M21];val[M02] = inv_det * tmp[M02];val[M12] = inv_det * tmp[M12];val[M22] = inv_det * tmp[M22];return this;}
public Matrix3 set(Matrix3 mat) {System.arraycopy(mat.val, 0, val, 0, val.length);return this;}
public Matrix3 set(Affine2 affine) {float[] val = this.val;val[M00] = affine.m00;val[M10] = affine.m10;val[M20] = 0;val[M01] = affine.m01;val[M11] = affine.m11;val[M21] = 0;val[M02] = affine.m02;val[M12] = affine.m12;val[M22] = 1;return this;}
public Matrix3 set(Matrix4 mat) {float[] val = this.val;val[M00] = mat.val[Matrix4.M00];val[M10] = mat.val[Matrix4.M10];val[M20] = mat.val[Matrix4.M20];val[M01] = mat.val[Matrix4.M01];val[M11] = mat.val[Matrix4.M11];val[M21] = mat.val[Matrix4.M21];val[M02] = mat.val[Matrix4.M02];val[M12] = mat.val[Matrix4.M12];val[M22] = mat.val[Matrix4.M22];return this;}
public Matrix3 set(float[] values) {System.arraycopy(values, 0, val, 0, val.length);return this;}
public Matrix3 trn(Vector2 vector) {val[M02] += vector.x;val[M12] += vector.y;return this;}
public Matrix3 trn(float x, float y) {val[M02] += x;val[M12] += y;return this;}
public Matrix3 trn(Vector3 vector) {val[M02] += vector.x;val[M12] += vector.y;return this;}
public Matrix3 translate(float x, float y) {float[] val = this.val;tmp[M00] = 1;tmp[M10] = 0;tmp[M20] = 0;tmp[M01] = 0;tmp[M11] = 1;tmp[M21] = 0;tmp[M02] = x;tmp[M12] = y;tmp[M22] = 1;mul(val, tmp);return this;}
public Matrix3 translate(Vector2 translation) {float[] val = this.val;tmp[M00] = 1;tmp[M10] = 0;tmp[M20] = 0;tmp[M01] = 0;tmp[M11] = 1;tmp[M21] = 0;tmp[M02] = translation.x;tmp[M12] = translation.y;tmp[M22] = 1;mul(val, tmp);return this;}
public Matrix3 rotate(float degrees) {return rotateRad(MathUtils.degreesToRadians * degrees);}
public Matrix3 rotateRad(float radians) {if (radians == 0)return this;float cos = (float) Math.cos(radians);float sin = (float) Math.sin(radians);float[] tmp = this.tmp;tmp[M00] = cos;tmp[M10] = sin;tmp[M20] = 0;tmp[M01] = -sin;tmp[M11] = cos;tmp[M21] = 0;tmp[M02] = 0;tmp[M12] = 0;tmp[M22] = 1;mul(val, tmp);return this;}
public Matrix3 scale(float scaleX, float scaleY) {float[] tmp = this.tmp;tmp[M00] = scaleX;tmp[M10] = 0;tmp[M20] = 0;tmp[M01] = 0;tmp[M11] = scaleY;tmp[M21] = 0;tmp[M02] = 0;tmp[M12] = 0;tmp[M22] = 1;mul(val, tmp);return this;}
public Matrix3 scale(Vector2 scale) {float[] tmp = this.tmp;tmp[M00] = scale.x;tmp[M10] = 0;tmp[M20] = 0;tmp[M01] = 0;tmp[M11] = scale.y;tmp[M21] = 0;tmp[M02] = 0;tmp[M12] = 0;tmp[M22] = 1;mul(val, tmp);return this;}
public float[] getValues() {return val;}
public Vector2 getTranslation(Vector2 position) {position.x = val[M02];position.y = val[M12];return position;}
public Vector2 getScale(Vector2 scale) {float[] val = this.val;scale.x = (float) Math.sqrt(val[M00] * val[M00] + val[M01] * val[M01]);scale.y = (float) Math.sqrt(val[M10] * val[M10] + val[M11] * val[M11]);return scale;}
public float getRotation() {return MathUtils.radiansToDegrees * (float) Math.atan2(val[M10], val[M00]);}
public float getRotationRad() {return (float) Math.atan2(val[M10], val[M00]);}
public Matrix3 scl(float scale) {val[M00] *= scale;val[M11] *= scale;return this;}
public Matrix3 scl(Vector2 scale) {val[M00] *= scale.x;val[M11] *= scale.y;return this;}
public Matrix3 scl(Vector3 scale) {val[M00] *= scale.x;val[M11] *= scale.y;return this;}
public Matrix3 transpose() {// Where MXY you do not have to change MXXfloat[] val = this.val;float v01 = val[M10];float v02 = val[M20];float v10 = val[M01];float v12 = val[M21];float v20 = val[M02];float v21 = val[M12];val[M01] = v01;val[M02] = v02;val[M10] = v10;val[M12] = v12;val[M20] = v20;val[M21] = v21;return this;}
private static void mul(float[] mata, float[] matb) {float v00 = mata[M00] * matb[M00] + mata[M01] * matb[M10] + mata[M02] * matb[M20];float v01 = mata[M00] * matb[M01] + mata[M01] * matb[M11] + mata[M02] * matb[M21];float v02 = mata[M00] * matb[M02] + mata[M01] * matb[M12] + mata[M02] * matb[M22];float v10 = mata[M10] * matb[M00] + mata[M11] * matb[M10] + mata[M12] * matb[M20];float v11 = mata[M10] * matb[M01] + mata[M11] * matb[M11] + mata[M12] * matb[M21];float v12 = mata[M10] * matb[M02] + mata[M11] * matb[M12] + mata[M12] * matb[M22];float v20 = mata[M20] * matb[M00] + mata[M21] * matb[M10] + mata[M22] * matb[M20];float v21 = mata[M20] * matb[M01] + mata[M21] * matb[M11] + mata[M22] * matb[M21];float v22 = mata[M20] * matb[M02] + mata[M21] * matb[M12] + mata[M22] * matb[M22];mata[M00] = v00;mata[M10] = v10;mata[M20] = v20;mata[M01] = v01;mata[M11] = v11;mata[M21] = v21;mata[M02] = v02;mata[M12] = v12;mata[M22] = v22;}public final Shape clone() {PolygonShape shape = new PolygonShape();shape.m_centroid.set(this.m_centroid);for (int i = 0; i < shape.m_normals.length; i++) {shape.m_normals[i].set(m_normals[i]);shape.m_vertices[i].set(m_vertices[i]);}shape.setRadius(this.getRadius());shape.m_count = this.m_count;return shape;}
public final void set(final Vec2[] vertices, final int count) {set(vertices, count, null, null);}
public final void set(final Vec2[] verts, final int num, final Vec2Array vecPool, final IntArray intPool) {assert (3 <= num && num <= Settings.maxPolygonVertices);if (num < 3) {setAsBox(1.0f, 1.0f);return;}int n = MathUtils.min(num, Settings.maxPolygonVertices);// Perform welding and copy vertices into local buffer.Vec2[] ps = (vecPool != null) ? vecPool.get(Settings.maxPolygonVertices) : new Vec2[Settings.maxPolygonVertices];int tempCount = 0;for (int i = 0; i < n; ++i) {Vec2 v = verts[i];boolean unique = true;for (int j = 0; j < tempCount; ++j) {if (MathUtils.distanceSquared(v, ps[j]) < 0.5f * Settings.linearSlop) {unique = false;break;}}if (unique) {ps[tempCount++] = v;}}n = tempCount;if (n < 3) {assert (false);setAsBox(1.0f, 1.0f);return;}int i0 = 0;float x0 = ps[0].x;for (int i = 1; i < n; ++i) {float x = ps[i].x;if (x > x0 || (x == x0 && ps[i].y < ps[i0].y)) {i0 = i;x0 = x;}}int[] hull = (intPool != null) ? intPool.get(Settings.maxPolygonVertices) : new int[Settings.maxPolygonVertices];int m = 0;int ih = i0;while (true) {hull[m] = ih;int ie = 0;for (int j = 1; j < n; ++j) {if (ie == ih) {ie = j;continue;}Vec2 r = pool1.set(ps[ie]).subLocal(ps[hull[m]]);Vec2 v = pool2.set(ps[j]).subLocal(ps[hull[m]]);float c = Vec2.cross(r, v);if (c < 0.0f) {ie = j;}// Collinearity checkif (c == 0.0f && v.lengthSquared() > r.lengthSquared()) {ie = j;}}++m;ih = ie;if (ie == i0) {break;}}this.m_count = m;// Copy vertices.for (int i = 0; i < m_count; ++i) {if (m_vertices[i] == null) {m_vertices[i] = new Vec2();}m_vertices[i].set(ps[hull[i]]);}final Vec2 edge = pool1;// Compute normals. Ensure the edges have non-zero length.for (int i = 0; i < m_count; ++i) {final int i1 = i;final int i2 = i + 1 < m_count ? i + 1 : 0;edge.set(m_vertices[i2]).subLocal(m_vertices[i1]);assert (edge.lengthSquared() > Settings.EPSILON * Settings.EPSILON);Vec2.crossToOutUnsafe(edge, 1f, m_normals[i]);m_normals[i].normalize();}// Compute the polygon centroid.computeCentroidToOut(m_vertices, m_count, m_centroid);}
public final void setAsBox(final float hx, final float hy) {m_count = 4;m_vertices[0].set(-hx, -hy);m_vertices[1].set(hx, -hy);m_vertices[2].set(hx, hy);m_vertices[3].set(-hx, hy);m_normals[0].set(0.0f, -1.0f);m_normals[1].set(1.0f, 0.0f);m_normals[2].set(0.0f, 1.0f);m_normals[3].set(-1.0f, 0.0f);m_centroid.setZero();}
public final void setAsBox(final float hx, final float hy, final Vec2 center, final float angle) {m_count = 4;m_vertices[0].set(-hx, -hy);m_vertices[1].set(hx, -hy);m_vertices[2].set(hx, hy);m_vertices[3].set(-hx, hy);m_normals[0].set(0.0f, -1.0f);m_normals[1].set(1.0f, 0.0f);m_normals[2].set(0.0f, 1.0f);m_normals[3].set(-1.0f, 0.0f);m_centroid.set(center);final Transform xf = poolt1;xf.p.set(center);xf.q.set(angle);// Transform vertices and normals.for (int i = 0; i < m_count; ++i) {Transform.mulToOut(xf, m_vertices[i], m_vertices[i]);Rot.mulToOut(xf.q, m_normals[i], m_normals[i]);}}
public int getChildCount() {return 1;}
public final boolean testPoint(final Transform xf, final Vec2 p) {float tempx, tempy;final Rot xfq = xf.q;tempx = p.x - xf.p.x;tempy = p.y - xf.p.y;final float pLocalx = xfq.c * tempx + xfq.s * tempy;final float pLocaly = -xfq.s * tempx + xfq.c * tempy;if (m_debug) {System.out.println("--testPoint debug--");System.out.println("Vertices: ");for (int i = 0; i < m_count; ++i) {System.out.println(m_vertices[i]);}System.out.println("pLocal: " + pLocalx + ", " + pLocaly);}for (int i = 0; i < m_count; ++i) {Vec2 vertex = m_vertices[i];Vec2 normal = m_normals[i];tempx = pLocalx - vertex.x;tempy = pLocaly - vertex.y;final float dot = normal.x * tempx + normal.y * tempy;if (dot > 0.0f) {return false;}}return true;}
public final void computeAABB(final AABB aabb, final Transform xf, int childIndex) {final Vec2 lower = aabb.lowerBound;final Vec2 upper = aabb.upperBound;final Vec2 v1 = m_vertices[0];final float xfqc = xf.q.c;final float xfqs = xf.q.s;final float xfpx = xf.p.x;final float xfpy = xf.p.y;lower.x = (xfqc * v1.x - xfqs * v1.y) + xfpx;lower.y = (xfqs * v1.x + xfqc * v1.y) + xfpy;upper.x = lower.x;upper.y = lower.y;for (int i = 1; i < m_count; ++i) {Vec2 v2 = m_vertices[i];// Vec2 v = Mul(xf, m_vertices[i]);float vx = (xfqc * v2.x - xfqs * v2.y) + xfpx;float vy = (xfqs * v2.x + xfqc * v2.y) + xfpy;lower.x = lower.x < vx ? lower.x : vx;lower.y = lower.y < vy ? lower.y : vy;upper.x = upper.x > vx ? upper.x : vx;upper.y = upper.y > vy ? upper.y : vy;}lower.x -= m_radius;lower.y -= m_radius;upper.x += m_radius;upper.y += m_radius;}
public final int getVertexCount() {return m_count;}
public final Vec2 getVertex(final int index) {assert (0 <= index && index < m_count);return m_vertices[index];}
public float computeDistanceToOut(Transform xf, Vec2 p, int childIndex, Vec2 normalOut) {float xfqc = xf.q.c;float xfqs = xf.q.s;float tx = p.x - xf.p.x;float ty = p.y - xf.p.y;float pLocalx = xfqc * tx + xfqs * ty;float pLocaly = -xfqs * tx + xfqc * ty;float maxDistance = -Float.MAX_VALUE;float normalForMaxDistanceX = pLocalx;float normalForMaxDistanceY = pLocaly;for (int i = 0; i < m_count; ++i) {Vec2 vertex = m_vertices[i];Vec2 normal = m_normals[i];tx = pLocalx - vertex.x;ty = pLocaly - vertex.y;float dot = normal.x * tx + normal.y * ty;if (dot > maxDistance) {maxDistance = dot;normalForMaxDistanceX = normal.x;normalForMaxDistanceY = normal.y;}}float distance;if (maxDistance > 0) {float minDistanceX = normalForMaxDistanceX;float minDistanceY = normalForMaxDistanceY;float minDistance2 = maxDistance * maxDistance;for (int i = 0; i < m_count; ++i) {Vec2 vertex = m_vertices[i];float distanceVecX = pLocalx - vertex.x;float distanceVecY = pLocaly - vertex.y;float distance2 = (distanceVecX * distanceVecX + distanceVecY * distanceVecY);if (minDistance2 > distance2) {minDistanceX = distanceVecX;minDistanceY = distanceVecY;minDistance2 = distance2;}}distance = MathUtils.sqrt(minDistance2);normalOut.x = xfqc * minDistanceX - xfqs * minDistanceY;normalOut.y = xfqs * minDistanceX + xfqc * minDistanceY;normalOut.normalize();} else {distance = maxDistance;normalOut.x = xfqc * normalForMaxDistanceX - xfqs * normalForMaxDistanceY;normalOut.y = xfqs * normalForMaxDistanceX + xfqc * normalForMaxDistanceY;}return distance;}
public final boolean raycast(RayCastOutput output, RayCastInput input, Transform xf, int childIndex) {final float xfqc = xf.q.c;final float xfqs = xf.q.s;final Vec2 xfp = xf.p;float tempx, tempy;// b2Vec2 p2 = b2MulT(xf.q, input.p2 - xf.p);tempx = input.p1.x - xfp.x;tempy = input.p1.y - xfp.y;final float p1x = xfqc * tempx + xfqs * tempy;final float p1y = -xfqs * tempx + xfqc * tempy;tempx = input.p2.x - xfp.x;tempy = input.p2.y - xfp.y;final float p2x = xfqc * tempx + xfqs * tempy;final float p2y = -xfqs * tempx + xfqc * tempy;final float dx = p2x - p1x;final float dy = p2y - p1y;float lower = 0, upper = input.maxFraction;int index = -1;for (int i = 0; i < m_count; ++i) {Vec2 normal = m_normals[i];Vec2 vertex = m_vertices[i];// dot(normal, p1 - v) + a * dot(normal, d) = 0float tempxn = vertex.x - p1x;float tempyn = vertex.y - p1y;final float numerator = normal.x * tempxn + normal.y * tempyn;final float denominator = normal.x * dx + normal.y * dy;if (denominator == 0.0f) {if (numerator < 0.0f) {return false;}} else {// numerator.if (denominator < 0.0f && numerator < lower * denominator) {// The segment enters this half-space.lower = numerator / denominator;index = i;} else if (denominator > 0.0f && numerator < upper * denominator) {// The segment exits this half-space.upper = numerator / denominator;}}if (upper < lower) {return false;}}assert (0.0f <= lower && lower <= input.maxFraction);if (index >= 0) {output.fraction = lower;// normal = Mul(xf.R, m_normals[index]);Vec2 normal = m_normals[index];Vec2 out = output.normal;out.x = xfqc * normal.x - xfqs * normal.y;out.y = xfqs * normal.x + xfqc * normal.y;return true;}return false;}
public final void computeCentroidToOut(final Vec2[] vs, final int count, final Vec2 out) {assert (count >= 3);out.set(0.0f, 0.0f);float area = 0.0f;// It's location doesn't change the result (except for rounding error).final Vec2 pRef = pool1;pRef.setZero();final Vec2 e1 = pool2;final Vec2 e2 = pool3;final float inv3 = 1.0f / 3.0f;for (int i = 0; i < count; ++i) {// Triangle vertices.final Vec2 p1 = pRef;final Vec2 p2 = vs[i];final Vec2 p3 = i + 1 < count ? vs[i + 1] : vs[0];e1.set(p2).subLocal(p1);e2.set(p3).subLocal(p1);final float D = Vec2.cross(e1, e2);final float triangleArea = 0.5f * D;area += triangleArea;// Area weighted centroide1.set(p1).addLocal(p2).addLocal(p3).mulLocal(triangleArea * inv3);out.addLocal(e1);}// Centroidassert (area > Settings.EPSILON);out.mulLocal(1.0f / area);}
public void computeMass(final MassData massData, float density) {assert (m_count >= 3);final Vec2 center = pool1;center.setZero();float area = 0.0f;float I = 0.0f;// It's location doesn't change the result (except for rounding error).final Vec2 s = pool2;s.setZero();// This code would put the reference point inside the polygon.for (int i = 0; i < m_count; ++i) {s.addLocal(m_vertices[i]);}s.mulLocal(1.0f / m_count);final float k_inv3 = 1.0f / 3.0f;final Vec2 e1 = pool3;final Vec2 e2 = pool4;for (int i = 0; i < m_count; ++i) {// Triangle vertices.e1.set(m_vertices[i]).subLocal(s);e2.set(s).negateLocal().addLocal(i + 1 < m_count ? m_vertices[i + 1] : m_vertices[0]);final float D = Vec2.cross(e1, e2);final float triangleArea = 0.5f * D;area += triangleArea;// Area weighted centroidcenter.x += triangleArea * k_inv3 * (e1.x + e2.x);center.y += triangleArea * k_inv3 * (e1.y + e2.y);final float ex1 = e1.x, ey1 = e1.y;final float ex2 = e2.x, ey2 = e2.y;float intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;float inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;I += (0.25f * k_inv3 * D) * (intx2 + inty2);}// Total massmassData.mass = density * area;// Center of massassert (area > Settings.EPSILON);center.mulLocal(1.0f / area);massData.center.set(center).addLocal(s);// Inertia tensor relative to the local origin (point s)massData.I = I * density;// Shift to center of mass then to original body origin.massData.I += massData.mass * (Vec2.dot(massData.center, massData.center));}
public boolean validate() {for (int i = 0; i < m_count; ++i) {int i1 = i;int i2 = i < m_count - 1 ? i1 + 1 : 0;Vec2 p = m_vertices[i1];Vec2 e = pool1.set(m_vertices[i2]).subLocal(p);for (int j = 0; j < m_count; ++j) {if (j == i1 || j == i2) {continue;}Vec2 v = pool2.set(m_vertices[j]).subLocal(p);float c = Vec2.cross(e, v);if (c < 0.0f) {return false;}}}return true;}
public Vec2[] getVertices() {return m_vertices;}
public Vec2[] getNormals() {return m_normals;}
public Vec2 centroid(final Transform xf) {return Transform.mul(xf, m_centroid);}
public Vec2 centroidToOut(final Transform xf, final Vec2 out) {Transform.mulToOutUnsafe(xf, m_centroid, out);return out;}protected void finalize() {try {if (mGLThread != null) {// attached to a window.mGLThread.requestExitAndWait();}} finally {super.finalize();}}
private void init() {// underlying surface is created and destroyedSurfaceHolder holder = getHolder();holder.addCallback(this);int sdkVersion = android.os.Build.VERSION.SDK_INT;// setFormat is done by SurfaceView in SDK 2.3 and newer.if (sdkVersion <= 8) {// SDK 2.2 or olderholder.setFormat(PixelFormat.RGB_565);}}
public void setGLWrapper(GLWrapper glWrapper) {mGLWrapper = glWrapper;}
public void setDebugFlags(int debugFlags) {mDebugFlags = debugFlags;}
public int getDebugFlags() {return mDebugFlags;}
public void setPreserveEGLContextOnPause(boolean preserveOnPause) {mPreserveEGLContextOnPause = preserveOnPause;}
public boolean getPreserveEGLContextOnPause() {return mPreserveEGLContextOnPause;}
public void setRenderer(Renderer renderer) {checkRenderThreadState();if (mEGLConfigChooser == null) {mEGLConfigChooser = new SimpleEGLConfigChooser(true);}if (mEGLContextFactory == null) {mEGLContextFactory = new DefaultContextFactory();}if (mEGLWindowSurfaceFactory == null) {mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();}mRenderer = renderer;mGLThread = new GLThread(mThisWeakRef);mGLThread.start();}
public void setEGLContextFactory(EGLContextFactory factory) {checkRenderThreadState();mEGLContextFactory = factory;}
public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {checkRenderThreadState();mEGLWindowSurfaceFactory = factory;}
public void setEGLConfigChooser(EGLConfigChooser configChooser) {checkRenderThreadState();mEGLConfigChooser = configChooser;}
public void setEGLConfigChooser(boolean needDepth) {setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));}
public void setEGLConfigChooser(int redSize, int greenSize, int blueSize, int alphaSize, int depthSize, int stencilSize) {setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize, blueSize, alphaSize, depthSize, stencilSize));}
public void setEGLContextClientVersion(int version) {checkRenderThreadState();mEGLContextClientVersion = version;}
public void setRenderMode(int renderMode) {mGLThread.setRenderMode(renderMode);}
public int getRenderMode() {return mGLThread.getRenderMode();}
public void requestRender() {mGLThread.requestRender();}
public void surfaceCreated(SurfaceHolder holder) {mGLThread.surfaceCreated();}
public void surfaceDestroyed(SurfaceHolder holder) {// Surface will be destroyed when we returnmGLThread.surfaceDestroyed();}
public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {mGLThread.onWindowResize(w, h);}
public void onPause() {mGLThread.onPause();}
public void onResume() {mGLThread.onResume();}
public void queueEvent(Runnable r) {mGLThread.queueEvent(r);}
protected void onAttachedToWindow() {super.onAttachedToWindow();if (LOG_ATTACH_DETACH) {Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);}if (mDetached && (mRenderer != null)) {int renderMode = RENDERMODE_CONTINUOUSLY;if (mGLThread != null) {renderMode = mGLThread.getRenderMode();}mGLThread = new GLThread(mThisWeakRef);if (renderMode != RENDERMODE_CONTINUOUSLY) {mGLThread.setRenderMode(renderMode);}mGLThread.start();}mDetached = false;}
protected void onDetachedFromWindow() {if (LOG_ATTACH_DETACH) {Log.d(TAG, "onDetachedFromWindow");}if (mGLThread != null) {mGLThread.requestExitAndWait();}mDetached = true;super.onDetachedFromWindow();}
public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {int[] attrib_list = { EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion, EGL10.EGL_NONE };return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT, mEGLContextClientVersion != 0 ? attrib_list : null);}
public void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context) {if (!egl.eglDestroyContext(display, context)) {Log.e("DefaultContextFactory", "display:" + display + " context: " + context);if (LOG_THREADS) {Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());}EglHelper.throwEglException("eglDestroyContex", egl.eglGetError());}}
public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config, Object nativeWindow) {EGLSurface result = null;try {result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);} catch (IllegalArgumentException e) {Log.e(TAG, "eglCreateWindowSurface", e);}return result;}
public void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface) {egl.eglDestroySurface(display, surface);}
public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {int[] num_config = new int[1];if (!egl.eglChooseConfig(display, mConfigSpec, null, 0, num_config)) {throw new IllegalArgumentException("eglChooseConfig failed");}int numConfigs = num_config[0];if (numConfigs <= 0) {throw new IllegalArgumentException("No configs match configSpec");}EGLConfig[] configs = new EGLConfig[numConfigs];if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs, num_config)) {throw new IllegalArgumentException("eglChooseConfig#2 failed");}EGLConfig config = chooseConfig(egl, display, configs);if (config == null) {throw new IllegalArgumentException("No config chosen");}return config;}
private int[] filterConfigSpec(int[] configSpec) {if (mEGLContextClientVersion != 2) {return configSpec;}int len = configSpec.length;int[] newConfigSpec = new int[len + 2];System.arraycopy(configSpec, 0, newConfigSpec, 0, len - 1);newConfigSpec[len - 1] = EGL10.EGL_RENDERABLE_TYPE;newConfigSpec[len] = 4;/* EGL_OPENGL_ES2_BIT */newConfigSpec[len + 1] = EGL10.EGL_NONE;return newConfigSpec;}
public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display, EGLConfig[] configs) {for (EGLConfig config : configs) {int d = findConfigAttrib(egl, display, config, EGL10.EGL_DEPTH_SIZE, 0);int s = findConfigAttrib(egl, display, config, EGL10.EGL_STENCIL_SIZE, 0);if ((d >= mDepthSize) && (s >= mStencilSize)) {int r = findConfigAttrib(egl, display, config, EGL10.EGL_RED_SIZE, 0);int g = findConfigAttrib(egl, display, config, EGL10.EGL_GREEN_SIZE, 0);int b = findConfigAttrib(egl, display, config, EGL10.EGL_BLUE_SIZE, 0);int a = findConfigAttrib(egl, display, config, EGL10.EGL_ALPHA_SIZE, 0);if ((r == mRedSize) && (g == mGreenSize) && (b == mBlueSize) && (a == mAlphaSize)) {return config;}}}return null;}
private int findConfigAttrib(EGL10 egl, EGLDisplay display, EGLConfig config, int attribute, int defaultValue) {if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {return mValue[0];}return defaultValue;}
public void start() {if (LOG_EGL) {Log.w("EglHelper", "start() tid=" + Thread.currentThread().getId());}mEgl = (EGL10) EGLContext.getEGL();mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {throw new RuntimeException("eglGetDisplay failed");}/* * We can now initialize EGL for that display */int[] version = new int[2];if (!mEgl.eglInitialize(mEglDisplay, version)) {throw new RuntimeException("eglInitialize failed");}GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef.get();if (view == null) {mEglConfig = null;mEglContext = null;} else {mEglConfig = view.mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);/** Create an EGL context. We want to do this as rarely as we can, because an* EGL context is a somewhat heavy object.*/mEglContext = view.mEGLContextFactory.createContext(mEgl, mEglDisplay, mEglConfig);}if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {mEglContext = null;throwEglException("createContext");}if (LOG_EGL) {Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getId());}mEglSurface = null;}
public boolean createSurface() {if (LOG_EGL) {Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getId());}/* * Check preconditions. */if (mEgl == null) {throw new RuntimeException("egl not initialized");}if (mEglDisplay == null) {throw new RuntimeException("eglDisplay not initialized");}if (mEglConfig == null) {throw new RuntimeException("mEglConfig not initialized");}/* *  The window size has changed, so we need to create a new *  surface. */destroySurfaceImp();/* * Create an EGL surface we can render into. */GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef.get();if (view != null) {mEglSurface = view.mEGLWindowSurfaceFactory.createWindowSurface(mEgl, mEglDisplay, mEglConfig, view.getHolder());} else {mEglSurface = null;}if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {int error = mEgl.eglGetError();if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");}return false;}/* * Before we can issue GL commands, we need to make sure * the context is current and bound to a surface. */if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {/* * Could not make the context current, probably because the underlying * SurfaceView surface has been destroyed. */logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());return false;}return true;}
GL createGL() {GL gl = mEglContext.getGL();GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef.get();if (view != null) {if (view.mGLWrapper != null) {gl = view.mGLWrapper.wrap(gl);}if ((view.mDebugFlags & (DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS)) != 0) {int configFlags = 0;Writer log = null;if ((view.mDebugFlags & DEBUG_CHECK_GL_ERROR) != 0) {configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;}if ((view.mDebugFlags & DEBUG_LOG_GL_CALLS) != 0) {log = new LogWriter();}gl = GLDebugHelper.wrap(gl, configFlags, log);}}return gl;}
public int swap() {if (!mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {return mEgl.eglGetError();}return EGL10.EGL_SUCCESS;}
public void destroySurface() {if (LOG_EGL) {Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getId());}destroySurfaceImp();}
private void destroySurfaceImp() {if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef.get();if (view != null) {view.mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay, mEglSurface);}mEglSurface = null;}}
public void finish() {if (LOG_EGL) {Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getId());}if (mEglContext != null) {GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef.get();if (view != null) {view.mEGLContextFactory.destroyContext(mEgl, mEglDisplay, mEglContext);}mEglContext = null;}if (mEglDisplay != null) {mEgl.eglTerminate(mEglDisplay);mEglDisplay = null;}}
private void throwEglException(String function) {throwEglException(function, mEgl.eglGetError());}
public static void throwEglException(String function, int error) {String message = formatEglError(function, error);if (LOG_THREADS) {Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getId() + " " + message);}throw new RuntimeException(message);}
public static void logEglErrorAsWarning(String tag, String function, int error) {Log.w(tag, formatEglError(function, error));}
private static String getErrorString(int error) {switch(error) {case EGL10.EGL_SUCCESS:return "EGL_SUCCESS";case EGL10.EGL_NOT_INITIALIZED:return "EGL_NOT_INITIALIZED";case EGL10.EGL_BAD_ACCESS:return "EGL_BAD_ACCESS";case EGL10.EGL_BAD_ALLOC:return "EGL_BAD_ALLOC";case EGL10.EGL_BAD_ATTRIBUTE:return "EGL_BAD_ATTRIBUTE";case EGL10.EGL_BAD_CONFIG:return "EGL_BAD_CONFIG";case EGL10.EGL_BAD_CONTEXT:return "EGL_BAD_CONTEXT";case EGL10.EGL_BAD_CURRENT_SURFACE:return "EGL_BAD_CURRENT_SURFACE";case EGL10.EGL_BAD_DISPLAY:return "EGL_BAD_DISPLAY";case EGL10.EGL_BAD_MATCH:return "EGL_BAD_MATCH";case EGL10.EGL_BAD_NATIVE_PIXMAP:return "EGL_BAD_NATIVE_PIXMAP";case EGL10.EGL_BAD_NATIVE_WINDOW:return "EGL_BAD_NATIVE_WINDOW";case EGL10.EGL_BAD_PARAMETER:return "EGL_BAD_PARAMETER";case EGL10.EGL_BAD_SURFACE:return "EGL_BAD_SURFACE";case EGL11.EGL_CONTEXT_LOST:return "EGL_CONTEXT_LOST";default:return "0x" + Integer.toHexString(error);}}
public static String formatEglError(String function, int error) {return function + " failed: " + getErrorString(error);}
public void run() {setName("GLThread " + getId());if (LOG_THREADS) {Log.i("GLThread", "starting tid=" + getId());}try {guardedRun();} catch (InterruptedException e) {} finally {sGLThreadManager.threadExiting(this);}}
private void stopEglSurfaceLocked() {if (mHaveEglSurface) {mHaveEglSurface = false;mEglHelper.destroySurface();}}
private void stopEglContextLocked() {if (mHaveEglContext) {mEglHelper.finish();mHaveEglContext = false;sGLThreadManager.releaseEglContextLocked(this);}}
private void guardedRun() {mEglHelper = new EglHelper(mGLSurfaceViewWeakRef);mHaveEglContext = false;mHaveEglSurface = false;try {GL10 gl = null;boolean createEglContext = false;boolean createEglSurface = false;boolean createGlInterface = false;boolean lostEglContext = false;boolean sizeChanged = false;boolean wantRenderNotification = false;boolean doRenderNotification = false;boolean askedToReleaseEglContext = false;int w = 0;int h = 0;Runnable event = null;while (true) {synchronized (sGLThreadManager) {while (true) {if (mShouldExit) {return;}if (!mEventQueue.isEmpty()) {event = mEventQueue.remove(0);break;}// Update the pause state.boolean pausing = false;if (mPaused != mRequestPaused) {pausing = mRequestPaused;mPaused = mRequestPaused;sGLThreadManager.notifyAll();if (LOG_PAUSE_RESUME) {Log.i("GLThread", "mPaused is now " + mPaused + " tid=" + getId());}}// Do we need to give up the EGL context?if (mShouldReleaseEglContext) {if (LOG_SURFACE) {Log.i("GLThread", "releasing EGL context because asked to tid=" + getId());}stopEglSurfaceLocked();stopEglContextLocked();mShouldReleaseEglContext = false;askedToReleaseEglContext = true;}// Have we lost the EGL context?if (lostEglContext) {stopEglSurfaceLocked();stopEglContextLocked();lostEglContext = false;}// When pausing, release the EGL surface:if (pausing && mHaveEglSurface) {if (LOG_SURFACE) {Log.i("GLThread", "releasing EGL surface because paused tid=" + getId());}stopEglSurfaceLocked();}// When pausing, optionally release the EGL Context:if (pausing && mHaveEglContext) {GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef.get();boolean preserveEglContextOnPause = view == null ? false : view.mPreserveEGLContextOnPause;if (!preserveEglContextOnPause || sGLThreadManager.shouldReleaseEGLContextWhenPausing()) {stopEglContextLocked();if (LOG_SURFACE) {Log.i("GLThread", "releasing EGL context because paused tid=" + getId());}}}// When pausing, optionally terminate EGL:if (pausing) {if (sGLThreadManager.shouldTerminateEGLWhenPausing()) {mEglHelper.finish();if (LOG_SURFACE) {Log.i("GLThread", "terminating EGL because paused tid=" + getId());}}}// Have we lost the SurfaceView surface?if ((!mHasSurface) && (!mWaitingForSurface)) {if (LOG_SURFACE) {Log.i("GLThread", "noticed surfaceView surface lost tid=" + getId());}if (mHaveEglSurface) {stopEglSurfaceLocked();}mWaitingForSurface = true;mSurfaceIsBad = false;sGLThreadManager.notifyAll();}// Have we acquired the surface view surface?if (mHasSurface && mWaitingForSurface) {if (LOG_SURFACE) {Log.i("GLThread", "noticed surfaceView surface acquired tid=" + getId());}mWaitingForSurface = false;sGLThreadManager.notifyAll();}if (doRenderNotification) {if (LOG_SURFACE) {Log.i("GLThread", "sending render notification tid=" + getId());}wantRenderNotification = false;doRenderNotification = false;mRenderComplete = true;sGLThreadManager.notifyAll();}// Ready to draw?if (readyToDraw()) {// If we don't have an EGL context, try to acquire one.if (!mHaveEglContext) {if (askedToReleaseEglContext) {askedToReleaseEglContext = false;} else if (sGLThreadManager.tryAcquireEglContextLocked(this)) {try {mEglHelper.start();} catch (RuntimeException t) {sGLThreadManager.releaseEglContextLocked(this);throw t;}mHaveEglContext = true;createEglContext = true;sGLThreadManager.notifyAll();}}if (mHaveEglContext && !mHaveEglSurface) {mHaveEglSurface = true;createEglSurface = true;createGlInterface = true;sizeChanged = true;}if (mHaveEglSurface) {if (mSizeChanged) {sizeChanged = true;w = mWidth;h = mHeight;wantRenderNotification = true;if (LOG_SURFACE) {Log.i("GLThread", "noticing that we want render notification tid=" + getId());}// Destroy and recreate the EGL surface.createEglSurface = true;mSizeChanged = false;}mRequestRender = false;sGLThreadManager.notifyAll();break;}}// By design, this is the only place in a GLThread thread where we wait().if (LOG_THREADS) {Log.i("GLThread", "waiting tid=" + getId() + " mHaveEglContext: " + mHaveEglContext + " mHaveEglSurface: " + mHaveEglSurface + " mFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface + " mPaused: " + mPaused + " mHasSurface: " + mHasSurface + " mSurfaceIsBad: " + mSurfaceIsBad + " mWaitingForSurface: " + mWaitingForSurface + " mWidth: " + mWidth + " mHeight: " + mHeight + " mRequestRender: " + mRequestRender + " mRenderMode: " + mRenderMode);}sGLThreadManager.wait();}}if (event != null) {event.run();event = null;continue;}if (createEglSurface) {if (LOG_SURFACE) {Log.w("GLThread", "egl createSurface");}if (mEglHelper.createSurface()) {synchronized (sGLThreadManager) {mFinishedCreatingEglSurface = true;sGLThreadManager.notifyAll();}} else {synchronized (sGLThreadManager) {mFinishedCreatingEglSurface = true;mSurfaceIsBad = true;sGLThreadManager.notifyAll();}continue;}createEglSurface = false;}if (createGlInterface) {gl = (GL10) mEglHelper.createGL();sGLThreadManager.checkGLDriver(gl);createGlInterface = false;}if (createEglContext) {if (LOG_RENDERER) {Log.w("GLThread", "onSurfaceCreated");}GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef.get();if (view != null) {view.mRenderer.onSurfaceCreated(gl, mEglHelper.mEglConfig);}createEglContext = false;}if (sizeChanged) {if (LOG_RENDERER) {Log.w("GLThread", "onSurfaceChanged(" + w + ", " + h + ")");}GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef.get();if (view != null) {view.mRenderer.onSurfaceChanged(gl, w, h);}sizeChanged = false;}if (LOG_RENDERER_DRAW_FRAME) {Log.w("GLThread", "onDrawFrame tid=" + getId());}{GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef.get();if (view != null) {view.mRenderer.onDrawFrame(gl);}}int swapError = mEglHelper.swap();switch(swapError) {case EGL10.EGL_SUCCESS:break;case EGL11.EGL_CONTEXT_LOST:if (LOG_SURFACE) {Log.i("GLThread", "egl context lost tid=" + getId());}lostEglContext = true;break;default:// Log the error to help developers understand why rendering stopped.EglHelper.logEglErrorAsWarning("GLThread", "eglSwapBuffers", swapError);synchronized (sGLThreadManager) {mSurfaceIsBad = true;sGLThreadManager.notifyAll();}break;}if (wantRenderNotification) {doRenderNotification = true;}}} finally {/* * clean-up everything... */synchronized (sGLThreadManager) {stopEglSurfaceLocked();stopEglContextLocked();}}}
public boolean ableToDraw() {return mHaveEglContext && mHaveEglSurface && readyToDraw();}
private boolean readyToDraw() {return (!mPaused) && mHasSurface && (!mSurfaceIsBad) && (mWidth > 0) && (mHeight > 0) && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY));}
public void setRenderMode(int renderMode) {if (!((RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= RENDERMODE_CONTINUOUSLY))) {throw new IllegalArgumentException("renderMode");}synchronized (sGLThreadManager) {mRenderMode = renderMode;sGLThreadManager.notifyAll();}}
public int getRenderMode() {synchronized (sGLThreadManager) {return mRenderMode;}}
public void requestRender() {synchronized (sGLThreadManager) {mRequestRender = true;sGLThreadManager.notifyAll();}}
public void surfaceCreated() {synchronized (sGLThreadManager) {if (LOG_THREADS) {Log.i("GLThread", "surfaceCreated tid=" + getId());}mHasSurface = true;mFinishedCreatingEglSurface = false;sGLThreadManager.notifyAll();while (mWaitingForSurface && !mFinishedCreatingEglSurface && !mExited) {try {sGLThreadManager.wait();} catch (InterruptedException e) {Thread.currentThread().interrupt();}}}}
public void surfaceDestroyed() {synchronized (sGLThreadManager) {if (LOG_THREADS) {Log.i("GLThread", "surfaceDestroyed tid=" + getId());}mHasSurface = false;sGLThreadManager.notifyAll();while ((!mWaitingForSurface) && (!mExited)) {try {sGLThreadManager.wait();} catch (InterruptedException e) {Thread.currentThread().interrupt();}}}}
public void onPause() {synchronized (sGLThreadManager) {if (LOG_PAUSE_RESUME) {Log.i("GLThread", "onPause tid=" + getId());}mRequestPaused = true;sGLThreadManager.notifyAll();while ((!mExited) && (!mPaused)) {if (LOG_PAUSE_RESUME) {Log.i("Main thread", "onPause waiting for mPaused.");}try {sGLThreadManager.wait();} catch (InterruptedException ex) {Thread.currentThread().interrupt();}}}}
public void onResume() {synchronized (sGLThreadManager) {if (LOG_PAUSE_RESUME) {Log.i("GLThread", "onResume tid=" + getId());}mRequestPaused = false;mRequestRender = true;mRenderComplete = false;sGLThreadManager.notifyAll();while ((!mExited) && mPaused && (!mRenderComplete)) {if (LOG_PAUSE_RESUME) {Log.i("Main thread", "onResume waiting for !mPaused.");}try {sGLThreadManager.wait();} catch (InterruptedException ex) {Thread.currentThread().interrupt();}}}}
public void onWindowResize(int w, int h) {synchronized (sGLThreadManager) {mWidth = w;mHeight = h;mSizeChanged = true;mRequestRender = true;mRenderComplete = false;sGLThreadManager.notifyAll();// Wait for thread to react to resize and render a framewhile (!mExited && !mPaused && !mRenderComplete && ableToDraw()) {if (LOG_SURFACE) {Log.i("Main thread", "onWindowResize waiting for render complete from tid=" + getId());}try {sGLThreadManager.wait();} catch (InterruptedException ex) {Thread.currentThread().interrupt();}}}}
public void requestExitAndWait() {// deadlock!synchronized (sGLThreadManager) {mShouldExit = true;sGLThreadManager.notifyAll();while (!mExited) {try {sGLThreadManager.wait();} catch (InterruptedException ex) {Thread.currentThread().interrupt();}}}}
public void requestReleaseEglContextLocked() {mShouldReleaseEglContext = true;sGLThreadManager.notifyAll();}
public void queueEvent(Runnable r) {if (r == null) {throw new IllegalArgumentException("r must not be null");}synchronized (sGLThreadManager) {mEventQueue.add(r);sGLThreadManager.notifyAll();}}
public void close() {flushBuilder();}
public void flush() {flushBuilder();}
public void write(char[] buf, int offset, int count) {for (int i = 0; i < count; i++) {char c = buf[offset + i];if (c == '\n') {flushBuilder();} else {mBuilder.append(c);}}}
private void flushBuilder() {if (mBuilder.length() > 0) {Log.v("GLSurfaceView", mBuilder.toString());mBuilder.delete(0, mBuilder.length());}}
private void checkRenderThreadState() {if (mGLThread != null) {throw new IllegalStateException("setRenderer has already been called for this instance.");}}
public synchronized void threadExiting(GLThread thread) {if (LOG_THREADS) {Log.i("GLThread", "exiting tid=" + thread.getId());}thread.mExited = true;if (mEglOwner == thread) {mEglOwner = null;}notifyAll();}
public boolean tryAcquireEglContextLocked(GLThread thread) {if (mEglOwner == thread || mEglOwner == null) {mEglOwner = thread;notifyAll();return true;}checkGLESVersion();if (mMultipleGLESContextsAllowed) {return true;}// reacquire the EGL context.if (mEglOwner != null) {mEglOwner.requestReleaseEglContextLocked();}return false;}
public void releaseEglContextLocked(GLThread thread) {if (mEglOwner == thread) {mEglOwner = null;}notifyAll();}
public synchronized boolean shouldReleaseEGLContextWhenPausing() {// Otherwise the device could run out of EGL contexts.return mLimitedGLESContexts;}
public synchronized boolean shouldTerminateEGLWhenPausing() {checkGLESVersion();return !mMultipleGLESContextsAllowed;}
public synchronized void checkGLDriver(GL10 gl) {if (!mGLESDriverCheckComplete) {checkGLESVersion();String renderer = gl.glGetString(GL10.GL_RENDERER);if (mGLESVersion < kGLES_20) {mMultipleGLESContextsAllowed = !renderer.startsWith(kMSM7K_RENDERER_PREFIX);notifyAll();}mLimitedGLESContexts = !mMultipleGLESContextsAllowed;if (LOG_SURFACE) {Log.w(TAG, "checkGLDriver renderer = \"" + renderer + "\" multipleContextsAllowed = " + mMultipleGLESContextsAllowed + " mLimitedGLESContexts = " + mLimitedGLESContexts);}mGLESDriverCheckComplete = true;}}
private void checkGLESVersion() {if (!mGLESVersionCheckComplete) {// so we force GL ES version to 2.0mGLESVersion = kGLES_20;if (mGLESVersion >= kGLES_20) {mMultipleGLESContextsAllowed = true;}if (LOG_SURFACE) {Log.w(TAG, "checkGLESVersion mGLESVersion =" + " " + mGLESVersion + " mMultipleGLESContextsAllowed = " + mMultipleGLESContextsAllowed);}mGLESVersionCheckComplete = true;}}protected KeyEvent newObject() {return new KeyEvent();}
protected TouchEvent newObject() {return new TouchEvent();}
public void setListeners(Canvas canvas) {if (this.canvas != null) {canvas.removeMouseListener(this);canvas.removeMouseMotionListener(this);canvas.removeMouseWheelListener(this);canvas.removeKeyListener(this);}canvas.addMouseListener(this);canvas.addMouseMotionListener(this);canvas.addMouseWheelListener(this);canvas.addKeyListener(this);canvas.setFocusTraversalKeysEnabled(false);this.canvas = canvas;}
public float getAccelerometerX() {return 0;}
public float getAccelerometerY() {return 0;}
public float getAccelerometerZ() {return 0;}
public void getTextInput(final TextInputListener listener, final String title, final String text, final String hint) {SwingUtilities.invokeLater(new Runnable() {
@Overridepublic void run() {JPanel panel = new JPanel(new FlowLayout());JPanel textPanel = new JPanel() {
public boolean isOptimizedDrawingEnabled() {return false;}
;};textPanel.setLayout(new OverlayLayout(textPanel));panel.add(textPanel);final JTextField textField = new JTextField(20);textField.setText(text);textField.setAlignmentX(0.0f);textPanel.add(textField);final JLabel placeholderLabel = new JLabel(hint);placeholderLabel.setForeground(Color.GRAY);placeholderLabel.setAlignmentX(0.0f);textPanel.add(placeholderLabel, 0);textField.getDocument().addDocumentListener(new DocumentListener() {
@Overridepublic void removeUpdate(DocumentEvent arg0) {this.updated();}
@Overridepublic void insertUpdate(DocumentEvent arg0) {this.updated();}
@Overridepublic void changedUpdate(DocumentEvent arg0) {this.updated();}
private void updated() {if (textField.getText().length() == 0)placeholderLabel.setVisible(true);elseplaceholderLabel.setVisible(false);}});JOptionPane pane = new JOptionPane(panel, JOptionPane.QUESTION_MESSAGE, JOptionPane.OK_CANCEL_OPTION, null, null, null);pane.setInitialValue(null);pane.setComponentOrientation(JOptionPane.getRootFrame().getComponentOrientation());Border border = textField.getBorder();placeholderLabel.setBorder(new EmptyBorder(border.getBorderInsets(textField)));JDialog dialog = pane.createDialog(null, title);pane.selectInitialValue();dialog.addWindowFocusListener(new WindowFocusListener() {
@Overridepublic void windowLostFocus(WindowEvent arg0) {}
@Overridepublic void windowGainedFocus(WindowEvent arg0) {textField.requestFocusInWindow();}});dialog.setVisible(true);dialog.dispose();Object selectedValue = pane.getValue();if (selectedValue != null && (selectedValue instanceof Integer) && ((Integer) selectedValue).intValue() == JOptionPane.OK_OPTION) {listener.input(textField.getText());} else {listener.canceled();}}});}
public void run() {JPanel panel = new JPanel(new FlowLayout());JPanel textPanel = new JPanel() {
public boolean isOptimizedDrawingEnabled() {return false;}
;};textPanel.setLayout(new OverlayLayout(textPanel));panel.add(textPanel);final JTextField textField = new JTextField(20);textField.setText(text);textField.setAlignmentX(0.0f);textPanel.add(textField);final JLabel placeholderLabel = new JLabel(hint);placeholderLabel.setForeground(Color.GRAY);placeholderLabel.setAlignmentX(0.0f);textPanel.add(placeholderLabel, 0);textField.getDocument().addDocumentListener(new DocumentListener() {
@Overridepublic void removeUpdate(DocumentEvent arg0) {this.updated();}
@Overridepublic void insertUpdate(DocumentEvent arg0) {this.updated();}
@Overridepublic void changedUpdate(DocumentEvent arg0) {this.updated();}
private void updated() {if (textField.getText().length() == 0)placeholderLabel.setVisible(true);elseplaceholderLabel.setVisible(false);}});JOptionPane pane = new JOptionPane(panel, JOptionPane.QUESTION_MESSAGE, JOptionPane.OK_CANCEL_OPTION, null, null, null);pane.setInitialValue(null);pane.setComponentOrientation(JOptionPane.getRootFrame().getComponentOrientation());Border border = textField.getBorder();placeholderLabel.setBorder(new EmptyBorder(border.getBorderInsets(textField)));JDialog dialog = pane.createDialog(null, title);pane.selectInitialValue();dialog.addWindowFocusListener(new WindowFocusListener() {
@Overridepublic void windowLostFocus(WindowEvent arg0) {}
@Overridepublic void windowGainedFocus(WindowEvent arg0) {textField.requestFocusInWindow();}});dialog.setVisible(true);dialog.dispose();Object selectedValue = pane.getValue();if (selectedValue != null && (selectedValue instanceof Integer) && ((Integer) selectedValue).intValue() == JOptionPane.OK_OPTION) {listener.input(textField.getText());} else {listener.canceled();}}
public boolean isOptimizedDrawingEnabled() {return false;}
public void removeUpdate(DocumentEvent arg0) {this.updated();}
public void insertUpdate(DocumentEvent arg0) {this.updated();}
public void changedUpdate(DocumentEvent arg0) {this.updated();}
private void updated() {if (textField.getText().length() == 0)placeholderLabel.setVisible(true);elseplaceholderLabel.setVisible(false);}
public void windowLostFocus(WindowEvent arg0) {}
public void windowGainedFocus(WindowEvent arg0) {textField.requestFocusInWindow();}
public int getX() {return touchX;}
public int getX(int pointer) {if (pointer == 0)return touchX;elsereturn 0;}
public int getY() {return touchY;}
public int getY(int pointer) {if (pointer == 0)return touchY;elsereturn 0;}
public synchronized boolean isKeyPressed(int key) {if (key == Input.Keys.ANY_KEY) {return keyCount > 0;}if (key < 0 || key > 255) {return false;}return keys[key];}
public synchronized boolean isKeyJustPressed(int key) {if (key == Input.Keys.ANY_KEY) {return keyJustPressed;}if (key < 0 || key > 255) {return false;}return justPressedKeys[key];}
public boolean isTouched() {return touchDown;}
public boolean isTouched(int pointer) {if (pointer == 0)return touchDown;elsereturn false;}
void processEvents() {synchronized (this) {justTouched = false;if (keyJustPressed) {keyJustPressed = false;for (int i = 0; i < justPressedKeys.length; i++) {justPressedKeys[i] = false;}}if (processor != null) {InputProcessor processor = this.processor;int len = keyEvents.size();for (int i = 0; i < len; i++) {KeyEvent e = keyEvents.get(i);currentEventTimeStamp = e.timeStamp;switch(e.type) {case KeyEvent.KEY_DOWN:processor.keyDown(e.keyCode);keyJustPressed = true;justPressedKeys[e.keyCode] = true;break;case KeyEvent.KEY_UP:processor.keyUp(e.keyCode);break;case KeyEvent.KEY_TYPED:processor.keyTyped(e.keyChar);}usedKeyEvents.free(e);}len = touchEvents.size();for (int i = 0; i < len; i++) {TouchEvent e = touchEvents.get(i);currentEventTimeStamp = e.timeStamp;switch(e.type) {case TouchEvent.TOUCH_DOWN:processor.touchDown(e.x, e.y, e.pointer, e.button);justTouched = true;break;case TouchEvent.TOUCH_UP:processor.touchUp(e.x, e.y, e.pointer, e.button);break;case TouchEvent.TOUCH_DRAGGED:processor.touchDragged(e.x, e.y, e.pointer);break;case TouchEvent.TOUCH_MOVED:processor.mouseMoved(e.x, e.y);break;case TouchEvent.TOUCH_SCROLLED:processor.scrolled(e.scrollAmount);break;}usedTouchEvents.free(e);}} else {int len = touchEvents.size();for (int i = 0; i < len; i++) {TouchEvent event = touchEvents.get(i);if (event.type == TouchEvent.TOUCH_DOWN)justTouched = true;usedTouchEvents.free(event);}len = keyEvents.size();for (int i = 0; i < len; i++) {usedKeyEvents.free(keyEvents.get(i));}}if (touchEvents.size() == 0) {deltaX = 0;deltaY = 0;}keyEvents.clear();touchEvents.clear();}}
public void setCatchBackKey(boolean catchBack) {}
public boolean isCatchBackKey() {return false;}
public void setCatchMenuKey(boolean catchMenu) {}
public boolean isCatchMenuKey() {return false;}
public void setOnscreenKeyboardVisible(boolean visible) {}
public void mouseDragged(MouseEvent e) {synchronized (this) {TouchEvent event = usedTouchEvents.obtain();event.pointer = 0;event.x = e.getX();event.y = e.getY();event.type = TouchEvent.TOUCH_DRAGGED;event.timeStamp = System.nanoTime();touchEvents.add(event);deltaX = event.x - touchX;deltaY = event.y - touchY;touchX = event.x;touchY = event.y;checkCatched(e);lwjglAwtCanvas.graphics.requestRendering();}}
public void mouseMoved(MouseEvent e) {synchronized (this) {TouchEvent event = usedTouchEvents.obtain();event.pointer = 0;event.x = e.getX();event.y = e.getY();event.type = TouchEvent.TOUCH_MOVED;event.timeStamp = System.nanoTime();touchEvents.add(event);deltaX = event.x - touchX;deltaY = event.y - touchY;touchX = event.x;touchY = event.y;checkCatched(e);lwjglAwtCanvas.graphics.requestRendering();}}
public void mouseClicked(MouseEvent arg0) {}
public void mouseEntered(MouseEvent e) {touchX = e.getX();touchY = e.getY();checkCatched(e);lwjglAwtCanvas.graphics.requestRendering();}
public void mouseExited(MouseEvent e) {checkCatched(e);lwjglAwtCanvas.graphics.requestRendering();}
private void checkCatched(MouseEvent e) {if (catched && robot != null && canvas.isShowing()) {int x = Math.max(0, Math.min(e.getX(), canvas.getWidth()) - 1) + canvas.getLocationOnScreen().x;int y = Math.max(0, Math.min(e.getY(), canvas.getHeight()) - 1) + canvas.getLocationOnScreen().y;if (e.getX() < 0 || e.getX() >= canvas.getWidth() || e.getY() < 0 || e.getY() >= canvas.getHeight()) {robot.mouseMove(x, y);}}}
private int toGdxButton(int swingButton) {if (swingButton == MouseEvent.BUTTON1)return Buttons.LEFT;if (swingButton == MouseEvent.BUTTON2)return Buttons.MIDDLE;if (swingButton == MouseEvent.BUTTON3)return Buttons.RIGHT;return Buttons.LEFT;}
public void mousePressed(MouseEvent e) {synchronized (this) {TouchEvent event = usedTouchEvents.obtain();event.pointer = 0;event.x = e.getX();event.y = e.getY();event.type = TouchEvent.TOUCH_DOWN;event.button = toGdxButton(e.getButton());event.timeStamp = System.nanoTime();touchEvents.add(event);deltaX = event.x - touchX;deltaY = event.y - touchY;touchX = event.x;touchY = event.y;touchDown = true;pressedButtons.add(event.button);lwjglAwtCanvas.graphics.requestRendering();}}
public void mouseReleased(MouseEvent e) {synchronized (this) {TouchEvent event = usedTouchEvents.obtain();event.pointer = 0;event.x = e.getX();event.y = e.getY();event.button = toGdxButton(e.getButton());event.type = TouchEvent.TOUCH_UP;event.timeStamp = System.nanoTime();touchEvents.add(event);deltaX = event.x - touchX;deltaY = event.y - touchY;touchX = event.x;touchY = event.y;pressedButtons.remove(event.button);if (pressedButtons.size == 0)touchDown = false;lwjglAwtCanvas.graphics.requestRendering();}}
public void mouseWheelMoved(MouseWheelEvent e) {synchronized (this) {TouchEvent event = usedTouchEvents.obtain();event.pointer = 0;event.type = TouchEvent.TOUCH_SCROLLED;event.scrollAmount = e.getWheelRotation();event.timeStamp = System.nanoTime();touchEvents.add(event);lwjglAwtCanvas.graphics.requestRendering();}}
public void keyPressed(java.awt.event.KeyEvent e) {synchronized (this) {KeyEvent event = usedKeyEvents.obtain();event.keyChar = 0;event.keyCode = translateKeyCode(e.getKeyCode());event.type = KeyEvent.KEY_DOWN;event.timeStamp = System.nanoTime();keyEvents.add(event);if (!keys[event.keyCode]) {keyCount++;keys[event.keyCode] = true;}lwjglAwtCanvas.graphics.requestRendering();}}
public void keyReleased(java.awt.event.KeyEvent e) {synchronized (this) {KeyEvent event = usedKeyEvents.obtain();event.keyChar = 0;event.keyCode = translateKeyCode(e.getKeyCode());event.type = KeyEvent.KEY_UP;event.timeStamp = System.nanoTime();keyEvents.add(event);if (keys[event.keyCode]) {keyCount--;keys[event.keyCode] = false;}lwjglAwtCanvas.graphics.requestRendering();}}
public void keyTyped(java.awt.event.KeyEvent e) {synchronized (this) {KeyEvent event = usedKeyEvents.obtain();event.keyChar = e.getKeyChar();event.keyCode = 0;event.type = KeyEvent.KEY_TYPED;event.timeStamp = System.nanoTime();keyEvents.add(event);lwjglAwtCanvas.graphics.requestRendering();}}
protected static int translateKeyCode(int keyCode) {switch(keyCode) {case java.awt.event.KeyEvent.VK_ADD:return Input.Keys.PLUS;case java.awt.event.KeyEvent.VK_SUBTRACT:return Input.Keys.MINUS;case java.awt.event.KeyEvent.VK_0:return Input.Keys.NUM_0;case java.awt.event.KeyEvent.VK_1:return Input.Keys.NUM_1;case java.awt.event.KeyEvent.VK_2:return Input.Keys.NUM_2;case java.awt.event.KeyEvent.VK_3:return Input.Keys.NUM_3;case java.awt.event.KeyEvent.VK_4:return Input.Keys.NUM_4;case java.awt.event.KeyEvent.VK_5:return Input.Keys.NUM_5;case java.awt.event.KeyEvent.VK_6:return Input.Keys.NUM_6;case java.awt.event.KeyEvent.VK_7:return Input.Keys.NUM_7;case java.awt.event.KeyEvent.VK_8:return Input.Keys.NUM_8;case java.awt.event.KeyEvent.VK_9:return Input.Keys.NUM_9;case java.awt.event.KeyEvent.VK_A:return Input.Keys.A;case java.awt.event.KeyEvent.VK_B:return Input.Keys.B;case java.awt.event.KeyEvent.VK_C:return Input.Keys.C;case java.awt.event.KeyEvent.VK_D:return Input.Keys.D;case java.awt.event.KeyEvent.VK_E:return Input.Keys.E;case java.awt.event.KeyEvent.VK_F:return Input.Keys.F;case java.awt.event.KeyEvent.VK_G:return Input.Keys.G;case java.awt.event.KeyEvent.VK_H:return Input.Keys.H;case java.awt.event.KeyEvent.VK_I:return Input.Keys.I;case java.awt.event.KeyEvent.VK_J:return Input.Keys.J;case java.awt.event.KeyEvent.VK_K:return Input.Keys.K;case java.awt.event.KeyEvent.VK_L:return Input.Keys.L;case java.awt.event.KeyEvent.VK_M:return Input.Keys.M;case java.awt.event.KeyEvent.VK_N:return Input.Keys.N;case java.awt.event.KeyEvent.VK_O:return Input.Keys.O;case java.awt.event.KeyEvent.VK_P:return Input.Keys.P;case java.awt.event.KeyEvent.VK_Q:return Input.Keys.Q;case java.awt.event.KeyEvent.VK_R:return Input.Keys.R;case java.awt.event.KeyEvent.VK_S:return Input.Keys.S;case java.awt.event.KeyEvent.VK_T:return Input.Keys.T;case java.awt.event.KeyEvent.VK_U:return Input.Keys.U;case java.awt.event.KeyEvent.VK_V:return Input.Keys.V;case java.awt.event.KeyEvent.VK_W:return Input.Keys.W;case java.awt.event.KeyEvent.VK_X:return Input.Keys.X;case java.awt.event.KeyEvent.VK_Y:return Input.Keys.Y;case java.awt.event.KeyEvent.VK_Z:return Input.Keys.Z;case java.awt.event.KeyEvent.VK_ALT:return Input.Keys.ALT_LEFT;case java.awt.event.KeyEvent.VK_ALT_GRAPH:return Input.Keys.ALT_RIGHT;case java.awt.event.KeyEvent.VK_BACK_SLASH:return Input.Keys.BACKSLASH;case java.awt.event.KeyEvent.VK_COMMA:return Input.Keys.COMMA;case java.awt.event.KeyEvent.VK_DELETE:return Input.Keys.FORWARD_DEL;case java.awt.event.KeyEvent.VK_LEFT:return Input.Keys.DPAD_LEFT;case java.awt.event.KeyEvent.VK_RIGHT:return Input.Keys.DPAD_RIGHT;case java.awt.event.KeyEvent.VK_UP:return Input.Keys.DPAD_UP;case java.awt.event.KeyEvent.VK_DOWN:return Input.Keys.DPAD_DOWN;case java.awt.event.KeyEvent.VK_ENTER:return Input.Keys.ENTER;case java.awt.event.KeyEvent.VK_HOME:return Input.Keys.HOME;case java.awt.event.KeyEvent.VK_MINUS:return Input.Keys.MINUS;case java.awt.event.KeyEvent.VK_PERIOD:return Input.Keys.PERIOD;case java.awt.event.KeyEvent.VK_PLUS:return Input.Keys.PLUS;case java.awt.event.KeyEvent.VK_SEMICOLON:return Input.Keys.SEMICOLON;case java.awt.event.KeyEvent.VK_SHIFT:return Input.Keys.SHIFT_LEFT;case java.awt.event.KeyEvent.VK_SLASH:return Input.Keys.SLASH;case java.awt.event.KeyEvent.VK_SPACE:return Input.Keys.SPACE;case java.awt.event.KeyEvent.VK_TAB:return Input.Keys.TAB;case java.awt.event.KeyEvent.VK_BACK_SPACE:return Input.Keys.DEL;case java.awt.event.KeyEvent.VK_CONTROL:return Input.Keys.CONTROL_LEFT;case java.awt.event.KeyEvent.VK_ESCAPE:return Input.Keys.ESCAPE;case java.awt.event.KeyEvent.VK_END:return Input.Keys.END;case java.awt.event.KeyEvent.VK_INSERT:return Input.Keys.INSERT;case java.awt.event.KeyEvent.VK_PAGE_UP:return Input.Keys.PAGE_UP;case java.awt.event.KeyEvent.VK_PAGE_DOWN:return Input.Keys.PAGE_DOWN;case java.awt.event.KeyEvent.VK_F1:return Input.Keys.F1;case java.awt.event.KeyEvent.VK_F2:return Input.Keys.F2;case java.awt.event.KeyEvent.VK_F3:return Input.Keys.F3;case java.awt.event.KeyEvent.VK_F4:return Input.Keys.F4;case java.awt.event.KeyEvent.VK_F5:return Input.Keys.F5;case java.awt.event.KeyEvent.VK_F6:return Input.Keys.F6;case java.awt.event.KeyEvent.VK_F7:return Input.Keys.F7;case java.awt.event.KeyEvent.VK_F8:return Input.Keys.F8;case java.awt.event.KeyEvent.VK_F9:return Input.Keys.F9;case java.awt.event.KeyEvent.VK_F10:return Input.Keys.F10;case java.awt.event.KeyEvent.VK_F11:return Input.Keys.F11;case java.awt.event.KeyEvent.VK_F12:return Input.Keys.F12;case java.awt.event.KeyEvent.VK_COLON:return Input.Keys.COLON;case java.awt.event.KeyEvent.VK_NUMPAD0:return Input.Keys.NUM_0;case java.awt.event.KeyEvent.VK_NUMPAD1:return Input.Keys.NUM_1;case java.awt.event.KeyEvent.VK_NUMPAD2:return Input.Keys.NUM_2;case java.awt.event.KeyEvent.VK_NUMPAD3:return Input.Keys.NUM_3;case java.awt.event.KeyEvent.VK_NUMPAD4:return Input.Keys.NUM_4;case java.awt.event.KeyEvent.VK_NUMPAD5:return Input.Keys.NUM_5;case java.awt.event.KeyEvent.VK_NUMPAD6:return Input.Keys.NUM_6;case java.awt.event.KeyEvent.VK_NUMPAD7:return Input.Keys.NUM_7;case java.awt.event.KeyEvent.VK_NUMPAD8:return Input.Keys.NUM_8;case java.awt.event.KeyEvent.VK_NUMPAD9:return Input.Keys.NUM_9;}return Input.Keys.UNKNOWN;}
public void setInputProcessor(InputProcessor processor) {synchronized (this) {this.processor = processor;}}
public InputProcessor getInputProcessor() {return this.processor;}
public void vibrate(int milliseconds) {}
public boolean justTouched() {return justTouched;}
public boolean isButtonPressed(int button) {return pressedButtons.contains(button);}
public void vibrate(long[] pattern, int repeat) {}
public void cancelVibrate() {}
public float getAzimuth() {return 0;}
public float getPitch() {return 0;}
public float getRoll() {return 0;}
public boolean isPeripheralAvailable(Peripheral peripheral) {if (peripheral == Peripheral.HardwareKeyboard)return true;return false;}
public int getRotation() {return 0;}
public Orientation getNativeOrientation() {return Orientation.Landscape;}
public void setCursorCatched(boolean catched) {this.catched = catched;showCursor(!catched);}
private void showCursor(boolean visible) {if (!visible) {Toolkit t = Toolkit.getDefaultToolkit();Image i = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);Cursor noCursor = t.createCustomCursor(i, new Point(0, 0), "none");JFrame frame = findJFrame(canvas);frame.setCursor(noCursor);} else {JFrame frame = findJFrame(canvas);frame.setCursor(Cursor.getDefaultCursor());}}
protected static JFrame findJFrame(Component component) {Container parent = component.getParent();while (parent != null) {if (parent instanceof JFrame) {return (JFrame) parent;}parent = parent.getParent();}return null;}
public boolean isCursorCatched() {return catched;}
public int getDeltaX() {return deltaX;}
public int getDeltaX(int pointer) {if (pointer == 0)return deltaX;return 0;}
public int getDeltaY() {return deltaY;}
public int getDeltaY(int pointer) {if (pointer == 0)return deltaY;return 0;}
public void setCursorPosition(int x, int y) {if (robot != null) {robot.mouseMove(canvas.getLocationOnScreen().x + x, canvas.getLocationOnScreen().y + y);}}
public long getCurrentEventTime() {return currentEventTimeStamp;}
public void getRotationMatrix(float[] matrix) {}public static long SwigDirector_btIDebugDraw_getDefaultColors(btIDebugDraw jself) {return btIDebugDraw.DefaultColors.getCPtr(jself.getDefaultColors());}
public static void SwigDirector_btIDebugDraw_setDefaultColors(btIDebugDraw jself, long arg0) {jself.setDefaultColors(new btIDebugDraw.DefaultColors(arg0, false));}
public static void SwigDirector_btIDebugDraw_drawLine__SWIG_0(btIDebugDraw jself, Vector3 from, Vector3 to, Vector3 color) {jself.drawLine(from, to, color);}
public static void SwigDirector_btIDebugDraw_drawLine__SWIG_1(btIDebugDraw jself, Vector3 from, Vector3 to, Vector3 fromColor, Vector3 toColor) {jself.drawLine(from, to, fromColor, toColor);}
public static void SwigDirector_btIDebugDraw_drawSphere__SWIG_0(btIDebugDraw jself, float radius, Matrix4 transform, Vector3 color) {jself.drawSphere(radius, transform, color);}
public static void SwigDirector_btIDebugDraw_drawSphere__SWIG_1(btIDebugDraw jself, Vector3 p, float radius, Vector3 color) {jself.drawSphere(p, radius, color);}
public static void SwigDirector_btIDebugDraw_drawTriangle__SWIG_0(btIDebugDraw jself, Vector3 v0, Vector3 v1, Vector3 v2, Vector3 arg3, Vector3 arg4, Vector3 arg5, Vector3 color, float alpha) {jself.drawTriangle(v0, v1, v2, arg3, arg4, arg5, color, alpha);}
public static void SwigDirector_btIDebugDraw_drawTriangle__SWIG_1(btIDebugDraw jself, Vector3 v0, Vector3 v1, Vector3 v2, Vector3 color, float arg4) {jself.drawTriangle(v0, v1, v2, color, arg4);}
public static void SwigDirector_btIDebugDraw_drawContactPoint(btIDebugDraw jself, Vector3 PointOnB, Vector3 normalOnB, float distance, int lifeTime, Vector3 color) {jself.drawContactPoint(PointOnB, normalOnB, distance, lifeTime, color);}
public static void SwigDirector_btIDebugDraw_reportErrorWarning(btIDebugDraw jself, String warningString) {jself.reportErrorWarning(warningString);}
public static void SwigDirector_btIDebugDraw_draw3dText(btIDebugDraw jself, Vector3 location, String textString) {jself.draw3dText(location, textString);}
public static void SwigDirector_btIDebugDraw_setDebugMode(btIDebugDraw jself, int debugMode) {jself.setDebugMode(debugMode);}
public static int SwigDirector_btIDebugDraw_getDebugMode(btIDebugDraw jself) {return jself.getDebugMode();}
public static void SwigDirector_btIDebugDraw_drawAabb(btIDebugDraw jself, Vector3 from, Vector3 to, Vector3 color) {jself.drawAabb(from, to, color);}
public static void SwigDirector_btIDebugDraw_drawTransform(btIDebugDraw jself, Matrix4 transform, float orthoLen) {jself.drawTransform(transform, orthoLen);}
public static void SwigDirector_btIDebugDraw_drawArc__SWIG_0(btIDebugDraw jself, Vector3 center, Vector3 normal, Vector3 axis, float radiusA, float radiusB, float minAngle, float maxAngle, Vector3 color, boolean drawSect, float stepDegrees) {jself.drawArc(center, normal, axis, radiusA, radiusB, minAngle, maxAngle, color, drawSect, stepDegrees);}
public static void SwigDirector_btIDebugDraw_drawArc__SWIG_1(btIDebugDraw jself, Vector3 center, Vector3 normal, Vector3 axis, float radiusA, float radiusB, float minAngle, float maxAngle, Vector3 color, boolean drawSect) {jself.drawArc(center, normal, axis, radiusA, radiusB, minAngle, maxAngle, color, drawSect);}
public static void SwigDirector_btIDebugDraw_drawSpherePatch__SWIG_0(btIDebugDraw jself, Vector3 center, Vector3 up, Vector3 axis, float radius, float minTh, float maxTh, float minPs, float maxPs, Vector3 color, float stepDegrees, boolean drawCenter) {jself.drawSpherePatch(center, up, axis, radius, minTh, maxTh, minPs, maxPs, color, stepDegrees, drawCenter);}
public static void SwigDirector_btIDebugDraw_drawSpherePatch__SWIG_1(btIDebugDraw jself, Vector3 center, Vector3 up, Vector3 axis, float radius, float minTh, float maxTh, float minPs, float maxPs, Vector3 color, float stepDegrees) {jself.drawSpherePatch(center, up, axis, radius, minTh, maxTh, minPs, maxPs, color, stepDegrees);}
public static void SwigDirector_btIDebugDraw_drawSpherePatch__SWIG_2(btIDebugDraw jself, Vector3 center, Vector3 up, Vector3 axis, float radius, float minTh, float maxTh, float minPs, float maxPs, Vector3 color) {jself.drawSpherePatch(center, up, axis, radius, minTh, maxTh, minPs, maxPs, color);}
public static void SwigDirector_btIDebugDraw_drawBox__SWIG_0(btIDebugDraw jself, Vector3 bbMin, Vector3 bbMax, Vector3 color) {jself.drawBox(bbMin, bbMax, color);}
public static void SwigDirector_btIDebugDraw_drawBox__SWIG_1(btIDebugDraw jself, Vector3 bbMin, Vector3 bbMax, Matrix4 trans, Vector3 color) {jself.drawBox(bbMin, bbMax, trans, color);}
public static void SwigDirector_btIDebugDraw_drawCapsule(btIDebugDraw jself, float radius, float halfHeight, int upAxis, Matrix4 transform, Vector3 color) {jself.drawCapsule(radius, halfHeight, upAxis, transform, color);}
public static void SwigDirector_btIDebugDraw_drawCylinder(btIDebugDraw jself, float radius, float halfHeight, int upAxis, Matrix4 transform, Vector3 color) {jself.drawCylinder(radius, halfHeight, upAxis, transform, color);}
public static void SwigDirector_btIDebugDraw_drawCone(btIDebugDraw jself, float radius, float height, int upAxis, Matrix4 transform, Vector3 color) {jself.drawCone(radius, height, upAxis, transform, color);}
public static void SwigDirector_btIDebugDraw_drawPlane(btIDebugDraw jself, Vector3 planeNormal, float planeConst, Matrix4 transform, Vector3 color) {jself.drawPlane(planeNormal, planeConst, transform, color);}
public static void SwigDirector_btIDebugDraw_flushLines(btIDebugDraw jself) {jself.flushLines();}
public static void SwigDirector_btMotionState_getWorldTransform(btMotionState jself, Matrix4 worldTrans) {jself.getWorldTransform(worldTrans);}
public static void SwigDirector_btMotionState_setWorldTransform(btMotionState jself, Matrix4 worldTrans) {jself.setWorldTransform(worldTrans);}public void begin() {if (drawing)throw new IllegalStateException("PolygonSpriteBatch.end must be called before begin.");renderCalls = 0;Gdx.gl.glDepthMask(false);if (customShader != null)customShader.begin();elseshader.begin();setupMatrices();drawing = true;}
public void end() {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before end.");if (vertexIndex > 0)flush();lastTexture = null;drawing = false;GL20 gl = Gdx.gl;gl.glDepthMask(true);if (isBlendingEnabled())gl.glDisable(GL20.GL_BLEND);if (customShader != null)customShader.end();elseshader.end();}
public void setColor(Color tint) {color = tint.toFloatBits();}
public void setColor(float r, float g, float b, float a) {int intBits = (int) (255 * a) << 24 | (int) (255 * b) << 16 | (int) (255 * g) << 8 | (int) (255 * r);color = NumberUtils.intToFloatColor(intBits);}
public void setColor(float color) {this.color = color;}
public Color getColor() {int intBits = NumberUtils.floatToIntColor(color);Color color = this.tempColor;color.r = (intBits & 0xff) / 255f;color.g = ((intBits >>> 8) & 0xff) / 255f;color.b = ((intBits >>> 16) & 0xff) / 255f;color.a = ((intBits >>> 24) & 0xff) / 255f;return color;}
public float getPackedColor() {return color;}
public void draw(PolygonRegion region, float x, float y) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final short[] regionTriangles = region.triangles;final int regionTrianglesLength = regionTriangles.length;final float[] regionVertices = region.vertices;final int regionVerticesLength = regionVertices.length;final Texture texture = region.region.texture;if (texture != lastTexture)switchTexture(texture);else if (triangleIndex + regionTrianglesLength > triangles.length || vertexIndex + regionVerticesLength * VERTEX_SIZE / 2 > vertices.length)flush();int triangleIndex = this.triangleIndex;int vertexIndex = this.vertexIndex;final int startVertex = vertexIndex / VERTEX_SIZE;for (int i = 0; i < regionTrianglesLength; i++) triangles[triangleIndex++] = (short) (regionTriangles[i] + startVertex);this.triangleIndex = triangleIndex;final float[] vertices = this.vertices;final float color = this.color;final float[] textureCoords = region.textureCoords;for (int i = 0; i < regionVerticesLength; i += 2) {vertices[vertexIndex++] = regionVertices[i] + x;vertices[vertexIndex++] = regionVertices[i + 1] + y;vertices[vertexIndex++] = color;vertices[vertexIndex++] = textureCoords[i];vertices[vertexIndex++] = textureCoords[i + 1];}this.vertexIndex = vertexIndex;}
public void draw(PolygonRegion region, float x, float y, float width, float height) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final short[] regionTriangles = region.triangles;final int regionTrianglesLength = regionTriangles.length;final float[] regionVertices = region.vertices;final int regionVerticesLength = regionVertices.length;final TextureRegion textureRegion = region.region;final Texture texture = textureRegion.texture;if (texture != lastTexture)switchTexture(texture);else if (triangleIndex + regionTrianglesLength > triangles.length || vertexIndex + regionVerticesLength * VERTEX_SIZE / 2 > vertices.length)flush();int triangleIndex = this.triangleIndex;int vertexIndex = this.vertexIndex;final int startVertex = vertexIndex / VERTEX_SIZE;for (int i = 0, n = regionTriangles.length; i < n; i++) triangles[triangleIndex++] = (short) (regionTriangles[i] + startVertex);this.triangleIndex = triangleIndex;final float[] vertices = this.vertices;final float color = this.color;final float[] textureCoords = region.textureCoords;final float sX = width / textureRegion.regionWidth;final float sY = height / textureRegion.regionHeight;for (int i = 0; i < regionVerticesLength; i += 2) {vertices[vertexIndex++] = regionVertices[i] * sX + x;vertices[vertexIndex++] = regionVertices[i + 1] * sY + y;vertices[vertexIndex++] = color;vertices[vertexIndex++] = textureCoords[i];vertices[vertexIndex++] = textureCoords[i + 1];}this.vertexIndex = vertexIndex;}
public void draw(PolygonRegion region, float x, float y, float originX, float originY, float width, float height, float scaleX, float scaleY, float rotation) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final short[] regionTriangles = region.triangles;final int regionTrianglesLength = regionTriangles.length;final float[] regionVertices = region.vertices;final int regionVerticesLength = regionVertices.length;final TextureRegion textureRegion = region.region;Texture texture = textureRegion.texture;if (texture != lastTexture)switchTexture(texture);else if (triangleIndex + regionTrianglesLength > triangles.length || vertexIndex + regionVerticesLength * VERTEX_SIZE / 2 > vertices.length)flush();int triangleIndex = this.triangleIndex;int vertexIndex = this.vertexIndex;final int startVertex = vertexIndex / VERTEX_SIZE;for (int i = 0; i < regionTrianglesLength; i++) triangles[triangleIndex++] = (short) (regionTriangles[i] + startVertex);this.triangleIndex = triangleIndex;final float[] vertices = this.vertices;final float color = this.color;final float[] textureCoords = region.textureCoords;final float worldOriginX = x + originX;final float worldOriginY = y + originY;final float sX = width / textureRegion.regionWidth;final float sY = height / textureRegion.regionHeight;final float cos = MathUtils.cosDeg(rotation);final float sin = MathUtils.sinDeg(rotation);float fx, fy;for (int i = 0; i < regionVerticesLength; i += 2) {fx = (regionVertices[i] * sX - originX) * scaleX;fy = (regionVertices[i + 1] * sY - originY) * scaleY;vertices[vertexIndex++] = cos * fx - sin * fy + worldOriginX;vertices[vertexIndex++] = sin * fx + cos * fy + worldOriginY;vertices[vertexIndex++] = color;vertices[vertexIndex++] = textureCoords[i];vertices[vertexIndex++] = textureCoords[i + 1];}this.vertexIndex = vertexIndex;}
public void draw(Texture texture, float[] polygonVertices, int verticesOffset, int verticesCount, short[] polygonTriangles, int trianglesOffset, int trianglesCount) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + trianglesCount > triangles.length || vertexIndex + verticesCount > vertices.length)flush();int triangleIndex = this.triangleIndex;final int vertexIndex = this.vertexIndex;final int startVertex = vertexIndex / VERTEX_SIZE;for (int i = trianglesOffset, n = i + trianglesCount; i < n; i++) triangles[triangleIndex++] = (short) (polygonTriangles[i] + startVertex);this.triangleIndex = triangleIndex;System.arraycopy(polygonVertices, verticesOffset, vertices, vertexIndex, verticesCount);this.vertexIndex += verticesCount;}
public void draw(Texture texture, float x, float y, float originX, float originY, float width, float height, float scaleX, float scaleY, float rotation, int srcX, int srcY, int srcWidth, int srcHeight, boolean flipX, boolean flipY) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + 6 > triangles.length || vertexIndex + SPRITE_SIZE > vertices.length)flush();int triangleIndex = this.triangleIndex;final int startVertex = vertexIndex / VERTEX_SIZE;triangles[triangleIndex++] = (short) startVertex;triangles[triangleIndex++] = (short) (startVertex + 1);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 3);triangles[triangleIndex++] = (short) startVertex;this.triangleIndex = triangleIndex;// bottom left and top right corner points relative to originfinal float worldOriginX = x + originX;final float worldOriginY = y + originY;float fx = -originX;float fy = -originY;float fx2 = width - originX;float fy2 = height - originY;// scaleif (scaleX != 1 || scaleY != 1) {fx *= scaleX;fy *= scaleY;fx2 *= scaleX;fy2 *= scaleY;}// construct corner points, start from top left and go counter clockwisefinal float p1x = fx;final float p1y = fy;final float p2x = fx;final float p2y = fy2;final float p3x = fx2;final float p3y = fy2;final float p4x = fx2;final float p4y = fy;float x1;float y1;float x2;float y2;float x3;float y3;float x4;float y4;// rotateif (rotation != 0) {final float cos = MathUtils.cosDeg(rotation);final float sin = MathUtils.sinDeg(rotation);x1 = cos * p1x - sin * p1y;y1 = sin * p1x + cos * p1y;x2 = cos * p2x - sin * p2y;y2 = sin * p2x + cos * p2y;x3 = cos * p3x - sin * p3y;y3 = sin * p3x + cos * p3y;x4 = x1 + (x3 - x2);y4 = y3 - (y2 - y1);} else {x1 = p1x;y1 = p1y;x2 = p2x;y2 = p2y;x3 = p3x;y3 = p3y;x4 = p4x;y4 = p4y;}x1 += worldOriginX;y1 += worldOriginY;x2 += worldOriginX;y2 += worldOriginY;x3 += worldOriginX;y3 += worldOriginY;x4 += worldOriginX;y4 += worldOriginY;float u = srcX * invTexWidth;float v = (srcY + srcHeight) * invTexHeight;float u2 = (srcX + srcWidth) * invTexWidth;float v2 = srcY * invTexHeight;if (flipX) {float tmp = u;u = u2;u2 = tmp;}if (flipY) {float tmp = v;v = v2;v2 = tmp;}float color = this.color;int idx = this.vertexIndex;vertices[idx++] = x1;vertices[idx++] = y1;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v;vertices[idx++] = x2;vertices[idx++] = y2;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v2;vertices[idx++] = x3;vertices[idx++] = y3;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v2;vertices[idx++] = x4;vertices[idx++] = y4;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v;this.vertexIndex = idx;}
public void draw(Texture texture, float x, float y, float width, float height, int srcX, int srcY, int srcWidth, int srcHeight, boolean flipX, boolean flipY) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + 6 > triangles.length || vertexIndex + SPRITE_SIZE > vertices.length)flush();int triangleIndex = this.triangleIndex;final int startVertex = vertexIndex / VERTEX_SIZE;triangles[triangleIndex++] = (short) startVertex;triangles[triangleIndex++] = (short) (startVertex + 1);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 3);triangles[triangleIndex++] = (short) startVertex;this.triangleIndex = triangleIndex;float u = srcX * invTexWidth;float v = (srcY + srcHeight) * invTexHeight;float u2 = (srcX + srcWidth) * invTexWidth;float v2 = srcY * invTexHeight;final float fx2 = x + width;final float fy2 = y + height;if (flipX) {float tmp = u;u = u2;u2 = tmp;}if (flipY) {float tmp = v;v = v2;v2 = tmp;}float color = this.color;int idx = this.vertexIndex;vertices[idx++] = x;vertices[idx++] = y;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v;vertices[idx++] = x;vertices[idx++] = fy2;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v2;vertices[idx++] = fx2;vertices[idx++] = fy2;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v2;vertices[idx++] = fx2;vertices[idx++] = y;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v;this.vertexIndex = idx;}
public void draw(Texture texture, float x, float y, int srcX, int srcY, int srcWidth, int srcHeight) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + 6 > triangles.length || vertexIndex + SPRITE_SIZE > vertices.length)flush();int triangleIndex = this.triangleIndex;final int startVertex = vertexIndex / VERTEX_SIZE;triangles[triangleIndex++] = (short) startVertex;triangles[triangleIndex++] = (short) (startVertex + 1);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 3);triangles[triangleIndex++] = (short) startVertex;this.triangleIndex = triangleIndex;final float u = srcX * invTexWidth;final float v = (srcY + srcHeight) * invTexHeight;final float u2 = (srcX + srcWidth) * invTexWidth;final float v2 = srcY * invTexHeight;final float fx2 = x + srcWidth;final float fy2 = y + srcHeight;float color = this.color;int idx = this.vertexIndex;vertices[idx++] = x;vertices[idx++] = y;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v;vertices[idx++] = x;vertices[idx++] = fy2;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v2;vertices[idx++] = fx2;vertices[idx++] = fy2;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v2;vertices[idx++] = fx2;vertices[idx++] = y;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v;this.vertexIndex = idx;}
public void draw(Texture texture, float x, float y, float width, float height, float u, float v, float u2, float v2) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + 6 > triangles.length || vertexIndex + SPRITE_SIZE > vertices.length)flush();int triangleIndex = this.triangleIndex;final int startVertex = vertexIndex / VERTEX_SIZE;triangles[triangleIndex++] = (short) startVertex;triangles[triangleIndex++] = (short) (startVertex + 1);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 3);triangles[triangleIndex++] = (short) startVertex;this.triangleIndex = triangleIndex;final float fx2 = x + width;final float fy2 = y + height;float color = this.color;int idx = this.vertexIndex;vertices[idx++] = x;vertices[idx++] = y;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v;vertices[idx++] = x;vertices[idx++] = fy2;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v2;vertices[idx++] = fx2;vertices[idx++] = fy2;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v2;vertices[idx++] = fx2;vertices[idx++] = y;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v;this.vertexIndex = idx;}
public void draw(Texture texture, float x, float y) {draw(texture, x, y, texture.getWidth(), texture.getHeight());}
public void draw(Texture texture, float x, float y, float width, float height) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + 6 > triangles.length || vertexIndex + SPRITE_SIZE > vertices.length)flush();int triangleIndex = this.triangleIndex;final int startVertex = vertexIndex / VERTEX_SIZE;triangles[triangleIndex++] = (short) startVertex;triangles[triangleIndex++] = (short) (startVertex + 1);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 3);triangles[triangleIndex++] = (short) startVertex;this.triangleIndex = triangleIndex;final float fx2 = x + width;final float fy2 = y + height;final float u = 0;final float v = 1;final float u2 = 1;final float v2 = 0;float color = this.color;int idx = this.vertexIndex;vertices[idx++] = x;vertices[idx++] = y;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v;vertices[idx++] = x;vertices[idx++] = fy2;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v2;vertices[idx++] = fx2;vertices[idx++] = fy2;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v2;vertices[idx++] = fx2;vertices[idx++] = y;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v;this.vertexIndex = idx;}
public void draw(Texture texture, float[] spriteVertices, int offset, int count) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;final int triangleCount = count / SPRITE_SIZE * 6;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + triangleCount > triangles.length || vertexIndex + count > vertices.length)flush();final int vertexIndex = this.vertexIndex;int triangleIndex = this.triangleIndex;short vertex = (short) (vertexIndex / VERTEX_SIZE);for (int n = triangleIndex + triangleCount; triangleIndex < n; triangleIndex += 6, vertex += 4) {triangles[triangleIndex] = vertex;triangles[triangleIndex + 1] = (short) (vertex + 1);triangles[triangleIndex + 2] = (short) (vertex + 2);triangles[triangleIndex + 3] = (short) (vertex + 2);triangles[triangleIndex + 4] = (short) (vertex + 3);triangles[triangleIndex + 5] = vertex;}this.triangleIndex = triangleIndex;System.arraycopy(spriteVertices, offset, vertices, vertexIndex, count);this.vertexIndex += count;}
public void draw(TextureRegion region, float x, float y) {draw(region, x, y, region.getRegionWidth(), region.getRegionHeight());}
public void draw(TextureRegion region, float x, float y, float width, float height) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;Texture texture = region.texture;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + 6 > triangles.length || vertexIndex + SPRITE_SIZE > vertices.length)flush();int triangleIndex = this.triangleIndex;final int startVertex = vertexIndex / VERTEX_SIZE;triangles[triangleIndex++] = (short) startVertex;triangles[triangleIndex++] = (short) (startVertex + 1);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 3);triangles[triangleIndex++] = (short) startVertex;this.triangleIndex = triangleIndex;final float fx2 = x + width;final float fy2 = y + height;final float u = region.u;final float v = region.v2;final float u2 = region.u2;final float v2 = region.v;float color = this.color;int idx = this.vertexIndex;vertices[idx++] = x;vertices[idx++] = y;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v;vertices[idx++] = x;vertices[idx++] = fy2;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v2;vertices[idx++] = fx2;vertices[idx++] = fy2;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v2;vertices[idx++] = fx2;vertices[idx++] = y;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v;this.vertexIndex = idx;}
public void draw(TextureRegion region, float x, float y, float originX, float originY, float width, float height, float scaleX, float scaleY, float rotation) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;Texture texture = region.texture;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + 6 > triangles.length || vertexIndex + SPRITE_SIZE > vertices.length)flush();int triangleIndex = this.triangleIndex;final int startVertex = vertexIndex / VERTEX_SIZE;triangles[triangleIndex++] = (short) startVertex;triangles[triangleIndex++] = (short) (startVertex + 1);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 3);triangles[triangleIndex++] = (short) startVertex;this.triangleIndex = triangleIndex;// bottom left and top right corner points relative to originfinal float worldOriginX = x + originX;final float worldOriginY = y + originY;float fx = -originX;float fy = -originY;float fx2 = width - originX;float fy2 = height - originY;// scaleif (scaleX != 1 || scaleY != 1) {fx *= scaleX;fy *= scaleY;fx2 *= scaleX;fy2 *= scaleY;}// construct corner points, start from top left and go counter clockwisefinal float p1x = fx;final float p1y = fy;final float p2x = fx;final float p2y = fy2;final float p3x = fx2;final float p3y = fy2;final float p4x = fx2;final float p4y = fy;float x1;float y1;float x2;float y2;float x3;float y3;float x4;float y4;// rotateif (rotation != 0) {final float cos = MathUtils.cosDeg(rotation);final float sin = MathUtils.sinDeg(rotation);x1 = cos * p1x - sin * p1y;y1 = sin * p1x + cos * p1y;x2 = cos * p2x - sin * p2y;y2 = sin * p2x + cos * p2y;x3 = cos * p3x - sin * p3y;y3 = sin * p3x + cos * p3y;x4 = x1 + (x3 - x2);y4 = y3 - (y2 - y1);} else {x1 = p1x;y1 = p1y;x2 = p2x;y2 = p2y;x3 = p3x;y3 = p3y;x4 = p4x;y4 = p4y;}x1 += worldOriginX;y1 += worldOriginY;x2 += worldOriginX;y2 += worldOriginY;x3 += worldOriginX;y3 += worldOriginY;x4 += worldOriginX;y4 += worldOriginY;final float u = region.u;final float v = region.v2;final float u2 = region.u2;final float v2 = region.v;float color = this.color;int idx = this.vertexIndex;vertices[idx++] = x1;vertices[idx++] = y1;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v;vertices[idx++] = x2;vertices[idx++] = y2;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v2;vertices[idx++] = x3;vertices[idx++] = y3;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v2;vertices[idx++] = x4;vertices[idx++] = y4;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v;this.vertexIndex = idx;}
public void draw(TextureRegion region, float x, float y, float originX, float originY, float width, float height, float scaleX, float scaleY, float rotation, boolean clockwise) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;Texture texture = region.texture;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + 6 > triangles.length || vertexIndex + SPRITE_SIZE > vertices.length)flush();int triangleIndex = this.triangleIndex;final int startVertex = vertexIndex / VERTEX_SIZE;triangles[triangleIndex++] = (short) startVertex;triangles[triangleIndex++] = (short) (startVertex + 1);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 3);triangles[triangleIndex++] = (short) startVertex;this.triangleIndex = triangleIndex;// bottom left and top right corner points relative to originfinal float worldOriginX = x + originX;final float worldOriginY = y + originY;float fx = -originX;float fy = -originY;float fx2 = width - originX;float fy2 = height - originY;// scaleif (scaleX != 1 || scaleY != 1) {fx *= scaleX;fy *= scaleY;fx2 *= scaleX;fy2 *= scaleY;}// construct corner points, start from top left and go counter clockwisefinal float p1x = fx;final float p1y = fy;final float p2x = fx;final float p2y = fy2;final float p3x = fx2;final float p3y = fy2;final float p4x = fx2;final float p4y = fy;float x1;float y1;float x2;float y2;float x3;float y3;float x4;float y4;// rotateif (rotation != 0) {final float cos = MathUtils.cosDeg(rotation);final float sin = MathUtils.sinDeg(rotation);x1 = cos * p1x - sin * p1y;y1 = sin * p1x + cos * p1y;x2 = cos * p2x - sin * p2y;y2 = sin * p2x + cos * p2y;x3 = cos * p3x - sin * p3y;y3 = sin * p3x + cos * p3y;x4 = x1 + (x3 - x2);y4 = y3 - (y2 - y1);} else {x1 = p1x;y1 = p1y;x2 = p2x;y2 = p2y;x3 = p3x;y3 = p3y;x4 = p4x;y4 = p4y;}x1 += worldOriginX;y1 += worldOriginY;x2 += worldOriginX;y2 += worldOriginY;x3 += worldOriginX;y3 += worldOriginY;x4 += worldOriginX;y4 += worldOriginY;float u1, v1, u2, v2, u3, v3, u4, v4;if (clockwise) {u1 = region.u2;v1 = region.v2;u2 = region.u;v2 = region.v2;u3 = region.u;v3 = region.v;u4 = region.u2;v4 = region.v;} else {u1 = region.u;v1 = region.v;u2 = region.u2;v2 = region.v;u3 = region.u2;v3 = region.v2;u4 = region.u;v4 = region.v2;}float color = this.color;int idx = this.vertexIndex;vertices[idx++] = x1;vertices[idx++] = y1;vertices[idx++] = color;vertices[idx++] = u1;vertices[idx++] = v1;vertices[idx++] = x2;vertices[idx++] = y2;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v2;vertices[idx++] = x3;vertices[idx++] = y3;vertices[idx++] = color;vertices[idx++] = u3;vertices[idx++] = v3;vertices[idx++] = x4;vertices[idx++] = y4;vertices[idx++] = color;vertices[idx++] = u4;vertices[idx++] = v4;this.vertexIndex = idx;}
public void draw(TextureRegion region, float width, float height, Affine2 transform) {if (!drawing)throw new IllegalStateException("PolygonSpriteBatch.begin must be called before draw.");final short[] triangles = this.triangles;final float[] vertices = this.vertices;Texture texture = region.texture;if (texture != lastTexture)switchTexture(texture);else if (//triangleIndex + 6 > triangles.length || vertexIndex + SPRITE_SIZE > vertices.length)flush();int triangleIndex = this.triangleIndex;final int startVertex = vertexIndex / VERTEX_SIZE;triangles[triangleIndex++] = (short) startVertex;triangles[triangleIndex++] = (short) (startVertex + 1);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 2);triangles[triangleIndex++] = (short) (startVertex + 3);triangles[triangleIndex++] = (short) startVertex;this.triangleIndex = triangleIndex;// construct corner pointsfloat x1 = transform.m02;float y1 = transform.m12;float x2 = transform.m01 * height + transform.m02;float y2 = transform.m11 * height + transform.m12;float x3 = transform.m00 * width + transform.m01 * height + transform.m02;float y3 = transform.m10 * width + transform.m11 * height + transform.m12;float x4 = transform.m00 * width + transform.m02;float y4 = transform.m10 * width + transform.m12;float u = region.u;float v = region.v2;float u2 = region.u2;float v2 = region.v;float color = this.color;int idx = vertexIndex;vertices[idx++] = x1;vertices[idx++] = y1;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v;vertices[idx++] = x2;vertices[idx++] = y2;vertices[idx++] = color;vertices[idx++] = u;vertices[idx++] = v2;vertices[idx++] = x3;vertices[idx++] = y3;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v2;vertices[idx++] = x4;vertices[idx++] = y4;vertices[idx++] = color;vertices[idx++] = u2;vertices[idx++] = v;vertexIndex = idx;}
public void flush() {if (vertexIndex == 0)return;renderCalls++;totalRenderCalls++;int trianglesInBatch = triangleIndex;if (trianglesInBatch > maxTrianglesInBatch)maxTrianglesInBatch = trianglesInBatch;lastTexture.bind();Mesh mesh = this.mesh;mesh.setVertices(vertices, 0, vertexIndex);mesh.setIndices(triangles, 0, triangleIndex);if (blendingDisabled) {Gdx.gl.glDisable(GL20.GL_BLEND);} else {Gdx.gl.glEnable(GL20.GL_BLEND);if (blendSrcFunc != -1)Gdx.gl.glBlendFunc(blendSrcFunc, blendDstFunc);}mesh.render(customShader != null ? customShader : shader, GL20.GL_TRIANGLES, 0, trianglesInBatch);vertexIndex = 0;triangleIndex = 0;}
public void disableBlending() {flush();blendingDisabled = true;}
public void enableBlending() {flush();blendingDisabled = false;}
public void setBlendFunction(int srcFunc, int dstFunc) {if (blendSrcFunc == srcFunc && blendDstFunc == dstFunc)return;flush();blendSrcFunc = srcFunc;blendDstFunc = dstFunc;}
public int getBlendSrcFunc() {return blendSrcFunc;}
public int getBlendDstFunc() {return blendDstFunc;}
public void dispose() {mesh.dispose();if (ownsShader && shader != null)shader.dispose();}
public Matrix4 getProjectionMatrix() {return projectionMatrix;}
public Matrix4 getTransformMatrix() {return transformMatrix;}
public void setProjectionMatrix(Matrix4 projection) {if (drawing)flush();projectionMatrix.set(projection);if (drawing)setupMatrices();}
public void setTransformMatrix(Matrix4 transform) {if (drawing)flush();transformMatrix.set(transform);if (drawing)setupMatrices();}
private void setupMatrices() {combinedMatrix.set(projectionMatrix).mul(transformMatrix);if (customShader != null) {customShader.setUniformMatrix("u_projTrans", combinedMatrix);customShader.setUniformi("u_texture", 0);} else {shader.setUniformMatrix("u_projTrans", combinedMatrix);shader.setUniformi("u_texture", 0);}}
private void switchTexture(Texture texture) {flush();lastTexture = texture;invTexWidth = 1.0f / texture.getWidth();invTexHeight = 1.0f / texture.getHeight();}
public void setShader(ShaderProgram shader) {if (drawing) {flush();if (customShader != null)customShader.end();elsethis.shader.end();}customShader = shader;if (drawing) {if (customShader != null)customShader.begin();elsethis.shader.begin();setupMatrices();}}
public ShaderProgram getShader() {if (customShader == null) {return shader;}return customShader;}
public boolean isBlendingEnabled() {return !blendingDisabled;}
public boolean isDrawing() {return drawing;}